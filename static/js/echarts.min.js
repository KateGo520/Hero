! function(t, e) {
	"object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.echarts = {})
}(this, function(t) {
	"use strict";

	function e(t) {
		var e = {},
			i = {},
			n = t.match(/Firefox\/([\d.]+)/),
			r = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/),
			a = t.match(/Edge\/([\d.]+)/),
			o = /micromessenger/i.test(t);
		return n && (i.firefox = !0, i.version = n[1]), r && (i.ie = !0, i.version = r[1]), a && (i.edge = !0, i.version = a[1]), o && (i.weChat = !0), {
			browser: i,
			os: e,
			node: !1,
			canvasSupported: !!document.createElement("canvas").getContext,
			svgSupported: "undefined" != typeof SVGRect,
			touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge,
			pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 11),
			domSupported: "undefined" != typeof document
		}
	}

	function i(t, e) {
		"createCanvas" === t && (Yp = null), Xp[t] = e
	}

	function n(t) {
		if (null == t || "object" != typeof t) return t;
		var e = t,
			i = Np.call(t);
		if ("[object Array]" === i) {
			if (!B(t)) {
				e = [];
				for (var r = 0, a = t.length; a > r; r++) e[r] = n(t[r])
			}
		} else if (Rp[i]) {
			if (!B(t)) {
				var o = t.constructor;
				if (t.constructor.from) e = o.from(t);
				else {
					e = new o(t.length);
					for (var r = 0, a = t.length; a > r; r++) e[r] = n(t[r])
				}
			}
		} else if (!Bp[i] && !B(t) && !T(t)) {
			e = {};
			for (var s in t) t.hasOwnProperty(s) && (e[s] = n(t[s]))
		}
		return e
	}

	function r(t, e, i) {
		if (!S(e) || !S(t)) return i ? n(e) : t;
		for (var a in e)
			if (e.hasOwnProperty(a)) {
				var o = t[a],
					s = e[a];
				!S(s) || !S(o) || x(s) || x(o) || T(s) || T(o) || M(s) || M(o) || B(s) || B(o) ? !i && a in t || (t[a] = n(e[a], !0)) : r(o, s, i)
			}
		return t
	}

	function a(t, e) {
		for (var i = t[0], n = 1, a = t.length; a > n; n++) i = r(i, t[n], e);
		return i
	}

	function o(t, e) {
		for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
		return t
	}

	function s(t, e, i) {
		for (var n in e) e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
		return t
	}

	function l() {
		return Yp || (Yp = jp().getContext("2d")), Yp
	}

	function u(t, e) {
		if (t) {
			if (t.indexOf) return t.indexOf(e);
			for (var i = 0, n = t.length; n > i; i++)
				if (t[i] === e) return i
		}
		return -1
	}

	function h(t, e) {
		function i() {}
		var n = t.prototype;
		i.prototype = e.prototype, t.prototype = new i;
		for (var r in n) n.hasOwnProperty(r) && (t.prototype[r] = n[r]);
		t.prototype.constructor = t, t.superClass = e
	}

	function c(t, e, i) {
		t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, s(t, e, i)
	}

	function d(t) {
		return t ? "string" == typeof t ? !1 : "number" == typeof t.length : void 0
	}

	function f(t, e, i) {
		if (t && e)
			if (t.forEach && t.forEach === Vp) t.forEach(e, i);
			else if (t.length === +t.length)
			for (var n = 0, r = t.length; r > n; n++) e.call(i, t[n], n, t);
		else
			for (var a in t) t.hasOwnProperty(a) && e.call(i, t[a], a, t)
	}

	function p(t, e, i) {
		if (t && e) {
			if (t.map && t.map === Gp) return t.map(e, i);
			for (var n = [], r = 0, a = t.length; a > r; r++) n.push(e.call(i, t[r], r, t));
			return n
		}
	}

	function g(t, e, i, n) {
		if (t && e) {
			if (t.reduce && t.reduce === Up) return t.reduce(e, i, n);
			for (var r = 0, a = t.length; a > r; r++) i = e.call(n, i, t[r], r, t);
			return i
		}
	}

	function v(t, e, i) {
		if (t && e) {
			if (t.filter && t.filter === Hp) return t.filter(e, i);
			for (var n = [], r = 0, a = t.length; a > r; r++) e.call(i, t[r], r, t) && n.push(t[r]);
			return n
		}
	}

	function m(t, e, i) {
		if (t && e)
			for (var n = 0, r = t.length; r > n; n++)
				if (e.call(i, t[n], n, t)) return t[n]
	}

	function y(t, e) {
		var i = Wp.call(arguments, 2);
		return function() {
			return t.apply(e, i.concat(Wp.call(arguments)))
		}
	}

	function _(t) {
		var e = Wp.call(arguments, 1);
		return function() {
			return t.apply(this, e.concat(Wp.call(arguments)))
		}
	}

	function x(t) {
		return "[object Array]" === Np.call(t)
	}

	function w(t) {
		return "function" == typeof t
	}

	function b(t) {
		return "[object String]" === Np.call(t)
	}

	function S(t) {
		var e = typeof t;
		return "function" === e || !!t && "object" === e
	}

	function M(t) {
		return !!Bp[Np.call(t)]
	}

	function I(t) {
		return !!Rp[Np.call(t)]
	}

	function T(t) {
		return "object" == typeof t && "number" == typeof t.nodeType && "object" == typeof t.ownerDocument
	}

	function C(t) {
		return t !== t
	}

	function D() {
		for (var t = 0, e = arguments.length; e > t; t++)
			if (null != arguments[t]) return arguments[t]
	}

	function k(t, e) {
		return null != t ? t : e
	}

	function A(t, e, i) {
		return null != t ? t : null != e ? e : i
	}

	function P() {
		return Function.call.apply(Wp, arguments)
	}

	function L(t) {
		if ("number" == typeof t) return [t, t, t, t];
		var e = t.length;
		return 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
	}

	function O(t, e) {
		if (!t) throw new Error(e)
	}

	function E(t) {
		return null == t ? null : "function" == typeof t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
	}

	function z(t) {
		t[qp] = !0
	}

	function B(t) {
		return t[qp]
	}

	function R(t) {
		function e(t, e) {
			i ? n.set(t, e) : n.set(e, t)
		}
		var i = x(t);
		this.data = {};
		var n = this;
		t instanceof R ? t.each(e) : t && f(t, e)
	}

	function N(t) {
		return new R(t)
	}

	function F(t, e) {
		for (var i = new t.constructor(t.length + e.length), n = 0; n < t.length; n++) i[n] = t[n];
		var r = t.length;
		for (n = 0; n < e.length; n++) i[n + r] = e[n];
		return i
	}

	function V() {}

	function H(t, e) {
		var i = new Kp(2);
		return null == t && (t = 0), null == e && (e = 0), i[0] = t, i[1] = e, i
	}

	function W(t, e) {
		return t[0] = e[0], t[1] = e[1], t
	}

	function G(t) {
		var e = new Kp(2);
		return e[0] = t[0], e[1] = t[1], e
	}

	function U(t, e, i) {
		return t[0] = e, t[1] = i, t
	}

	function X(t, e, i) {
		return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
	}

	function j(t, e, i, n) {
		return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t
	}

	function Y(t, e, i) {
		return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
	}

	function q(t) {
		return Math.sqrt(Z(t))
	}

	function Z(t) {
		return t[0] * t[0] + t[1] * t[1]
	}

	function K(t, e, i) {
		return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
	}

	function $(t, e, i) {
		return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
	}

	function Q(t, e) {
		return t[0] * e[0] + t[1] * e[1]
	}

	function J(t, e, i) {
		return t[0] = e[0] * i, t[1] = e[1] * i, t
	}

	function te(t, e) {
		var i = q(e);
		return 0 === i ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / i, t[1] = e[1] / i), t
	}

	function ee(t, e) {
		return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
	}

	function ie(t, e) {
		return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
	}

	function ne(t, e) {
		return t[0] = -e[0], t[1] = -e[1], t
	}

	function re(t, e, i, n) {
		return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t
	}

	function ae(t, e, i) {
		var n = e[0],
			r = e[1];
		return t[0] = i[0] * n + i[2] * r + i[4], t[1] = i[1] * n + i[3] * r + i[5], t
	}

	function oe(t, e, i) {
		return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
	}

	function se(t, e, i) {
		return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
	}

	function le() {
		this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this)
	}

	function ue(t, e) {
		return {
			target: t,
			topTarget: e && e.topTarget
		}
	}

	function he(t, e) {
		var i = t._$eventProcessor;
		return null != e && i && i.normalizeQuery && (e = i.normalizeQuery(e)), e
	}

	function ce(t, e, i, n, r, a) {
		var o = t._$handlers;
		if ("function" == typeof i && (r = n, n = i, i = null), !n || !e) return t;
		i = he(t, i), o[e] || (o[e] = []);
		for (var s = 0; s < o[e].length; s++)
			if (o[e][s].h === n) return t;
		var l = {
				h: n,
				one: a,
				query: i,
				ctx: r || t,
				callAtLast: n.zrEventfulCallAtLast
			},
			u = o[e].length - 1,
			h = o[e][u];
		return h && h.callAtLast ? o[e].splice(u, 0, l) : o[e].push(l), t
	}

	function de(t, e, i, n, r, a) {
		var o = n + "-" + r,
			s = t.length;
		if (a.hasOwnProperty(o)) return a[o];
		if (1 === e) {
			var l = Math.round(Math.log((1 << s) - 1 & ~r) / rg);
			return t[i][l]
		}
		for (var u = n | 1 << i, h = i + 1; n & 1 << h;) h++;
		for (var c = 0, d = 0, f = 0; s > d; d++) {
			var p = 1 << d;
			p & r || (c += (f % 2 ? -1 : 1) * t[i][d] * de(t, e - 1, h, u, r | p, a), f++)
		}
		return a[o] = c, c
	}

	function fe(t, e) {
		var i = [
				[t[0], t[1], 1, 0, 0, 0, -e[0] * t[0], -e[0] * t[1]],
				[0, 0, 0, t[0], t[1], 1, -e[1] * t[0], -e[1] * t[1]],
				[t[2], t[3], 1, 0, 0, 0, -e[2] * t[2], -e[2] * t[3]],
				[0, 0, 0, t[2], t[3], 1, -e[3] * t[2], -e[3] * t[3]],
				[t[4], t[5], 1, 0, 0, 0, -e[4] * t[4], -e[4] * t[5]],
				[0, 0, 0, t[4], t[5], 1, -e[5] * t[4], -e[5] * t[5]],
				[t[6], t[7], 1, 0, 0, 0, -e[6] * t[6], -e[6] * t[7]],
				[0, 0, 0, t[6], t[7], 1, -e[7] * t[6], -e[7] * t[7]]
			],
			n = {},
			r = de(i, 8, 0, 0, 0, n);
		if (0 !== r) {
			for (var a = [], o = 0; 8 > o; o++)
				for (var s = 0; 8 > s; s++) null == a[s] && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * de(i, 7, 0 === o ? 1 : 0, 1 << o, 1 << s, n) / r * e[o];
			return function(t, e, i) {
				var n = e * a[6] + i * a[7] + 1;
				t[0] = (e * a[0] + i * a[1] + a[2]) / n, t[1] = (e * a[3] + i * a[4] + a[5]) / n
			}
		}
	}

	function pe(t, e, i, n, r) {
		return ge(og, e, n, r, !0) && ge(t, i, og[0], og[1])
	}

	function ge(t, e, i, n, r) {
		if (e.getBoundingClientRect && zp.domSupported && !ye(e)) {
			var a = e[ag] || (e[ag] = {}),
				o = ve(e, a),
				s = me(o, a, r);
			if (s) return s(t, i, n), !0
		}
		return !1
	}

	function ve(t, e) {
		var i = e.markers;
		if (i) return i;
		i = e.markers = [];
		for (var n = ["left", "right"], r = ["top", "bottom"], a = 0; 4 > a; a++) {
			var o = document.createElement("div"),
				s = o.style,
				l = a % 2,
				u = (a >> 1) % 2;
			s.cssText = ["position: absolute", "visibility: hidden", "padding: 0", "margin: 0", "border-width: 0", "user-select: none", "width:0", "height:0", n[l] + ":0", r[u] + ":0", n[1 - l] + ":auto", r[1 - u] + ":auto", ""].join("!important;"), t.appendChild(o), i.push(o)
		}
		return i
	}

	function me(t, e, i) {
		for (var n = i ? "invTrans" : "trans", r = e[n], a = e.srcCoords, o = !0, s = [], l = [], u = 0; 4 > u; u++) {
			var h = t[u].getBoundingClientRect(),
				c = 2 * u,
				d = h.left,
				f = h.top;
			s.push(d, f), o = o && a && d === a[c] && f === a[c + 1], l.push(t[u].offsetLeft, t[u].offsetTop)
		}
		return o && r ? r : (e.srcCoords = s, e[n] = i ? fe(l, s) : fe(s, l))
	}

	function ye(t) {
		return "CANVAS" === t.nodeName.toUpperCase()
	}

	function _e(t, e, i, n) {
		return i = i || {}, n || !zp.canvasSupported ? xe(t, e, i) : zp.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX, i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : xe(t, e, i), i
	}

	function xe(t, e, i) {
		if (zp.domSupported && t.getBoundingClientRect) {
			var n = e.clientX,
				r = e.clientY;
			if (ye(t)) {
				var a = t.getBoundingClientRect();
				return i.zrX = n - a.left, void(i.zrY = r - a.top)
			}
			if (ge(ug, t, n, r)) return i.zrX = ug[0], void(i.zrY = ug[1])
		}
		i.zrX = i.zrY = 0
	}

	function we(t) {
		return t || window.event
	}

	function be(t, e, i) {
		if (e = we(e), null != e.zrX) return e;
		var n = e.type,
			r = n && n.indexOf("touch") >= 0;
		if (r) {
			var a = "touchend" !== n ? e.targetTouches[0] : e.changedTouches[0];
			a && _e(t, a, e, i)
		} else _e(t, e, e, i), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
		var o = e.button;
		return null == e.which && void 0 !== o && lg.test(e.type) && (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), e
	}

	function Se(t, e, i, n) {
		sg ? t.addEventListener(e, i, n) : t.attachEvent("on" + e, i)
	}

	function Me(t, e, i, n) {
		sg ? t.removeEventListener(e, i, n) : t.detachEvent("on" + e, i)
	}

	function Ie(t) {
		return 2 === t.which || 3 === t.which
	}

	function Te(t) {
		var e = t[1][0] - t[0][0],
			i = t[1][1] - t[0][1];
		return Math.sqrt(e * e + i * i)
	}

	function Ce(t) {
		return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
	}

	function De(t, e, i) {
		return {
			type: t,
			event: i,
			target: e.target,
			topTarget: e.topTarget,
			cancelBubble: !1,
			offsetX: i.zrX,
			offsetY: i.zrY,
			gestureEvent: i.gestureEvent,
			pinchX: i.pinchX,
			pinchY: i.pinchY,
			pinchScale: i.pinchScale,
			wheelDelta: i.zrDelta,
			zrByTouch: i.zrByTouch,
			which: i.which,
			stop: ke
		}
	}

	function ke() {
		hg(this.event)
	}

	function Ae() {}

	function Pe(t, e, i) {
		if (t[t.rectHover ? "rectContain" : "contain"](e, i)) {
			for (var n, r = t; r;) {
				if (r.clipPath && !r.clipPath.contain(e, i)) return !1;
				r.silent && (n = !0), r = r.parent
			}
			return n ? fg : !0
		}
		return !1
	}

	function Le(t, e, i) {
		var n = t.painter;
		return 0 > e || e > n.getWidth() || 0 > i || i > n.getHeight()
	}

	function Oe() {
		var t = new vg(6);
		return Ee(t), t
	}

	function Ee(t) {
		return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
	}

	function ze(t, e) {
		return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
	}

	function Be(t, e, i) {
		var n = e[0] * i[0] + e[2] * i[1],
			r = e[1] * i[0] + e[3] * i[1],
			a = e[0] * i[2] + e[2] * i[3],
			o = e[1] * i[2] + e[3] * i[3],
			s = e[0] * i[4] + e[2] * i[5] + e[4],
			l = e[1] * i[4] + e[3] * i[5] + e[5];
		return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t
	}

	function Re(t, e, i) {
		return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t
	}

	function Ne(t, e, i) {
		var n = e[0],
			r = e[2],
			a = e[4],
			o = e[1],
			s = e[3],
			l = e[5],
			u = Math.sin(i),
			h = Math.cos(i);
		return t[0] = n * h + o * u, t[1] = -n * u + o * h, t[2] = r * h + s * u, t[3] = -r * u + h * s, t[4] = h * a + u * l, t[5] = h * l - u * a, t
	}

	function Fe(t, e, i) {
		var n = i[0],
			r = i[1];
		return t[0] = e[0] * n, t[1] = e[1] * r, t[2] = e[2] * n, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * r, t
	}

	function Ve(t, e) {
		var i = e[0],
			n = e[2],
			r = e[4],
			a = e[1],
			o = e[3],
			s = e[5],
			l = i * o - a * n;
		return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null
	}

	function He(t) {
		var e = Oe();
		return ze(e, t), e
	}

	function We(t) {
		return t > _g || -_g > t
	}

	function Ge(t) {
		this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1
	}

	function Ue(t) {
		return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t
	}

	function Xe(t) {
		return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t
	}

	function je(t) {
		return 0 > t ? 0 : t > 1 ? 1 : t
	}

	function Ye(t) {
		return Ue(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 * 255 : parseInt(t, 10))
	}

	function qe(t) {
		return je(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 : parseFloat(t))
	}

	function Ze(t, e, i) {
		return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t
	}

	function Ke(t, e, i) {
		return t + (e - t) * i
	}

	function $e(t, e, i, n, r) {
		return t[0] = e, t[1] = i, t[2] = n, t[3] = r, t
	}

	function Qe(t, e) {
		return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
	}

	function Je(t, e) {
		Og && Qe(Og, e), Og = Lg.put(t, Og || e.slice())
	}

	function ti(t, e) {
		if (t) {
			e = e || [];
			var i = Lg.get(t);
			if (i) return Qe(e, i);
			t += "";
			var n = t.replace(/ /g, "").toLowerCase();
			if (n in Pg) return Qe(e, Pg[n]), Je(t, e), e;
			if ("#" !== n.charAt(0)) {
				var r = n.indexOf("("),
					a = n.indexOf(")");
				if (-1 !== r && a + 1 === n.length) {
					var o = n.substr(0, r),
						s = n.substr(r + 1, a - (r + 1)).split(","),
						l = 1;
					switch (o) {
						case "rgba":
							if (4 !== s.length) return void $e(e, 0, 0, 0, 1);
							l = qe(s.pop());
						case "rgb":
							return 3 !== s.length ? void $e(e, 0, 0, 0, 1) : ($e(e, Ye(s[0]), Ye(s[1]), Ye(s[2]), l), Je(t, e), e);
						case "hsla":
							return 4 !== s.length ? void $e(e, 0, 0, 0, 1) : (s[3] = qe(s[3]), ei(s, e), Je(t, e), e);
						case "hsl":
							return 3 !== s.length ? void $e(e, 0, 0, 0, 1) : (ei(s, e), Je(t, e), e);
						default:
							return
					}
				}
				$e(e, 0, 0, 0, 1)
			} else {
				if (4 === n.length) {
					var u = parseInt(n.substr(1), 16);
					return u >= 0 && 4095 >= u ? ($e(e, (3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1), Je(t, e), e) : void $e(e, 0, 0, 0, 1)
				}
				if (7 === n.length) {
					var u = parseInt(n.substr(1), 16);
					return u >= 0 && 16777215 >= u ? ($e(e, (16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1), Je(t, e), e) : void $e(e, 0, 0, 0, 1)
				}
			}
		}
	}

	function ei(t, e) {
		var i = (parseFloat(t[0]) % 360 + 360) % 360 / 360,
			n = qe(t[1]),
			r = qe(t[2]),
			a = .5 >= r ? r * (n + 1) : r + n - r * n,
			o = 2 * r - a;
		return e = e || [], $e(e, Ue(255 * Ze(o, a, i + 1 / 3)), Ue(255 * Ze(o, a, i)), Ue(255 * Ze(o, a, i - 1 / 3)), 1), 4 === t.length && (e[3] = t[3]), e
	}

	function ii(t) {
		if (t) {
			var e, i, n = t[0] / 255,
				r = t[1] / 255,
				a = t[2] / 255,
				o = Math.min(n, r, a),
				s = Math.max(n, r, a),
				l = s - o,
				u = (s + o) / 2;
			if (0 === l) e = 0, i = 0;
			else {
				i = .5 > u ? l / (s + o) : l / (2 - s - o);
				var h = ((s - n) / 6 + l / 2) / l,
					c = ((s - r) / 6 + l / 2) / l,
					d = ((s - a) / 6 + l / 2) / l;
				n === s ? e = d - c : r === s ? e = 1 / 3 + h - d : a === s && (e = 2 / 3 + c - h), 0 > e && (e += 1), e > 1 && (e -= 1)
			}
			var f = [360 * e, i, u];
			return null != t[3] && f.push(t[3]), f
		}
	}

	function ni(t, e) {
		var i = ti(t);
		if (i) {
			for (var n = 0; 3 > n; n++) i[n] = 0 > e ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0, i[n] > 255 ? i[n] = 255 : t[n] < 0 && (i[n] = 0);
			return ui(i, 4 === i.length ? "rgba" : "rgb")
		}
	}

	function ri(t) {
		var e = ti(t);
		return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0
	}

	function ai(t, e, i) {
		if (e && e.length && t >= 0 && 1 >= t) {
			i = i || [];
			var n = t * (e.length - 1),
				r = Math.floor(n),
				a = Math.ceil(n),
				o = e[r],
				s = e[a],
				l = n - r;
			return i[0] = Ue(Ke(o[0], s[0], l)), i[1] = Ue(Ke(o[1], s[1], l)), i[2] = Ue(Ke(o[2], s[2], l)), i[3] = je(Ke(o[3], s[3], l)), i
		}
	}

	function oi(t, e, i) {
		if (e && e.length && t >= 0 && 1 >= t) {
			var n = t * (e.length - 1),
				r = Math.floor(n),
				a = Math.ceil(n),
				o = ti(e[r]),
				s = ti(e[a]),
				l = n - r,
				u = ui([Ue(Ke(o[0], s[0], l)), Ue(Ke(o[1], s[1], l)), Ue(Ke(o[2], s[2], l)), je(Ke(o[3], s[3], l))], "rgba");
			return i ? {
				color: u,
				leftIndex: r,
				rightIndex: a,
				value: n
			} : u
		}
	}

	function si(t, e, i, n) {
		return t = ti(t), t ? (t = ii(t), null != e && (t[0] = Xe(e)), null != i && (t[1] = qe(i)), null != n && (t[2] = qe(n)), ui(ei(t), "rgba")) : void 0
	}

	function li(t, e) {
		return t = ti(t), t && null != e ? (t[3] = je(e), ui(t, "rgba")) : void 0
	}

	function ui(t, e) {
		if (t && t.length) {
			var i = t[0] + "," + t[1] + "," + t[2];
			return ("rgba" === e || "hsva" === e || "hsla" === e) && (i += "," + t[3]), e + "(" + i + ")"
		}
	}

	function hi(t, e) {
		return t[e]
	}

	function ci(t, e, i) {
		t[e] = i
	}

	function di(t, e, i) {
		return (e - t) * i + t
	}

	function fi(t, e, i) {
		return i > .5 ? e : t
	}

	function pi(t, e, i, n, r) {
		var a = t.length;
		if (1 === r)
			for (var o = 0; a > o; o++) n[o] = di(t[o], e[o], i);
		else
			for (var s = a && t[0].length, o = 0; a > o; o++)
				for (var l = 0; s > l; l++) n[o][l] = di(t[o][l], e[o][l], i)
	}

	function gi(t, e, i) {
		var n = t.length,
			r = e.length;
		if (n !== r) {
			var a = n > r;
			if (a) t.length = r;
			else
				for (var o = n; r > o; o++) t.push(1 === i ? e[o] : Rg.call(e[o]))
		}
		for (var s = t[0] && t[0].length, o = 0; o < t.length; o++)
			if (1 === i) isNaN(t[o]) && (t[o] = e[o]);
			else
				for (var l = 0; s > l; l++) isNaN(t[o][l]) && (t[o][l] = e[o][l])
	}

	function vi(t, e, i) {
		if (t === e) return !0;
		var n = t.length;
		if (n !== e.length) return !1;
		if (1 === i) {
			for (var r = 0; n > r; r++)
				if (t[r] !== e[r]) return !1
		} else
			for (var a = t[0].length, r = 0; n > r; r++)
				for (var o = 0; a > o; o++)
					if (t[r][o] !== e[r][o]) return !1; return !0
	}

	function mi(t, e, i, n, r, a, o, s, l) {
		var u = t.length;
		if (1 === l)
			for (var h = 0; u > h; h++) s[h] = yi(t[h], e[h], i[h], n[h], r, a, o);
		else
			for (var c = t[0].length, h = 0; u > h; h++)
				for (var d = 0; c > d; d++) s[h][d] = yi(t[h][d], e[h][d], i[h][d], n[h][d], r, a, o)
	}

	function yi(t, e, i, n, r, a, o) {
		var s = .5 * (i - t),
			l = .5 * (n - e);
		return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
	}

	function _i(t) {
		if (d(t)) {
			var e = t.length;
			if (d(t[0])) {
				for (var i = [], n = 0; e > n; n++) i.push(Rg.call(t[n]));
				return i
			}
			return Rg.call(t)
		}
		return t
	}

	function xi(t) {
		return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")"
	}

	function wi(t) {
		var e = t[t.length - 1].value;
		return d(e && e[0]) ? 2 : 1
	}

	function bi(t, e, i, n, r, a) {
		var o = t._getter,
			s = t._setter,
			l = "spline" === e,
			u = n.length;
		if (u) {
			var h, c = n[0].value,
				f = d(c),
				p = !1,
				g = !1,
				v = f ? wi(n) : 0;
			n.sort(function(t, e) {
				return t.time - e.time
			}), h = n[u - 1].time;
			for (var m = [], y = [], _ = n[0].value, x = !0, w = 0; u > w; w++) {
				m.push(n[w].time / h);
				var b = n[w].value;
				if (f && vi(b, _, v) || !f && b === _ || (x = !1), _ = b, "string" == typeof b) {
					var S = ti(b);
					S ? (b = S, p = !0) : g = !0
				}
				y.push(b)
			}
			if (a || !x) {
				for (var M = y[u - 1], w = 0; u - 1 > w; w++) f ? gi(y[w], M, v) : !isNaN(y[w]) || isNaN(M) || g || p || (y[w] = M);
				f && gi(o(t._target, r), M, v);
				var I, T, C, D, k, A, P = 0,
					L = 0;
				if (p) var O = [0, 0, 0, 0];
				var E = function(t, e) {
						var i;
						if (0 > e) i = 0;
						else if (L > e) {
							for (I = Math.min(P + 1, u - 1), i = I; i >= 0 && !(m[i] <= e); i--);
							i = Math.min(i, u - 2)
						} else {
							for (i = P; u > i && !(m[i] > e); i++);
							i = Math.min(i - 1, u - 2)
						}
						P = i, L = e;
						var n = m[i + 1] - m[i];
						if (0 !== n)
							if (T = (e - m[i]) / n, l)
								if (D = y[i], C = y[0 === i ? i : i - 1], k = y[i > u - 2 ? u - 1 : i + 1], A = y[i > u - 3 ? u - 1 : i + 2], f) mi(C, D, k, A, T, T * T, T * T * T, o(t, r), v);
								else {
									var a;
									if (p) a = mi(C, D, k, A, T, T * T, T * T * T, O, 1), a = xi(O);
									else {
										if (g) return fi(D, k, T);
										a = yi(C, D, k, A, T, T * T, T * T * T)
									}
									s(t, r, a)
								}
						else if (f) pi(y[i], y[i + 1], T, o(t, r), v);
						else {
							var a;
							if (p) pi(y[i], y[i + 1], T, O, 1), a = xi(O);
							else {
								if (g) return fi(y[i], y[i + 1], T);
								a = di(y[i], y[i + 1], T)
							}
							s(t, r, a)
						}
					},
					z = new Ge({
						target: t._target,
						life: h,
						loop: t._loop,
						delay: t._delay,
						onframe: E,
						ondestroy: i
					});
				return e && "spline" !== e && (z.easing = e), z
			}
		}
	}

	function Si(t, e, i, n, r, a, o, s) {
		function l() {
			h--, h || a && a()
		}
		b(n) ? (a = r, r = n, n = 0) : w(r) ? (a = r, r = "linear", n = 0) : w(n) ? (a = n, n = 0) : w(i) ? (a = i, i = 500) : i || (i = 500), t.stopAnimation(), Mi(t, "", t, e, i, n, s);
		var u = t.animators.slice(),
			h = u.length;
		h || a && a();
		for (var c = 0; c < u.length; c++) u[c].done(l).start(r, o)
	}

	function Mi(t, e, i, n, r, a, o) {
		var s = {},
			l = 0;
		for (var u in n) n.hasOwnProperty(u) && (null != i[u] ? S(n[u]) && !d(n[u]) ? Mi(t, e ? e + "." + u : u, i[u], n[u], r, a, o) : (o ? (s[u] = i[u], Ii(t, e, u, n[u])) : s[u] = n[u], l++) : null == n[u] || o || Ii(t, e, u, n[u]));
		l > 0 && t.animate(e, !1).when(null == r ? 500 : r, s).delay(a || 0)
	}

	function Ii(t, e, i, n) {
		if (e) {
			var r = {};
			r[e] = {}, r[e][i] = n, t.attr(r)
		} else t.attr(i, n)
	}

	function Ti(t, e, i, n) {
		0 > i && (t += i, i = -i), 0 > n && (e += n, n = -n), this.x = t, this.y = e, this.width = i, this.height = n
	}

	function Ci(t) {
		for (var e = 0; t >= Kg;) e |= 1 & t, t >>= 1;
		return t + e
	}

	function Di(t, e, i, n) {
		var r = e + 1;
		if (r === i) return 1;
		if (n(t[r++], t[e]) < 0) {
			for (; i > r && n(t[r], t[r - 1]) < 0;) r++;
			ki(t, e, r)
		} else
			for (; i > r && n(t[r], t[r - 1]) >= 0;) r++;
		return r - e
	}

	function ki(t, e, i) {
		for (i--; i > e;) {
			var n = t[e];
			t[e++] = t[i], t[i--] = n
		}
	}

	function Ai(t, e, i, n, r) {
		for (n === e && n++; i > n; n++) {
			for (var a, o = t[n], s = e, l = n; l > s;) a = s + l >>> 1, r(o, t[a]) < 0 ? l = a : s = a + 1;
			var u = n - s;
			switch (u) {
				case 3:
					t[s + 3] = t[s + 2];
				case 2:
					t[s + 2] = t[s + 1];
				case 1:
					t[s + 1] = t[s];
					break;
				default:
					for (; u > 0;) t[s + u] = t[s + u - 1], u--
			}
			t[s] = o
		}
	}

	function Pi(t, e, i, n, r, a) {
		var o = 0,
			s = 0,
			l = 1;
		if (a(t, e[i + r]) > 0) {
			for (s = n - r; s > l && a(t, e[i + r + l]) > 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
			l > s && (l = s), o += r, l += r
		} else {
			for (s = r + 1; s > l && a(t, e[i + r - l]) <= 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
			l > s && (l = s);
			var u = o;
			o = r - l, l = r - u
		}
		for (o++; l > o;) {
			var h = o + (l - o >>> 1);
			a(t, e[i + h]) > 0 ? o = h + 1 : l = h
		}
		return l
	}

	function Li(t, e, i, n, r, a) {
		var o = 0,
			s = 0,
			l = 1;
		if (a(t, e[i + r]) < 0) {
			for (s = r + 1; s > l && a(t, e[i + r - l]) < 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
			l > s && (l = s);
			var u = o;
			o = r - l, l = r - u
		} else {
			for (s = n - r; s > l && a(t, e[i + r + l]) >= 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
			l > s && (l = s), o += r, l += r
		}
		for (o++; l > o;) {
			var h = o + (l - o >>> 1);
			a(t, e[i + h]) < 0 ? l = h : o = h + 1
		}
		return l
	}

	function Oi(t, e) {
		function i(t, e) {
			l[c] = t, u[c] = e, c += 1
		}

		function n() {
			for (; c > 1;) {
				var t = c - 2;
				if (t >= 1 && u[t - 1] <= u[t] + u[t + 1] || t >= 2 && u[t - 2] <= u[t] + u[t - 1]) u[t - 1] < u[t + 1] && t--;
				else if (u[t] > u[t + 1]) break;
				a(t)
			}
		}

		function r() {
			for (; c > 1;) {
				var t = c - 2;
				t > 0 && u[t - 1] < u[t + 1] && t--, a(t)
			}
		}

		function a(i) {
			var n = l[i],
				r = u[i],
				a = l[i + 1],
				h = u[i + 1];
			u[i] = r + h, i === c - 3 && (l[i + 1] = l[i + 2], u[i + 1] = u[i + 2]), c--;
			var d = Li(t[a], t, n, r, 0, e);
			n += d, r -= d, 0 !== r && (h = Pi(t[n + r - 1], t, a, h, h - 1, e), 0 !== h && (h >= r ? o(n, r, a, h) : s(n, r, a, h)))
		}

		function o(i, n, r, a) {
			var o = 0;
			for (o = 0; n > o; o++) d[o] = t[i + o];
			var s = 0,
				l = r,
				u = i;
			if (t[u++] = t[l++], 0 !== --a) {
				if (1 === n) {
					for (o = 0; a > o; o++) t[u + o] = t[l + o];
					return void(t[u + a] = d[s])
				}
				for (var c, f, p, g = h;;) {
					c = 0, f = 0, p = !1;
					do
						if (e(t[l], d[s]) < 0) {
							if (t[u++] = t[l++], f++, c = 0, 0 === --a) {
								p = !0;
								break
							}
						} else if (t[u++] = d[s++], c++, f = 0, 1 === --n) {
						p = !0;
						break
					} while (g > (c | f));
					if (p) break;
					do {
						if (c = Li(t[l], d, s, n, 0, e), 0 !== c) {
							for (o = 0; c > o; o++) t[u + o] = d[s + o];
							if (u += c, s += c, n -= c, 1 >= n) {
								p = !0;
								break
							}
						}
						if (t[u++] = t[l++], 0 === --a) {
							p = !0;
							break
						}
						if (f = Pi(d[s], t, l, a, 0, e), 0 !== f) {
							for (o = 0; f > o; o++) t[u + o] = t[l + o];
							if (u += f, l += f, a -= f, 0 === a) {
								p = !0;
								break
							}
						}
						if (t[u++] = d[s++], 1 === --n) {
							p = !0;
							break
						}
						g--
					} while (c >= $g || f >= $g);
					if (p) break;
					0 > g && (g = 0), g += 2
				}
				if (h = g, 1 > h && (h = 1), 1 === n) {
					for (o = 0; a > o; o++) t[u + o] = t[l + o];
					t[u + a] = d[s]
				} else {
					if (0 === n) throw new Error;
					for (o = 0; n > o; o++) t[u + o] = d[s + o]
				}
			} else
				for (o = 0; n > o; o++) t[u + o] = d[s + o]
		}

		function s(i, n, r, a) {
			var o = 0;
			for (o = 0; a > o; o++) d[o] = t[r + o];
			var s = i + n - 1,
				l = a - 1,
				u = r + a - 1,
				c = 0,
				f = 0;
			if (t[u--] = t[s--], 0 !== --n) {
				if (1 === a) {
					for (u -= n, s -= n, f = u + 1, c = s + 1, o = n - 1; o >= 0; o--) t[f + o] = t[c + o];
					return void(t[u] = d[l])
				}
				for (var p = h;;) {
					var g = 0,
						v = 0,
						m = !1;
					do
						if (e(d[l], t[s]) < 0) {
							if (t[u--] = t[s--], g++, v = 0, 0 === --n) {
								m = !0;
								break
							}
						} else if (t[u--] = d[l--], v++, g = 0, 1 === --a) {
						m = !0;
						break
					} while (p > (g | v));
					if (m) break;
					do {
						if (g = n - Li(d[l], t, i, n, n - 1, e), 0 !== g) {
							for (u -= g, s -= g, n -= g, f = u + 1, c = s + 1, o = g - 1; o >= 0; o--) t[f + o] = t[c + o];
							if (0 === n) {
								m = !0;
								break
							}
						}
						if (t[u--] = d[l--], 1 === --a) {
							m = !0;
							break
						}
						if (v = a - Pi(t[s], d, 0, a, a - 1, e), 0 !== v) {
							for (u -= v, l -= v, a -= v, f = u + 1, c = l + 1, o = 0; v > o; o++) t[f + o] = d[c + o];
							if (1 >= a) {
								m = !0;
								break
							}
						}
						if (t[u--] = t[s--], 0 === --n) {
							m = !0;
							break
						}
						p--
					} while (g >= $g || v >= $g);
					if (m) break;
					0 > p && (p = 0), p += 2
				}
				if (h = p, 1 > h && (h = 1), 1 === a) {
					for (u -= n, s -= n, f = u + 1, c = s + 1, o = n - 1; o >= 0; o--) t[f + o] = t[c + o];
					t[u] = d[l]
				} else {
					if (0 === a) throw new Error;
					for (c = u - (a - 1), o = 0; a > o; o++) t[c + o] = d[o]
				}
			} else
				for (c = u - (a - 1), o = 0; a > o; o++) t[c + o] = d[o]
		}
		var l, u, h = $g,
			c = 0,
			d = [];
		l = [], u = [], this.mergeRuns = n, this.forceMergeRuns = r, this.pushRun = i
	}

	function Ei(t, e, i, n) {
		i || (i = 0), n || (n = t.length);
		var r = n - i;
		if (!(2 > r)) {
			var a = 0;
			if (Kg > r) return a = Di(t, i, n, e), void Ai(t, i, n, i + a, e);
			var o = new Oi(t, e),
				s = Ci(r);
			do {
				if (a = Di(t, i, n, e), s > a) {
					var l = r;
					l > s && (l = s), Ai(t, i, i + l, i + a, e), a = l
				}
				o.pushRun(i, a), o.mergeRuns(), r -= a, i += a
			} while (0 !== r);
			o.forceMergeRuns()
		}
	}

	function zi(t, e) {
		return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel
	}

	function Bi(t, e, i) {
		var n = null == e.x ? 0 : e.x,
			r = null == e.x2 ? 1 : e.x2,
			a = null == e.y ? 0 : e.y,
			o = null == e.y2 ? 0 : e.y2;
		e.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i.height + i.y, o = o * i.height + i.y), n = isNaN(n) ? 0 : n, r = isNaN(r) ? 1 : r, a = isNaN(a) ? 0 : a, o = isNaN(o) ? 0 : o;
		var s = t.createLinearGradient(n, a, r, o);
		return s
	}

	function Ri(t, e, i) {
		var n = i.width,
			r = i.height,
			a = Math.min(n, r),
			o = null == e.x ? .5 : e.x,
			s = null == e.y ? .5 : e.y,
			l = null == e.r ? .5 : e.r;
		e.global || (o = o * n + i.x, s = s * r + i.y, l *= a);
		var u = t.createRadialGradient(o, s, 0, o, s, l);
		return u
	}

	function Ni() {
		return !1
	}

	function Fi(t, e, i) {
		var n = jp(),
			r = e.getWidth(),
			a = e.getHeight(),
			o = n.style;
		return o && (o.position = "absolute", o.left = 0, o.top = 0, o.width = r + "px", o.height = a + "px", n.setAttribute("data-zr-dom-id", t)), n.width = r * i, n.height = a * i, n
	}

	function Vi(t) {
		if ("string" == typeof t) {
			var e = cv.get(t);
			return e && e.image
		}
		return t
	}

	function Hi(t, e, i, n, r) {
		if (t) {
			if ("string" == typeof t) {
				if (e && e.__zrImageSrc === t || !i) return e;
				var a = cv.get(t),
					o = {
						hostEl: i,
						cb: n,
						cbPayload: r
					};
				return a ? (e = a.image, !Gi(e) && a.pending.push(o)) : (e = new Image, e.onload = e.onerror = Wi, cv.put(t, e.__cachedImgObj = {
					image: e,
					pending: [o]
				}), e.src = e.__zrImageSrc = t), e
			}
			return t
		}
		return e
	}

	function Wi() {
		var t = this.__cachedImgObj;
		this.onload = this.onerror = this.__cachedImgObj = null;
		for (var e = 0; e < t.pending.length; e++) {
			var i = t.pending[e],
				n = i.cb;
			n && n(this, i.cbPayload), i.hostEl.dirty()
		}
		t.pending.length = 0
	}

	function Gi(t) {
		return t && t.width && t.height
	}

	function Ui(t, e) {
		mv[t] = e
	}

	function Xi(t, e) {
		e = e || vv;
		var i = t + ":" + e;
		if (dv[i]) return dv[i];
		for (var n = (t + "").split("\n"), r = 0, a = 0, o = n.length; o > a; a++) r = Math.max(rn(n[a], e).width, r);
		return fv > pv && (fv = 0, dv = {}), fv++, dv[i] = r, r
	}

	function ji(t, e, i, n, r, a, o, s) {
		return o ? qi(t, e, i, n, r, a, o, s) : Yi(t, e, i, n, r, a, s)
	}

	function Yi(t, e, i, n, r, a, o) {
		var s = an(t, e, r, a, o),
			l = Xi(t, e);
		r && (l += r[1] + r[3]);
		var u = s.outerHeight,
			h = Zi(0, l, i),
			c = Ki(0, u, n),
			d = new Ti(h, c, l, u);
		return d.lineHeight = s.lineHeight, d
	}

	function qi(t, e, i, n, r, a, o, s) {
		var l = on(t, {
				rich: o,
				truncate: s,
				font: e,
				textAlign: i,
				textPadding: r,
				textLineHeight: a
			}),
			u = l.outerWidth,
			h = l.outerHeight,
			c = Zi(0, u, i),
			d = Ki(0, h, n);
		return new Ti(c, d, u, h)
	}

	function Zi(t, e, i) {
		return "right" === i ? t -= e : "center" === i && (t -= e / 2), t
	}

	function Ki(t, e, i) {
		return "middle" === i ? t -= e / 2 : "bottom" === i && (t -= e), t
	}

	function $i(t, e, i) {
		var n = e.textPosition,
			r = e.textDistance,
			a = i.x,
			o = i.y;
		r = r || 0;
		var s = i.height,
			l = i.width,
			u = s / 2,
			h = "left",
			c = "top";
		switch (n) {
			case "left":
				a -= r, o += u, h = "right", c = "middle";
				break;
			case "right":
				a += r + l, o += u, c = "middle";
				break;
			case "top":
				a += l / 2, o -= r, h = "center", c = "bottom";
				break;
			case "bottom":
				a += l / 2, o += s + r, h = "center";
				break;
			case "inside":
				a += l / 2, o += u, h = "center", c = "middle";
				break;
			case "insideLeft":
				a += r, o += u, c = "middle";
				break;
			case "insideRight":
				a += l - r, o += u, h = "right", c = "middle";
				break;
			case "insideTop":
				a += l / 2, o += r, h = "center";
				break;
			case "insideBottom":
				a += l / 2, o += s - r, h = "center", c = "bottom";
				break;
			case "insideTopLeft":
				a += r, o += r;
				break;
			case "insideTopRight":
				a += l - r, o += r, h = "right";
				break;
			case "insideBottomLeft":
				a += r, o += s - r, c = "bottom";
				break;
			case "insideBottomRight":
				a += l - r, o += s - r, h = "right", c = "bottom"
		}
		return t = t || {}, t.x = a, t.y = o, t.textAlign = h, t.textVerticalAlign = c, t
	}

	function Qi(t, e, i, n, r) {
		if (!e) return "";
		var a = (t + "").split("\n");
		r = Ji(e, i, n, r);
		for (var o = 0, s = a.length; s > o; o++) a[o] = tn(a[o], r);
		return a.join("\n")
	}

	function Ji(t, e, i, n) {
		n = o({}, n), n.font = e;
		var i = k(i, "...");
		n.maxIterations = k(n.maxIterations, 2);
		var r = n.minChar = k(n.minChar, 0);
		n.cnCharWidth = Xi("国", e);
		var a = n.ascCharWidth = Xi("a", e);
		n.placeholder = k(n.placeholder, "");
		for (var s = t = Math.max(0, t - 1), l = 0; r > l && s >= a; l++) s -= a;
		var u = Xi(i, e);
		return u > s && (i = "", u = 0), s = t - u, n.ellipsis = i, n.ellipsisWidth = u, n.contentWidth = s, n.containerWidth = t, n
	}

	function tn(t, e) {
		var i = e.containerWidth,
			n = e.font,
			r = e.contentWidth;
		if (!i) return "";
		var a = Xi(t, n);
		if (i >= a) return t;
		for (var o = 0;; o++) {
			if (r >= a || o >= e.maxIterations) {
				t += e.ellipsis;
				break
			}
			var s = 0 === o ? en(t, r, e.ascCharWidth, e.cnCharWidth) : a > 0 ? Math.floor(t.length * r / a) : 0;
			t = t.substr(0, s), a = Xi(t, n)
		}
		return "" === t && (t = e.placeholder), t
	}

	function en(t, e, i, n) {
		for (var r = 0, a = 0, o = t.length; o > a && e > r; a++) {
			var s = t.charCodeAt(a);
			r += s >= 0 && 127 >= s ? i : n
		}
		return a
	}

	function nn(t) {
		return Xi("国", t)
	}

	function rn(t, e) {
		return mv.measureText(t, e)
	}

	function an(t, e, i, n, r) {
		null != t && (t += "");
		var a = k(n, nn(e)),
			o = t ? t.split("\n") : [],
			s = o.length * a,
			l = s,
			u = !0;
		if (i && (l += i[0] + i[2]), t && r) {
			u = !1;
			var h = r.outerHeight,
				c = r.outerWidth;
			if (null != h && l > h) t = "", o = [];
			else if (null != c)
				for (var d = Ji(c - (i ? i[1] + i[3] : 0), e, r.ellipsis, {
						minChar: r.minChar,
						placeholder: r.placeholder
					}), f = 0, p = o.length; p > f; f++) o[f] = tn(o[f], d)
		}
		return {
			lines: o,
			height: s,
			outerHeight: l,
			lineHeight: a,
			canCacheByTextString: u
		}
	}

	function on(t, e) {
		var i = {
			lines: [],
			width: 0,
			height: 0
		};
		if (null != t && (t += ""), !t) return i;
		for (var n, r = gv.lastIndex = 0; null != (n = gv.exec(t));) {
			var a = n.index;
			a > r && sn(i, t.substring(r, a)), sn(i, n[2], n[1]), r = gv.lastIndex
		}
		r < t.length && sn(i, t.substring(r, t.length));
		var o = i.lines,
			s = 0,
			l = 0,
			u = [],
			h = e.textPadding,
			c = e.truncate,
			d = c && c.outerWidth,
			f = c && c.outerHeight;
		h && (null != d && (d -= h[1] + h[3]), null != f && (f -= h[0] + h[2]));
		for (var p = 0; p < o.length; p++) {
			for (var g = o[p], v = 0, m = 0, y = 0; y < g.tokens.length; y++) {
				var _ = g.tokens[y],
					x = _.styleName && e.rich[_.styleName] || {},
					w = _.textPadding = x.textPadding,
					b = _.font = x.font || e.font,
					S = _.textHeight = k(x.textHeight, nn(b));
				if (w && (S += w[0] + w[2]), _.height = S, _.lineHeight = A(x.textLineHeight, e.textLineHeight, S), _.textAlign = x && x.textAlign || e.textAlign, _.textVerticalAlign = x && x.textVerticalAlign || "middle", null != f && s + _.lineHeight > f) return {
					lines: [],
					width: 0,
					height: 0
				};
				_.textWidth = Xi(_.text, b);
				var M = x.textWidth,
					I = null == M || "auto" === M;
				if ("string" == typeof M && "%" === M.charAt(M.length - 1)) _.percentWidth = M, u.push(_), M = 0;
				else {
					if (I) {
						M = _.textWidth;
						var T = x.textBackgroundColor,
							C = T && T.image;
						C && (C = Vi(C), Gi(C) && (M = Math.max(M, C.width * S / C.height)))
					}
					var D = w ? w[1] + w[3] : 0;
					M += D;
					var P = null != d ? d - m : null;
					null != P && M > P && (!I || D > P ? (_.text = "", _.textWidth = M = 0) : (_.text = Qi(_.text, P - D, b, c.ellipsis, {
						minChar: c.minChar
					}), _.textWidth = Xi(_.text, b), M = _.textWidth + D))
				}
				m += _.width = M, x && (v = Math.max(v, _.lineHeight))
			}
			g.width = m, g.lineHeight = v, s += v, l = Math.max(l, m)
		}
		i.outerWidth = i.width = k(e.textWidth, l), i.outerHeight = i.height = k(e.textHeight, s), h && (i.outerWidth += h[1] + h[3], i.outerHeight += h[0] + h[2]);
		for (var p = 0; p < u.length; p++) {
			var _ = u[p],
				L = _.percentWidth;
			_.width = parseInt(L, 10) / 100 * l
		}
		return i
	}

	function sn(t, e, i) {
		for (var n = "" === e, r = e.split("\n"), a = t.lines, o = 0; o < r.length; o++) {
			var s = r[o],
				l = {
					styleName: i,
					text: s,
					isLineHolder: !s && !n
				};
			if (o) a.push({
				tokens: [l]
			});
			else {
				var u = (a[a.length - 1] || (a[0] = {
						tokens: []
					})).tokens,
					h = u.length;
				1 === h && u[0].isLineHolder ? u[0] = l : (s || !h || n) && u.push(l)
			}
		}
	}

	function ln(t) {
		var e = (t.fontSize || t.fontFamily) && [t.fontStyle, t.fontWeight, (t.fontSize || 12) + "px", t.fontFamily || "sans-serif"].join(" ");
		return e && E(e) || t.textFont || t.font
	}

	function un(t, e) {
		var i, n, r, a, o = e.x,
			s = e.y,
			l = e.width,
			u = e.height,
			h = e.r;
		0 > l && (o += l, l = -l), 0 > u && (s += u, u = -u), "number" == typeof h ? i = n = r = a = h : h instanceof Array ? 1 === h.length ? i = n = r = a = h[0] : 2 === h.length ? (i = r = h[0], n = a = h[1]) : 3 === h.length ? (i = h[0], n = a = h[1], r = h[2]) : (i = h[0], n = h[1], r = h[2], a = h[3]) : i = n = r = a = 0;
		var c;
		i + n > l && (c = i + n, i *= l / c, n *= l / c), r + a > l && (c = r + a, r *= l / c, a *= l / c), n + r > u && (c = n + r, n *= u / c, r *= u / c), i + a > u && (c = i + a, i *= u / c, a *= u / c), t.moveTo(o + i, s), t.lineTo(o + l - n, s), 0 !== n && t.arc(o + l - n, s + n, n, -Math.PI / 2, 0), t.lineTo(o + l, s + u - r), 0 !== r && t.arc(o + l - r, s + u - r, r, 0, Math.PI / 2), t.lineTo(o + a, s + u), 0 !== a && t.arc(o + a, s + u - a, a, Math.PI / 2, Math.PI), t.lineTo(o, s + i), 0 !== i && t.arc(o + i, s + i, i, Math.PI, 1.5 * Math.PI)
	}

	function hn(t) {
		return cn(t), f(t.rich, cn), t
	}

	function cn(t) {
		if (t) {
			t.font = ln(t);
			var e = t.textAlign;
			"middle" === e && (e = "center"), t.textAlign = null == e || _v[e] ? e : "left";
			var i = t.textVerticalAlign || t.textBaseline;
			"center" === i && (i = "middle"), t.textVerticalAlign = null == i || xv[i] ? i : "top";
			var n = t.textPadding;
			n && (t.textPadding = L(t.textPadding))
		}
	}

	function dn(t, e, i, n, r, a) {
		n.rich ? pn(t, e, i, n, r, a) : fn(t, e, i, n, r, a)
	}

	function fn(t, e, i, n, r, a) {
		var o, s = yn(n),
			l = !1,
			u = e.__attrCachedBy === ev.PLAIN_TEXT;
		a !== iv ? (a && (o = a.style, l = !s && u && o), e.__attrCachedBy = s ? ev.NONE : ev.PLAIN_TEXT) : u && (e.__attrCachedBy = ev.NONE);
		var h = n.font || yv;
		l && h === (o.font || yv) || (e.font = h);
		var c = t.__computedFont;
		t.__styleFont !== h && (t.__styleFont = h, c = t.__computedFont = e.font);
		var d = n.textPadding,
			f = n.textLineHeight,
			p = t.__textCotentBlock;
		(!p || t.__dirtyText) && (p = t.__textCotentBlock = an(i, c, d, f, n.truncate));
		var g = p.outerHeight,
			v = p.lines,
			m = p.lineHeight,
			y = wn(Sv, t, n, r),
			_ = y.baseX,
			x = y.baseY,
			w = y.textAlign || "left",
			b = y.textVerticalAlign;
		vn(e, n, r, _, x);
		var S = Ki(x, g, b),
			M = _,
			I = S;
		if (s || d) {
			var T = Xi(i, c),
				C = T;
			d && (C += d[1] + d[3]);
			var D = Zi(_, C, w);
			s && _n(t, e, n, D, S, C, g), d && (M = Tn(_, w, d), I += d[0])
		}
		e.textAlign = w, e.textBaseline = "middle", e.globalAlpha = n.opacity || 1;
		for (var k = 0; k < wv.length; k++) {
			var A = wv[k],
				P = A[0],
				L = A[1],
				O = n[P];
			l && O === o[P] || (e[L] = tv(e, L, O || A[2]))
		}
		I += m / 2;
		var E = n.textStrokeWidth,
			z = l ? o.textStrokeWidth : null,
			B = !l || E !== z,
			R = !l || B || n.textStroke !== o.textStroke,
			N = Sn(n.textStroke, E),
			F = Mn(n.textFill);
		if (N && (B && (e.lineWidth = E), R && (e.strokeStyle = N)), F && (l && n.textFill === o.textFill || (e.fillStyle = F)), 1 === v.length) N && e.strokeText(v[0], M, I), F && e.fillText(v[0], M, I);
		else
			for (var k = 0; k < v.length; k++) N && e.strokeText(v[k], M, I), F && e.fillText(v[k], M, I), I += m
	}

	function pn(t, e, i, n, r, a) {
		a !== iv && (e.__attrCachedBy = ev.NONE);
		var o = t.__textCotentBlock;
		(!o || t.__dirtyText) && (o = t.__textCotentBlock = on(i, n)), gn(t, e, o, n, r)
	}

	function gn(t, e, i, n, r) {
		var a = i.width,
			o = i.outerWidth,
			s = i.outerHeight,
			l = n.textPadding,
			u = wn(Sv, t, n, r),
			h = u.baseX,
			c = u.baseY,
			d = u.textAlign,
			f = u.textVerticalAlign;
		vn(e, n, r, h, c);
		var p = Zi(h, o, d),
			g = Ki(c, s, f),
			v = p,
			m = g;
		l && (v += l[3], m += l[0]);
		var y = v + a;
		yn(n) && _n(t, e, n, p, g, o, s);
		for (var _ = 0; _ < i.lines.length; _++) {
			for (var x, w = i.lines[_], b = w.tokens, S = b.length, M = w.lineHeight, I = w.width, T = 0, C = v, D = y, k = S - 1; S > T && (x = b[T], !x.textAlign || "left" === x.textAlign);) mn(t, e, x, n, M, m, C, "left"), I -= x.width, C += x.width, T++;
			for (; k >= 0 && (x = b[k], "right" === x.textAlign);) mn(t, e, x, n, M, m, D, "right"), I -= x.width, D -= x.width, k--;
			for (C += (a - (C - v) - (y - D) - I) / 2; k >= T;) x = b[T], mn(t, e, x, n, M, m, C + x.width / 2, "center"), C += x.width, T++;
			m += M
		}
	}

	function vn(t, e, i, n, r) {
		if (i && e.textRotation) {
			var a = e.textOrigin;
			"center" === a ? (n = i.width / 2 + i.x, r = i.height / 2 + i.y) : a && (n = a[0] + i.x, r = a[1] + i.y), t.translate(n, r), t.rotate(-e.textRotation), t.translate(-n, -r)
		}
	}

	function mn(t, e, i, n, r, a, o, s) {
		var l = n.rich[i.styleName] || {};
		l.text = i.text;
		var u = i.textVerticalAlign,
			h = a + r / 2;
		"top" === u ? h = a + i.height / 2 : "bottom" === u && (h = a + r - i.height / 2), !i.isLineHolder && yn(l) && _n(t, e, l, "right" === s ? o - i.width : "center" === s ? o - i.width / 2 : o, h - i.height / 2, i.width, i.height);
		var c = i.textPadding;
		c && (o = Tn(o, s, c), h -= i.height / 2 - c[2] - i.textHeight / 2), bn(e, "shadowBlur", A(l.textShadowBlur, n.textShadowBlur, 0)), bn(e, "shadowColor", l.textShadowColor || n.textShadowColor || "transparent"), bn(e, "shadowOffsetX", A(l.textShadowOffsetX, n.textShadowOffsetX, 0)), bn(e, "shadowOffsetY", A(l.textShadowOffsetY, n.textShadowOffsetY, 0)), bn(e, "textAlign", s), bn(e, "textBaseline", "middle"), bn(e, "font", i.font || yv);
		var d = Sn(l.textStroke || n.textStroke, p),
			f = Mn(l.textFill || n.textFill),
			p = k(l.textStrokeWidth, n.textStrokeWidth);
		d && (bn(e, "lineWidth", p), bn(e, "strokeStyle", d), e.strokeText(i.text, o, h)), f && (bn(e, "fillStyle", f), e.fillText(i.text, o, h))
	}

	function yn(t) {
		return !!(t.textBackgroundColor || t.textBorderWidth && t.textBorderColor)
	}

	function _n(t, e, i, n, r, a, o) {
		var s = i.textBackgroundColor,
			l = i.textBorderWidth,
			u = i.textBorderColor,
			h = b(s);
		if (bn(e, "shadowBlur", i.textBoxShadowBlur || 0), bn(e, "shadowColor", i.textBoxShadowColor || "transparent"), bn(e, "shadowOffsetX", i.textBoxShadowOffsetX || 0), bn(e, "shadowOffsetY", i.textBoxShadowOffsetY || 0), h || l && u) {
			e.beginPath();
			var c = i.textBorderRadius;
			c ? un(e, {
				x: n,
				y: r,
				width: a,
				height: o,
				r: c
			}) : e.rect(n, r, a, o), e.closePath()
		}
		if (h)
			if (bn(e, "fillStyle", s), null != i.fillOpacity) {
				var d = e.globalAlpha;
				e.globalAlpha = i.fillOpacity * i.opacity, e.fill(), e.globalAlpha = d
			} else e.fill();
		else if (S(s)) {
			var f = s.image;
			f = Hi(f, null, t, xn, s), f && Gi(f) && e.drawImage(f, n, r, a, o)
		}
		if (l && u)
			if (bn(e, "lineWidth", l), bn(e, "strokeStyle", u), null != i.strokeOpacity) {
				var d = e.globalAlpha;
				e.globalAlpha = i.strokeOpacity * i.opacity, e.stroke(), e.globalAlpha = d
			} else e.stroke()
	}

	function xn(t, e) {
		e.image = t
	}

	function wn(t, e, i, n) {
		var r = i.x || 0,
			a = i.y || 0,
			o = i.textAlign,
			s = i.textVerticalAlign;
		if (n) {
			var l = i.textPosition;
			if (l instanceof Array) r = n.x + In(l[0], n.width), a = n.y + In(l[1], n.height);
			else {
				var u = e && e.calculateTextPosition ? e.calculateTextPosition(bv, i, n) : $i(bv, i, n);
				r = u.x, a = u.y, o = o || u.textAlign, s = s || u.textVerticalAlign
			}
			var h = i.textOffset;
			h && (r += h[0], a += h[1])
		}
		return t = t || {}, t.baseX = r, t.baseY = a, t.textAlign = o, t.textVerticalAlign = s, t
	}

	function bn(t, e, i) {
		return t[e] = tv(t, e, i), t[e]
	}

	function Sn(t, e) {
		return null == t || 0 >= e || "transparent" === t || "none" === t ? null : t.image || t.colorStops ? "#000" : t
	}

	function Mn(t) {
		return null == t || "none" === t ? null : t.image || t.colorStops ? "#000" : t
	}

	function In(t, e) {
		return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
	}

	function Tn(t, e, i) {
		return "right" === e ? t - i[1] : "center" === e ? t + i[3] / 2 - i[1] / 2 : t + i[3]
	}

	function Cn(t, e) {
		return null != t && (t || e.textBackgroundColor || e.textBorderWidth && e.textBorderColor || e.textPadding)
	}

	function Dn(t) {
		t = t || {}, Xg.call(this, t);
		for (var e in t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
		this.style = new rv(t.style, this), this._rect = null, this.__clipPaths = null
	}

	function kn(t) {
		Dn.call(this, t)
	}

	function An(t) {
		return parseInt(t, 10)
	}

	function Pn(t) {
		return t ? t.__builtin__ ? !0 : "function" != typeof t.resize || "function" != typeof t.refresh ? !1 : !0 : !1
	}

	function Ln(t, e, i) {
		return Av.copy(t.getBoundingRect()), t.transform && Av.applyTransform(t.transform), Pv.width = e, Pv.height = i, !Av.intersect(Pv)
	}

	function On(t, e) {
		if (t === e) return !1;
		if (!t || !e || t.length !== e.length) return !0;
		for (var i = 0; i < t.length; i++)
			if (t[i] !== e[i]) return !0;
		return !1
	}

	function En(t, e) {
		for (var i = 0; i < t.length; i++) {
			var n = t[i];
			n.setTransform(e), e.beginPath(), n.buildPath(e, n.shape), e.clip(), n.restoreTransform(e)
		}
	}

	function zn(t, e) {
		var i = document.createElement("div");
		return i.style.cssText = ["position:relative", "width:" + t + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", i
	}

	function Bn(t) {
		return "mousewheel" === t && zp.browser.firefox ? "DOMMouseScroll" : t
	}

	function Rn(t) {
		var e = t.pointerType;
		return "pen" === e || "touch" === e
	}

	function Nn(t) {
		t.touching = !0, null != t.touchTimer && (clearTimeout(t.touchTimer), t.touchTimer = null), t.touchTimer = setTimeout(function() {
			t.touching = !1, t.touchTimer = null
		}, 700)
	}

	function Fn(t) {
		t && (t.zrByTouch = !0)
	}

	function Vn(t, e) {
		return be(t.dom, new Wn(t, e), !0)
	}

	function Hn(t, e) {
		for (var i = e, n = !1; i && 9 !== i.nodeType && !(n = i.domBelongToZr || i !== e && i === t.painterRoot);) i = i.parentNode;
		return n
	}

	function Wn(t, e) {
		this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY
	}

	function Gn(t, e) {
		var i = e.domHandlers;
		zp.pointerEventsSupported ? f(Bv.pointer, function(n) {
			Xn(e, n, function(e) {
				i[n].call(t, e)
			})
		}) : (zp.touchEventsSupported && f(Bv.touch, function(n) {
			Xn(e, n, function(r) {
				i[n].call(t, r), Nn(e)
			})
		}), f(Bv.mouse, function(n) {
			Xn(e, n, function(r) {
				r = we(r), e.touching || i[n].call(t, r)
			})
		}))
	}

	function Un(t, e) {
		function i(i) {
			function n(n) {
				n = we(n), Hn(t, n.target) || (n = Vn(t, n), e.domHandlers[i].call(t, n))
			}
			Xn(e, i, n, {
				capture: !0
			})
		}
		zp.pointerEventsSupported ? f(Rv.pointer, i) : zp.touchEventsSupported || f(Rv.mouse, i)
	}

	function Xn(t, e, i, n) {
		t.mounted[e] = i, t.listenerOpts[e] = n, Se(t.domTarget, Bn(e), i, n)
	}

	function jn(t) {
		var e = t.mounted;
		for (var i in e) e.hasOwnProperty(i) && Me(t.domTarget, Bn(i), e[i], t.listenerOpts[i]);
		t.mounted = {}
	}

	function Yn(t, e) {
		if (t._mayPointerCapture = null, zv && t._pointerCapturing ^ e) {
			t._pointerCapturing = e;
			var i = t._globalHandlerScope;
			e ? Un(t, i) : jn(i)
		}
	}

	function qn(t, e) {
		this.domTarget = t, this.domHandlers = e, this.mounted = {}, this.listenerOpts = {}, this.touchTimer = null, this.touching = !1
	}

	function Zn(t, e) {
		ng.call(this), this.dom = t, this.painterRoot = e, this._localHandlerScope = new qn(t, Fv), zv && (this._globalHandlerScope = new qn(document, Vv)), this._pointerCapturing = !1, this._mayPointerCapture = null, Gn(this, this._localHandlerScope)
	}

	function Kn(t, e) {
		var i = new jv(Op(), t, e);
		return Uv[i.id] = i, i
	}

	function $n(t) {
		if (t) t.dispose();
		else {
			for (var e in Uv) Uv.hasOwnProperty(e) && Uv[e].dispose();
			Uv = {}
		}
		return this
	}

	function Qn(t) {
		return Uv[t]
	}

	function Jn(t, e) {
		Gv[t] = e
	}

	function tr(t) {
		delete Uv[t]
	}

	function er(t) {
		return t instanceof Array ? t : null == t ? [] : [t]
	}

	function ir(t, e, i) {
		if (t) {
			t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {};
			for (var n = 0, r = i.length; r > n; n++) {
				var a = i[n];
				!t.emphasis[e].hasOwnProperty(a) && t[e].hasOwnProperty(a) && (t.emphasis[e][a] = t[e][a])
			}
		}
	}

	function nr(t) {
		return !Zv(t) || Kv(t) || t instanceof Date ? t : t.value
	}

	function rr(t) {
		return Zv(t) && !(t instanceof Array)
	}

	function ar(t, e) {
		e = (e || []).slice();
		var i = p(t || [], function(t) {
			return {
				exist: t
			}
		});
		return qv(e, function(t, n) {
			if (Zv(t)) {
				for (var r = 0; r < i.length; r++)
					if (!i[r].option && null != t.id && i[r].exist.id === t.id + "") return i[r].option = t, void(e[n] = null);
				for (var r = 0; r < i.length; r++) {
					var a = i[r].exist;
					if (!(i[r].option || null != a.id && null != t.id || null == t.name || lr(t) || lr(a) || a.name !== t.name + "")) return i[r].option = t, void(e[n] = null)
				}
			}
		}), qv(e, function(t) {
			if (Zv(t)) {
				for (var e = 0; e < i.length; e++) {
					var n = i[e].exist;
					if (!i[e].option && !lr(n) && null == t.id) {
						i[e].option = t;
						break
					}
				}
				e >= i.length && i.push({
					option: t
				})
			}
		}), i
	}

	function or(t) {
		var e = N();
		qv(t, function(t) {
			var i = t.exist;
			i && e.set(i.id, t)
		}), qv(t, function(t) {
			var i = t.option;
			O(!i || null == i.id || !e.get(i.id) || e.get(i.id) === t, "id duplicates: " + (i && i.id)), i && null != i.id && e.set(i.id, t), !t.keyInfo && (t.keyInfo = {})
		}), qv(t, function(t, i) {
			var n = t.exist,
				r = t.option,
				a = t.keyInfo;
			if (Zv(r)) {
				if (a.name = null != r.name ? r.name + "" : n ? n.name : $v + i, n) a.id = n.id;
				else if (null != r.id) a.id = r.id + "";
				else {
					var o = 0;
					do a.id = "\x00" + a.name + "\x00" + o++; while (e.get(a.id))
				}
				e.set(a.id, t)
			}
		})
	}

	function sr(t) {
		var e = t.name;
		return !(!e || !e.indexOf($v))
	}

	function lr(t) {
		return Zv(t) && t.id && 0 === (t.id + "").indexOf("\x00_ec_\x00")
	}

	function ur(t, e) {
		return null != e.dataIndexInside ? e.dataIndexInside : null != e.dataIndex ? x(e.dataIndex) ? p(e.dataIndex, function(e) {
			return t.indexOfRawIndex(e)
		}) : t.indexOfRawIndex(e.dataIndex) : null != e.name ? x(e.name) ? p(e.name, function(e) {
			return t.indexOfName(e)
		}) : t.indexOfName(e.name) : void 0
	}

	function hr() {
		var t = "__\x00ec_inner_" + Jv++ + "_" + Math.random().toFixed(5);
		return function(e) {
			return e[t] || (e[t] = {})
		}
	}

	function cr(t, e, i) {
		if (b(e)) {
			var n = {};
			n[e + "Index"] = 0, e = n
		}
		var r = i && i.defaultMainType;
		!r || dr(e, r + "Index") || dr(e, r + "Id") || dr(e, r + "Name") || (e[r + "Index"] = 0);
		var a = {};
		return qv(e, function(n, r) {
			var n = e[r];
			if ("dataIndex" === r || "dataIndexInside" === r) return void(a[r] = n);
			var o = r.match(/^(\w+)(Index|Id|Name)$/) || [],
				s = o[1],
				l = (o[2] || "").toLowerCase();
			if (!(!s || !l || null == n || "index" === l && "none" === n || i && i.includeMainTypes && u(i.includeMainTypes, s) < 0)) {
				var h = {
					mainType: s
				};
				("index" !== l || "all" !== n) && (h[l] = n);
				var c = t.queryComponents(h);
				a[s + "Models"] = c, a[s + "Model"] = c[0]
			}
		}), a
	}

	function dr(t, e) {
		return t && t.hasOwnProperty(e)
	}

	function fr(t, e, i) {
		t.setAttribute ? t.setAttribute(e, i) : t[e] = i
	}

	function pr(t, e) {
		return t.getAttribute ? t.getAttribute(e) : t[e]
	}

	function gr(t) {
		return "auto" === t ? zp.domSupported ? "html" : "richText" : t || "html"
	}

	function vr(t) {
		var e = {
			main: "",
			sub: ""
		};
		return t && (t = t.split(tm), e.main = t[0] || "", e.sub = t[1] || ""), e
	}

	function mr(t) {
		O(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal')
	}

	function yr(t) {
		t.$constructor = t, t.extend = function(t) {
			var e = this,
				i = function() {
					t.$constructor ? t.$constructor.apply(this, arguments) : e.apply(this, arguments)
				};
			return o(i.prototype, t), i.extend = this.extend, i.superCall = xr, i.superApply = wr, h(i, this), i.superClass = e, i
		}
	}

	function _r(t) {
		var e = ["__\x00is_clz", im++, Math.random().toFixed(3)].join("_");
		t.prototype[e] = !0, t.isInstance = function(t) {
			return !(!t || !t[e])
		}
	}

	function xr(t, e) {
		var i = P(arguments, 2);
		return this.superClass.prototype[e].apply(t, i)
	}

	function wr(t, e, i) {
		return this.superClass.prototype[e].apply(t, i)
	}

	function br(t, e) {
		function i(t) {
			var e = n[t.main];
			return e && e[em] || (e = n[t.main] = {}, e[em] = !0), e
		}
		e = e || {};
		var n = {};
		if (t.registerClass = function(t, e) {
				if (e)
					if (mr(e), e = vr(e), e.sub) {
						if (e.sub !== em) {
							var r = i(e);
							r[e.sub] = t
						}
					} else n[e.main] = t;
				return t
			}, t.getClass = function(t, e, i) {
				var r = n[t];
				if (r && r[em] && (r = e ? r[e] : null), i && !r) throw new Error(e ? "Component " + t + "." + (e || "") + " not exists. Load it first." : t + ".type should be specified.");
				return r
			}, t.getClassesByMainType = function(t) {
				t = vr(t);
				var e = [],
					i = n[t.main];
				return i && i[em] ? f(i, function(t, i) {
					i !== em && e.push(t)
				}) : e.push(i), e
			}, t.hasClass = function(t) {
				return t = vr(t), !!n[t.main]
			}, t.getAllClassMainTypes = function() {
				var t = [];
				return f(n, function(e, i) {
					t.push(i)
				}), t
			}, t.hasSubTypes = function(t) {
				t = vr(t);
				var e = n[t.main];
				return e && e[em]
			}, t.parseClassType = vr, e.registerWhenExtend) {
			var r = t.extend;
			r && (t.extend = function(e) {
				var i = r.call(this, e);
				return t.registerClass(i, e.type)
			})
		}
		return t
	}

	function Sr(t) {
		return t > -hm && hm > t
	}

	function Mr(t) {
		return t > hm || -hm > t
	}

	function Ir(t, e, i, n, r) {
		var a = 1 - r;
		return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i)
	}

	function Tr(t, e, i, n, r) {
		var a = 1 - r;
		return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r)
	}

	function Cr(t, e, i, n, r, a) {
		var o = n + 3 * (e - i) - t,
			s = 3 * (i - 2 * e + t),
			l = 3 * (e - t),
			u = t - r,
			h = s * s - 3 * o * l,
			c = s * l - 9 * o * u,
			d = l * l - 3 * s * u,
			f = 0;
		if (Sr(h) && Sr(c))
			if (Sr(s)) a[0] = 0;
			else {
				var p = -l / s;
				p >= 0 && 1 >= p && (a[f++] = p)
			}
		else {
			var g = c * c - 4 * h * d;
			if (Sr(g)) {
				var v = c / h,
					p = -s / o + v,
					m = -v / 2;
				p >= 0 && 1 >= p && (a[f++] = p), m >= 0 && 1 >= m && (a[f++] = m)
			} else if (g > 0) {
				var y = um(g),
					_ = h * s + 1.5 * o * (-c + y),
					x = h * s + 1.5 * o * (-c - y);
				_ = 0 > _ ? -lm(-_, fm) : lm(_, fm), x = 0 > x ? -lm(-x, fm) : lm(x, fm);
				var p = (-s - (_ + x)) / (3 * o);
				p >= 0 && 1 >= p && (a[f++] = p)
			} else {
				var w = (2 * h * s - 3 * o * c) / (2 * um(h * h * h)),
					b = Math.acos(w) / 3,
					S = um(h),
					M = Math.cos(b),
					p = (-s - 2 * S * M) / (3 * o),
					m = (-s + S * (M + dm * Math.sin(b))) / (3 * o),
					I = (-s + S * (M - dm * Math.sin(b))) / (3 * o);
				p >= 0 && 1 >= p && (a[f++] = p), m >= 0 && 1 >= m && (a[f++] = m), I >= 0 && 1 >= I && (a[f++] = I)
			}
		}
		return f
	}

	function Dr(t, e, i, n, r) {
		var a = 6 * i - 12 * e + 6 * t,
			o = 9 * e + 3 * n - 3 * t - 9 * i,
			s = 3 * e - 3 * t,
			l = 0;
		if (Sr(o)) {
			if (Mr(a)) {
				var u = -s / a;
				u >= 0 && 1 >= u && (r[l++] = u)
			}
		} else {
			var h = a * a - 4 * o * s;
			if (Sr(h)) r[0] = -a / (2 * o);
			else if (h > 0) {
				var c = um(h),
					u = (-a + c) / (2 * o),
					d = (-a - c) / (2 * o);
				u >= 0 && 1 >= u && (r[l++] = u), d >= 0 && 1 >= d && (r[l++] = d)
			}
		}
		return l
	}

	function kr(t, e, i, n, r, a) {
		var o = (e - t) * r + t,
			s = (i - e) * r + e,
			l = (n - i) * r + i,
			u = (s - o) * r + o,
			h = (l - s) * r + s,
			c = (h - u) * r + u;
		a[0] = t, a[1] = o, a[2] = u, a[3] = c, a[4] = c, a[5] = h, a[6] = l, a[7] = n
	}

	function Ar(t, e, i, n, r, a, o, s, l, u, h) {
		var c, d, f, p, g, v = .005,
			m = 1 / 0;
		pm[0] = l, pm[1] = u;
		for (var y = 0; 1 > y; y += .05) gm[0] = Ir(t, i, r, o, y), gm[1] = Ir(e, n, a, s, y), p = tg(pm, gm), m > p && (c = y, m = p);
		m = 1 / 0;
		for (var _ = 0; 32 > _ && !(cm > v); _++) d = c - v, f = c + v, gm[0] = Ir(t, i, r, o, d), gm[1] = Ir(e, n, a, s, d), p = tg(gm, pm), d >= 0 && m > p ? (c = d, m = p) : (vm[0] = Ir(t, i, r, o, f), vm[1] = Ir(e, n, a, s, f), g = tg(vm, pm), 1 >= f && m > g ? (c = f, m = g) : v *= .5);
		return h && (h[0] = Ir(t, i, r, o, c), h[1] = Ir(e, n, a, s, c)), um(m)
	}

	function Pr(t, e, i, n) {
		var r = 1 - n;
		return r * (r * t + 2 * n * e) + n * n * i
	}

	function Lr(t, e, i, n) {
		return 2 * ((1 - n) * (e - t) + n * (i - e))
	}

	function Or(t, e, i, n, r) {
		var a = t - 2 * e + i,
			o = 2 * (e - t),
			s = t - n,
			l = 0;
		if (Sr(a)) {
			if (Mr(o)) {
				var u = -s / o;
				u >= 0 && 1 >= u && (r[l++] = u)
			}
		} else {
			var h = o * o - 4 * a * s;
			if (Sr(h)) {
				var u = -o / (2 * a);
				u >= 0 && 1 >= u && (r[l++] = u)
			} else if (h > 0) {
				var c = um(h),
					u = (-o + c) / (2 * a),
					d = (-o - c) / (2 * a);
				u >= 0 && 1 >= u && (r[l++] = u), d >= 0 && 1 >= d && (r[l++] = d)
			}
		}
		return l
	}

	function Er(t, e, i) {
		var n = t + i - 2 * e;
		return 0 === n ? .5 : (t - e) / n
	}

	function zr(t, e, i, n, r) {
		var a = (e - t) * n + t,
			o = (i - e) * n + e,
			s = (o - a) * n + a;
		r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i
	}

	function Br(t, e, i, n, r, a, o, s, l) {
		var u, h = .005,
			c = 1 / 0;
		pm[0] = o, pm[1] = s;
		for (var d = 0; 1 > d; d += .05) {
			gm[0] = Pr(t, i, r, d), gm[1] = Pr(e, n, a, d);
			var f = tg(pm, gm);
			c > f && (u = d, c = f)
		}
		c = 1 / 0;
		for (var p = 0; 32 > p && !(cm > h); p++) {
			var g = u - h,
				v = u + h;
			gm[0] = Pr(t, i, r, g), gm[1] = Pr(e, n, a, g);
			var f = tg(gm, pm);
			if (g >= 0 && c > f) u = g, c = f;
			else {
				vm[0] = Pr(t, i, r, v), vm[1] = Pr(e, n, a, v);
				var m = tg(vm, pm);
				1 >= v && c > m ? (u = v, c = m) : h *= .5
			}
		}
		return l && (l[0] = Pr(t, i, r, u), l[1] = Pr(e, n, a, u)), um(c)
	}

	function Rr(t, e, i) {
		if (0 !== t.length) {
			var n, r = t[0],
				a = r[0],
				o = r[0],
				s = r[1],
				l = r[1];
			for (n = 1; n < t.length; n++) r = t[n], a = mm(a, r[0]), o = ym(o, r[0]), s = mm(s, r[1]), l = ym(l, r[1]);
			e[0] = a, e[1] = s, i[0] = o, i[1] = l
		}
	}

	function Nr(t, e, i, n, r, a) {
		r[0] = mm(t, i), r[1] = mm(e, n), a[0] = ym(t, i), a[1] = ym(e, n)
	}

	function Fr(t, e, i, n, r, a, o, s, l, u) {
		var h, c = Dr,
			d = Ir,
			f = c(t, i, r, o, Im);
		for (l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0, h = 0; f > h; h++) {
			var p = d(t, i, r, o, Im[h]);
			l[0] = mm(p, l[0]), u[0] = ym(p, u[0])
		}
		for (f = c(e, n, a, s, Tm), h = 0; f > h; h++) {
			var g = d(e, n, a, s, Tm[h]);
			l[1] = mm(g, l[1]), u[1] = ym(g, u[1])
		}
		l[0] = mm(t, l[0]), u[0] = ym(t, u[0]), l[0] = mm(o, l[0]), u[0] = ym(o, u[0]), l[1] = mm(e, l[1]), u[1] = ym(e, u[1]), l[1] = mm(s, l[1]), u[1] = ym(s, u[1])
	}

	function Vr(t, e, i, n, r, a, o, s) {
		var l = Er,
			u = Pr,
			h = ym(mm(l(t, i, r), 1), 0),
			c = ym(mm(l(e, n, a), 1), 0),
			d = u(t, i, r, h),
			f = u(e, n, a, c);
		o[0] = mm(t, r, d), o[1] = mm(e, a, f), s[0] = ym(t, r, d), s[1] = ym(e, a, f)
	}

	function Hr(t, e, i, n, r, a, o, s, l) {
		var u = oe,
			h = se,
			c = Math.abs(r - a);
		if (1e-4 > c % wm && c > 1e-4) return s[0] = t - i, s[1] = e - n, l[0] = t + i, void(l[1] = e + n);
		if (bm[0] = xm(r) * i + t, bm[1] = _m(r) * n + e, Sm[0] = xm(a) * i + t, Sm[1] = _m(a) * n + e, u(s, bm, Sm), h(l, bm, Sm), r %= wm, 0 > r && (r += wm), a %= wm, 0 > a && (a += wm), r > a && !o ? a += wm : a > r && o && (r += wm), o) {
			var d = a;
			a = r, r = d
		}
		for (var f = 0; a > f; f += Math.PI / 2) f > r && (Mm[0] = xm(f) * i + t, Mm[1] = _m(f) * n + e, u(s, Mm, s), h(l, Mm, l))
	}

	function Wr(t, e, i, n, r, a, o) {
		if (0 === r) return !1;
		var s = r,
			l = 0,
			u = t;
		if (o > e + s && o > n + s || e - s > o && n - s > o || a > t + s && a > i + s || t - s > a && i - s > a) return !1;
		if (t === i) return Math.abs(a - t) <= s / 2;
		l = (e - n) / (t - i), u = (t * n - i * e) / (t - i);
		var h = l * a - o + u,
			c = h * h / (l * l + 1);
		return s / 2 * s / 2 >= c
	}

	function Gr(t, e, i, n, r, a, o, s, l, u, h) {
		if (0 === l) return !1;
		var c = l;
		if (h > e + c && h > n + c && h > a + c && h > s + c || e - c > h && n - c > h && a - c > h && s - c > h || u > t + c && u > i + c && u > r + c && u > o + c || t - c > u && i - c > u && r - c > u && o - c > u) return !1;
		var d = Ar(t, e, i, n, r, a, o, s, u, h, null);
		return c / 2 >= d
	}

	function Ur(t, e, i, n, r, a, o, s, l) {
		if (0 === o) return !1;
		var u = o;
		if (l > e + u && l > n + u && l > a + u || e - u > l && n - u > l && a - u > l || s > t + u && s > i + u && s > r + u || t - u > s && i - u > s && r - u > s) return !1;
		var h = Br(t, e, i, n, r, a, s, l, null);
		return u / 2 >= h
	}

	function Xr(t) {
		return t %= Vm, 0 > t && (t += Vm), t
	}

	function jr(t, e, i, n, r, a, o, s, l) {
		if (0 === o) return !1;
		var u = o;
		s -= t, l -= e;
		var h = Math.sqrt(s * s + l * l);
		if (h - u > i || i > h + u) return !1;
		if (Math.abs(n - r) % Hm < 1e-4) return !0;
		if (a) {
			var c = n;
			n = Xr(r), r = Xr(c)
		} else n = Xr(n), r = Xr(r);
		n > r && (r += Hm);
		var d = Math.atan2(l, s);
		return 0 > d && (d += Hm), d >= n && r >= d || d + Hm >= n && r >= d + Hm
	}

	function Yr(t, e, i, n, r, a) {
		if (a > e && a > n || e > a && n > a) return 0;
		if (n === e) return 0;
		var o = e > n ? 1 : -1,
			s = (a - e) / (n - e);
		(1 === s || 0 === s) && (o = e > n ? .5 : -.5);
		var l = s * (i - t) + t;
		return l === r ? 1 / 0 : l > r ? o : 0
	}

	function qr(t, e) {
		return Math.abs(t - e) < Um
	}

	function Zr() {
		var t = jm[0];
		jm[0] = jm[1], jm[1] = t
	}

	function Kr(t, e, i, n, r, a, o, s, l, u) {
		if (u > e && u > n && u > a && u > s || e > u && n > u && a > u && s > u) return 0;
		var h = Cr(e, n, a, s, u, Xm);
		if (0 === h) return 0;
		for (var c, d, f = 0, p = -1, g = 0; h > g; g++) {
			var v = Xm[g],
				m = 0 === v || 1 === v ? .5 : 1,
				y = Ir(t, i, r, o, v);
			l > y || (0 > p && (p = Dr(e, n, a, s, jm), jm[1] < jm[0] && p > 1 && Zr(), c = Ir(e, n, a, s, jm[0]), p > 1 && (d = Ir(e, n, a, s, jm[1]))), f += 2 === p ? v < jm[0] ? e > c ? m : -m : v < jm[1] ? c > d ? m : -m : d > s ? m : -m : v < jm[0] ? e > c ? m : -m : c > s ? m : -m)
		}
		return f
	}

	function $r(t, e, i, n, r, a, o, s) {
		if (s > e && s > n && s > a || e > s && n > s && a > s) return 0;
		var l = Or(e, n, a, s, Xm);
		if (0 === l) return 0;
		var u = Er(e, n, a);
		if (u >= 0 && 1 >= u) {
			for (var h = 0, c = Pr(e, n, a, u), d = 0; l > d; d++) {
				var f = 0 === Xm[d] || 1 === Xm[d] ? .5 : 1,
					p = Pr(t, i, r, Xm[d]);
				o > p || (h += Xm[d] < u ? e > c ? f : -f : c > a ? f : -f)
			}
			return h
		}
		var f = 0 === Xm[0] || 1 === Xm[0] ? .5 : 1,
			p = Pr(t, i, r, Xm[0]);
		return o > p ? 0 : e > a ? f : -f
	}

	function Qr(t, e, i, n, r, a, o, s) {
		if (s -= e, s > i || -i > s) return 0;
		var l = Math.sqrt(i * i - s * s);
		Xm[0] = -l, Xm[1] = l;
		var u = Math.abs(n - r);
		if (1e-4 > u) return 0;
		if (1e-4 > u % Gm) {
			n = 0, r = Gm;
			var h = a ? 1 : -1;
			return o >= Xm[0] + t && o <= Xm[1] + t ? h : 0
		}
		if (a) {
			var l = n;
			n = Xr(r), r = Xr(l)
		} else n = Xr(n), r = Xr(r);
		n > r && (r += Gm);
		for (var c = 0, d = 0; 2 > d; d++) {
			var f = Xm[d];
			if (f + t > o) {
				var p = Math.atan2(s, f),
					h = a ? 1 : -1;
				0 > p && (p = Gm + p), (p >= n && r >= p || p + Gm >= n && r >= p + Gm) && (p > Math.PI / 2 && p < 1.5 * Math.PI && (h = -h), c += h)
			}
		}
		return c
	}

	function Jr(t, e, i, n, r) {
		for (var a = 0, o = 0, s = 0, l = 0, u = 0, h = 0; h < t.length;) {
			var c = t[h++];
			switch (c === Wm.M && h > 1 && (i || (a += Yr(o, s, l, u, n, r))), 1 === h && (o = t[h], s = t[h + 1], l = o, u = s), c) {
				case Wm.M:
					l = t[h++], u = t[h++], o = l, s = u;
					break;
				case Wm.L:
					if (i) {
						if (Wr(o, s, t[h], t[h + 1], e, n, r)) return !0
					} else a += Yr(o, s, t[h], t[h + 1], n, r) || 0;
					o = t[h++], s = t[h++];
					break;
				case Wm.C:
					if (i) {
						if (Gr(o, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], e, n, r)) return !0
					} else a += Kr(o, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], n, r) || 0;
					o = t[h++], s = t[h++];
					break;
				case Wm.Q:
					if (i) {
						if (Ur(o, s, t[h++], t[h++], t[h], t[h + 1], e, n, r)) return !0
					} else a += $r(o, s, t[h++], t[h++], t[h], t[h + 1], n, r) || 0;
					o = t[h++], s = t[h++];
					break;
				case Wm.A:
					var d = t[h++],
						f = t[h++],
						p = t[h++],
						g = t[h++],
						v = t[h++],
						m = t[h++];
					h += 1;
					var y = 1 - t[h++],
						_ = Math.cos(v) * p + d,
						x = Math.sin(v) * g + f;
					h > 1 ? a += Yr(o, s, _, x, n, r) : (l = _, u = x);
					var w = (n - d) * g / p + d;
					if (i) {
						if (jr(d, f, g, v, v + m, y, e, w, r)) return !0
					} else a += Qr(d, f, g, v, v + m, y, w, r);
					o = Math.cos(v + m) * p + d, s = Math.sin(v + m) * g + f;
					break;
				case Wm.R:
					l = o = t[h++], u = s = t[h++];
					var b = t[h++],
						S = t[h++],
						_ = l + b,
						x = u + S;
					if (i) {
						if (Wr(l, u, _, u, e, n, r) || Wr(_, u, _, x, e, n, r) || Wr(_, x, l, x, e, n, r) || Wr(l, x, l, u, e, n, r)) return !0
					} else a += Yr(_, u, _, x, n, r), a += Yr(l, x, l, u, n, r);
					break;
				case Wm.Z:
					if (i) {
						if (Wr(o, s, l, u, e, n, r)) return !0
					} else a += Yr(o, s, l, u, n, r);
					o = l, s = u
			}
		}
		return i || qr(s, u) || (a += Yr(o, s, l, u, n, r) || 0), 0 !== a
	}

	function ta(t, e, i) {
		return Jr(t, 0, !1, e, i)
	}

	function ea(t, e, i, n) {
		return Jr(t, e, !0, i, n)
	}

	function ia(t) {
		Dn.call(this, t), this.path = null
	}

	function na(t, e, i, n, r, a, o, s, l, u, h) {
		var c = l * (ry / 180),
			d = ny(c) * (t - i) / 2 + iy(c) * (e - n) / 2,
			f = -1 * iy(c) * (t - i) / 2 + ny(c) * (e - n) / 2,
			p = d * d / (o * o) + f * f / (s * s);
		p > 1 && (o *= ey(p), s *= ey(p));
		var g = (r === a ? -1 : 1) * ey((o * o * s * s - o * o * f * f - s * s * d * d) / (o * o * f * f + s * s * d * d)) || 0,
			v = g * o * f / s,
			m = g * -s * d / o,
			y = (t + i) / 2 + ny(c) * v - iy(c) * m,
			_ = (e + n) / 2 + iy(c) * v + ny(c) * m,
			x = sy([1, 0], [(d - v) / o, (f - m) / s]),
			w = [(d - v) / o, (f - m) / s],
			b = [(-1 * d - v) / o, (-1 * f - m) / s],
			S = sy(w, b);
		oy(w, b) <= -1 && (S = ry), oy(w, b) >= 1 && (S = 0), 0 === a && S > 0 && (S -= 2 * ry), 1 === a && 0 > S && (S += 2 * ry), h.addData(u, y, _, o, s, x, S, c, a)
	}

	function ra(t) {
		if (!t) return new Fm;
		for (var e, i = 0, n = 0, r = i, a = n, o = new Fm, s = Fm.CMD, l = t.match(ly), u = 0; u < l.length; u++) {
			for (var h, c = l[u], d = c.charAt(0), f = c.match(uy) || [], p = f.length, g = 0; p > g; g++) f[g] = parseFloat(f[g]);
			for (var v = 0; p > v;) {
				var m, y, _, x, w, b, S, M = i,
					I = n;
				switch (d) {
					case "l":
						i += f[v++], n += f[v++], h = s.L, o.addData(h, i, n);
						break;
					case "L":
						i = f[v++], n = f[v++], h = s.L, o.addData(h, i, n);
						break;
					case "m":
						i += f[v++], n += f[v++], h = s.M, o.addData(h, i, n), r = i, a = n, d = "l";
						break;
					case "M":
						i = f[v++], n = f[v++], h = s.M, o.addData(h, i, n), r = i, a = n, d = "L";
						break;
					case "h":
						i += f[v++], h = s.L, o.addData(h, i, n);
						break;
					case "H":
						i = f[v++], h = s.L, o.addData(h, i, n);
						break;
					case "v":
						n += f[v++], h = s.L, o.addData(h, i, n);
						break;
					case "V":
						n = f[v++], h = s.L, o.addData(h, i, n);
						break;
					case "C":
						h = s.C, o.addData(h, f[v++], f[v++], f[v++], f[v++], f[v++], f[v++]), i = f[v - 2], n = f[v - 1];
						break;
					case "c":
						h = s.C, o.addData(h, f[v++] + i, f[v++] + n, f[v++] + i, f[v++] + n, f[v++] + i, f[v++] + n), i += f[v - 2], n += f[v - 1];
						break;
					case "S":
						m = i, y = n;
						var T = o.len(),
							C = o.data;
						e === s.C && (m += i - C[T - 4], y += n - C[T - 3]), h = s.C, M = f[v++], I = f[v++], i = f[v++], n = f[v++], o.addData(h, m, y, M, I, i, n);
						break;
					case "s":
						m = i, y = n;
						var T = o.len(),
							C = o.data;
						e === s.C && (m += i - C[T - 4], y += n - C[T - 3]), h = s.C, M = i + f[v++], I = n + f[v++], i += f[v++], n += f[v++], o.addData(h, m, y, M, I, i, n);
						break;
					case "Q":
						M = f[v++], I = f[v++], i = f[v++], n = f[v++], h = s.Q, o.addData(h, M, I, i, n);
						break;
					case "q":
						M = f[v++] + i, I = f[v++] + n, i += f[v++], n += f[v++], h = s.Q, o.addData(h, M, I, i, n);
						break;
					case "T":
						m = i, y = n;
						var T = o.len(),
							C = o.data;
						e === s.Q && (m += i - C[T - 4], y += n - C[T - 3]), i = f[v++], n = f[v++], h = s.Q, o.addData(h, m, y, i, n);
						break;
					case "t":
						m = i, y = n;
						var T = o.len(),
							C = o.data;
						e === s.Q && (m += i - C[T - 4], y += n - C[T - 3]), i += f[v++], n += f[v++], h = s.Q, o.addData(h, m, y, i, n);
						break;
					case "A":
						_ = f[v++], x = f[v++], w = f[v++], b = f[v++], S = f[v++], M = i, I = n, i = f[v++], n = f[v++], h = s.A, na(M, I, i, n, b, S, _, x, w, h, o);
						break;
					case "a":
						_ = f[v++], x = f[v++], w = f[v++], b = f[v++], S = f[v++], M = i, I = n, i += f[v++], n += f[v++], h = s.A, na(M, I, i, n, b, S, _, x, w, h, o)
				}
			}("z" === d || "Z" === d) && (h = s.Z, o.addData(h), i = r, n = a), e = h
		}
		return o.toStatic(), o
	}

	function aa(t, e) {
		var i = ra(t);
		return e = e || {}, e.buildPath = function(t) {
			if (t.setData) {
				t.setData(i.data);
				var e = t.getContext();
				e && t.rebuildPath(e)
			} else {
				var e = t;
				i.rebuildPath(e)
			}
		}, e.applyTransform = function(t) {
			ty(i, t), this.dirty(!0)
		}, e
	}

	function oa(t, e) {
		return new ia(aa(t, e))
	}

	function sa(t, e) {
		return ia.extend(aa(t, e))
	}

	function la(t, e) {
		for (var i = [], n = t.length, r = 0; n > r; r++) {
			var a = t[r];
			a.path || a.createPathProxy(), a.__dirtyPath && a.buildPath(a.path, a.shape, !0), i.push(a.path)
		}
		var o = new ia(e);
		return o.createPathProxy(), o.buildPath = function(t) {
			t.appendPath(i);
			var e = t.getContext();
			e && t.rebuildPath(e)
		}, o
	}

	function ua(t, e, i, n, r, a, o) {
		var s = .5 * (i - t),
			l = .5 * (n - e);
		return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
	}

	function ha(t, e, i) {
		var n = e.points,
			r = e.smooth;
		if (n && n.length >= 2) {
			if (r && "spline" !== r) {
				var a = my(n, r, i, e.smoothConstraint);
				t.moveTo(n[0][0], n[0][1]);
				for (var o = n.length, s = 0;
					(i ? o : o - 1) > s; s++) {
					var l = a[2 * s],
						u = a[2 * s + 1],
						h = n[(s + 1) % o];
					t.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1])
				}
			} else {
				"spline" === r && (n = vy(n, i)), t.moveTo(n[0][0], n[0][1]);
				for (var s = 1, c = n.length; c > s; s++) t.lineTo(n[s][0], n[s][1])
			}
			i && t.closePath()
		}
	}

	function ca(t, e, i) {
		if (e) {
			var n = e.x1,
				r = e.x2,
				a = e.y1,
				o = e.y2;
			t.x1 = n, t.x2 = r, t.y1 = a, t.y2 = o;
			var s = i && i.lineWidth;
			s && (xy(2 * n) === xy(2 * r) && (t.x1 = t.x2 = fa(n, s, !0)), xy(2 * a) === xy(2 * o) && (t.y1 = t.y2 = fa(a, s, !0)))
		}
	}

	function da(t, e, i) {
		if (e) {
			var n = e.x,
				r = e.y,
				a = e.width,
				o = e.height;
			t.x = n, t.y = r, t.width = a, t.height = o;
			var s = i && i.lineWidth;
			s && (t.x = fa(n, s, !0), t.y = fa(r, s, !0), t.width = Math.max(fa(n + a, s, !1) - t.x, 0 === a ? 0 : 1), t.height = Math.max(fa(r + o, s, !1) - t.y, 0 === o ? 0 : 1))
		}
	}

	function fa(t, e, i) {
		if (!e) return t;
		var n = xy(2 * t);
		return (n + xy(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
	}

	function pa(t, e, i) {
		var n = t.cpx2,
			r = t.cpy2;
		return null === n || null === r ? [(i ? Tr : Ir)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? Tr : Ir)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? Lr : Pr)(t.x1, t.cpx1, t.x2, e), (i ? Lr : Pr)(t.y1, t.cpy1, t.y2, e)]
	}

	function ga(t) {
		Dn.call(this, t), this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.notClear = !0
	}

	function va(t) {
		return ia.extend(t)
	}

	function ma(t, e) {
		return sa(t, e)
	}

	function ya(t, e) {
		Wy[t] = e
	}

	function _a(t) {
		return Wy.hasOwnProperty(t) ? Wy[t] : void 0
	}

	function xa(t, e, i, n) {
		var r = oa(t, e);
		return i && ("center" === n && (i = ba(i, r.getBoundingRect())), Sa(r, i)), r
	}

	function wa(t, e, i) {
		var n = new kn({
			style: {
				image: t,
				x: e.x,
				y: e.y,
				width: e.width,
				height: e.height
			},
			onload: function(t) {
				if ("center" === i) {
					var r = {
						width: t.width,
						height: t.height
					};
					n.setStyle(ba(e, r))
				}
			}
		});
		return n
	}

	function ba(t, e) {
		var i, n = e.width / e.height,
			r = t.height * n;
		r <= t.width ? i = t.height : (r = t.width, i = r / n);
		var a = t.x + t.width / 2,
			o = t.y + t.height / 2;
		return {
			x: a - r / 2,
			y: o - i / 2,
			width: r,
			height: i
		}
	}

	function Sa(t, e) {
		if (t.applyTransform) {
			var i = t.getBoundingRect(),
				n = i.calculateTransform(e);
			t.applyTransform(n)
		}
	}

	function Ma(t) {
		return ca(t.shape, t.shape, t.style), t
	}

	function Ia(t) {
		return da(t.shape, t.shape, t.style), t
	}

	function Ta(t) {
		return null != t && "none" !== t
	}

	function Ca(t) {
		if ("string" != typeof t) return t;
		var e = Xy.get(t);
		return e || (e = ni(t, -.1), 1e4 > jy && (Xy.set(t, e), jy++)), e
	}

	function Da(t) {
		if (t.__hoverStlDirty) {
			t.__hoverStlDirty = !1;
			var e = t.__hoverStl;
			if (!e) return void(t.__cachedNormalStl = t.__cachedNormalZ2 = null);
			var i = t.__cachedNormalStl = {};
			t.__cachedNormalZ2 = t.z2;
			var n = t.style;
			for (var r in e) null != e[r] && (i[r] = n[r]);
			i.fill = n.fill, i.stroke = n.stroke
		}
	}

	function ka(t) {
		var e = t.__hoverStl;
		if (e && !t.__highlighted) {
			var i = t.__zr,
				n = t.useHoverLayer && i && "canvas" === i.painter.type;
			if (t.__highlighted = n ? "layer" : "plain", !(t.isGroup || !i && t.useHoverLayer)) {
				var r = t,
					a = t.style;
				n && (r = i.addHover(t), a = r.style), Qa(a), n || Da(r), a.extendFrom(e), Aa(a, e, "fill"), Aa(a, e, "stroke"), $a(a), n || (t.dirty(!1), t.z2 += By)
			}
		}
	}

	function Aa(t, e, i) {
		!Ta(e[i]) && Ta(t[i]) && (t[i] = Ca(t[i]))
	}

	function Pa(t) {
		var e = t.__highlighted;
		if (e && (t.__highlighted = !1, !t.isGroup))
			if ("layer" === e) t.__zr && t.__zr.removeHover(t);
			else {
				var i = t.style,
					n = t.__cachedNormalStl;
				n && (Qa(i), t.setStyle(n), $a(i));
				var r = t.__cachedNormalZ2;
				null != r && t.z2 - r === By && (t.z2 = r)
			}
	}

	function La(t, e, i) {
		var n, r = Fy,
			a = Fy;
		t.__highlighted && (r = Ny, n = !0), e(t, i), t.__highlighted && (a = Ny, n = !0), t.isGroup && t.traverse(function(t) {
			!t.isGroup && e(t, i)
		}), n && t.__highDownOnUpdate && t.__highDownOnUpdate(r, a)
	}

	function Oa(t, e) {
		e = t.__hoverStl = e !== !1 && (t.hoverStyle || e || {}), t.__hoverStlDirty = !0, t.__highlighted && (t.__cachedNormalStl = null, Pa(t), ka(t))
	}

	function Ea(t) {
		!Na(this, t) && !this.__highByOuter && La(this, ka)
	}

	function za(t) {
		!Na(this, t) && !this.__highByOuter && La(this, Pa)
	}

	function Ba(t) {
		this.__highByOuter |= 1 << (t || 0), La(this, ka)
	}

	function Ra(t) {
		!(this.__highByOuter &= ~(1 << (t || 0))) && La(this, Pa)
	}

	function Na(t, e) {
		return t.__highDownSilentOnTouch && e.zrByTouch
	}

	function Fa(t, e) {
		Va(t, !0), La(t, Oa, e)
	}

	function Va(t, e) {
		var i = e === !1;
		if (t.__highDownSilentOnTouch = t.highDownSilentOnTouch, t.__highDownOnUpdate = t.highDownOnUpdate, !i || t.__highDownDispatcher) {
			var n = i ? "off" : "on";
			t[n]("mouseover", Ea)[n]("mouseout", za), t[n]("emphasis", Ba)[n]("normal", Ra), t.__highByOuter = t.__highByOuter || 0, t.__highDownDispatcher = !i
		}
	}

	function Ha(t) {
		return !(!t || !t.__highDownDispatcher)
	}

	function Wa(t) {
		var e = Hy[t];
		return null == e && 32 >= Vy && (e = Hy[t] = Vy++), e
	}

	function Ga(t, e, i, n, r, a, o) {
		r = r || zy;
		var s, l = r.labelFetcher,
			u = r.labelDataIndex,
			h = r.labelDimIndex,
			c = r.labelProp,
			d = i.getShallow("show"),
			f = n.getShallow("show");
		(d || f) && (l && (s = l.getFormattedLabel(u, "normal", null, h, c)), null == s && (s = w(r.defaultText) ? r.defaultText(u, r) : r.defaultText));
		var p = d ? s : null,
			g = f ? k(l ? l.getFormattedLabel(u, "emphasis", null, h, c) : null, s) : null;
		(null != p || null != g) && (Xa(t, i, a, r), Xa(e, n, o, r, !0)), t.text = p, e.text = g
	}

	function Ua(t, e, i) {
		var n = t.style;
		e && (Qa(n), t.setStyle(e), $a(n)), n = t.__hoverStl, i && n && (Qa(n), o(n, i), $a(n))
	}

	function Xa(t, e, i, n, r) {
		return Ya(t, e, n, r), i && o(t, i), t
	}

	function ja(t, e, i) {
		var n, r = {
			isRectText: !0
		};
		i === !1 ? n = !0 : r.autoColor = i, Ya(t, e, r, n)
	}

	function Ya(t, e, i, n) {
		if (i = i || zy, i.isRectText) {
			var r;
			i.getTextPosition ? r = i.getTextPosition(e, n) : (r = e.getShallow("position") || (n ? null : "inside"), "outside" === r && (r = "top")), t.textPosition = r, t.textOffset = e.getShallow("offset");
			var a = e.getShallow("rotate");
			null != a && (a *= Math.PI / 180), t.textRotation = a, t.textDistance = k(e.getShallow("distance"), n ? null : 5)
		}
		var o, s = e.ecModel,
			l = s && s.option.textStyle,
			u = qa(e);
		if (u) {
			o = {};
			for (var h in u)
				if (u.hasOwnProperty(h)) {
					var c = e.getModel(["rich", h]);
					Za(o[h] = {}, c, l, i, n)
				}
		}
		return t.rich = o, Za(t, e, l, i, n, !0), i.forceRich && !i.textStyle && (i.textStyle = {}), t
	}

	function qa(t) {
		for (var e; t && t !== t.ecModel;) {
			var i = (t.option || zy).rich;
			if (i) {
				e = e || {};
				for (var n in i) i.hasOwnProperty(n) && (e[n] = 1)
			}
			t = t.parentModel
		}
		return e
	}

	function Za(t, e, i, n, r, a) {
		i = !r && i || zy, t.textFill = Ka(e.getShallow("color"), n) || i.color, t.textStroke = Ka(e.getShallow("textBorderColor"), n) || i.textBorderColor, t.textStrokeWidth = k(e.getShallow("textBorderWidth"), i.textBorderWidth), r || (a && (t.insideRollbackOpt = n, $a(t)), null == t.textFill && (t.textFill = n.autoColor)), t.fontStyle = e.getShallow("fontStyle") || i.fontStyle, t.fontWeight = e.getShallow("fontWeight") || i.fontWeight, t.fontSize = e.getShallow("fontSize") || i.fontSize, t.fontFamily = e.getShallow("fontFamily") || i.fontFamily, t.textAlign = e.getShallow("align"), t.textVerticalAlign = e.getShallow("verticalAlign") || e.getShallow("baseline"), t.textLineHeight = e.getShallow("lineHeight"), t.textWidth = e.getShallow("width"), t.textHeight = e.getShallow("height"), t.textTag = e.getShallow("tag"), a && n.disableBox || (t.textBackgroundColor = Ka(e.getShallow("backgroundColor"), n), t.textPadding = e.getShallow("padding"), t.textBorderColor = Ka(e.getShallow("borderColor"), n), t.textBorderWidth = e.getShallow("borderWidth"), t.textBorderRadius = e.getShallow("borderRadius"), t.textBoxShadowColor = e.getShallow("shadowColor"), t.textBoxShadowBlur = e.getShallow("shadowBlur"), t.textBoxShadowOffsetX = e.getShallow("shadowOffsetX"), t.textBoxShadowOffsetY = e.getShallow("shadowOffsetY")), t.textShadowColor = e.getShallow("textShadowColor") || i.textShadowColor, t.textShadowBlur = e.getShallow("textShadowBlur") || i.textShadowBlur, t.textShadowOffsetX = e.getShallow("textShadowOffsetX") || i.textShadowOffsetX, t.textShadowOffsetY = e.getShallow("textShadowOffsetY") || i.textShadowOffsetY
	}

	function Ka(t, e) {
		return "auto" !== t ? t : e && e.autoColor ? e.autoColor : null
	}

	function $a(t) {
		var e, i = t.textPosition,
			n = t.insideRollbackOpt;
		if (n && null == t.textFill) {
			var r = n.autoColor,
				a = n.isRectText,
				o = n.useInsideStyle,
				s = o !== !1 && (o === !0 || a && i && "string" == typeof i && i.indexOf("inside") >= 0),
				l = !s && null != r;
			(s || l) && (e = {
				textFill: t.textFill,
				textStroke: t.textStroke,
				textStrokeWidth: t.textStrokeWidth
			}), s && (t.textFill = "#fff", null == t.textStroke && (t.textStroke = r, null == t.textStrokeWidth && (t.textStrokeWidth = 2))), l && (t.textFill = r)
		}
		t.insideRollback = e
	}

	function Qa(t) {
		var e = t.insideRollback;
		e && (t.textFill = e.textFill, t.textStroke = e.textStroke, t.textStrokeWidth = e.textStrokeWidth, t.insideRollback = null)
	}

	function Ja(t, e) {
		var i = e && e.getModel("textStyle");
		return E([t.fontStyle || i && i.getShallow("fontStyle") || "", t.fontWeight || i && i.getShallow("fontWeight") || "", (t.fontSize || i && i.getShallow("fontSize") || 12) + "px", t.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"].join(" "))
	}

	function to(t, e, i, n, r, a) {
		"function" == typeof r && (a = r, r = null);
		var o = n && n.isAnimationEnabled();
		if (o) {
			var s = t ? "Update" : "",
				l = n.getShallow("animationDuration" + s),
				u = n.getShallow("animationEasing" + s),
				h = n.getShallow("animationDelay" + s);
			"function" == typeof h && (h = h(r, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, r) : null)), "function" == typeof l && (l = l(r)), l > 0 ? e.animateTo(i, l, h || 0, u, a, !!a) : (e.stopAnimation(), e.attr(i), a && a())
		} else e.stopAnimation(), e.attr(i), a && a()
	}

	function eo(t, e, i, n, r) {
		to(!0, t, e, i, n, r)
	}

	function io(t, e, i, n, r) {
		to(!1, t, e, i, n, r)
	}

	function no(t, e) {
		for (var i = Ee([]); t && t !== e;) Be(i, t.getLocalTransform(), i), t = t.parent;
		return i
	}

	function ro(t, e, i) {
		return e && !d(e) && (e = xg.getLocalTransform(e)), i && (e = Ve([], e)), ae([], t, e)
	}

	function ao(t, e, i) {
		var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
			r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
			a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -r : "bottom" === t ? r : 0];
		return a = ro(a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top"
	}

	function oo(t, e, i) {
		function n(t) {
			var e = {};
			return t.traverse(function(t) {
				!t.isGroup && t.anid && (e[t.anid] = t)
			}), e
		}

		function r(t) {
			var e = {
				position: G(t.position),
				rotation: t.rotation
			};
			return t.shape && (e.shape = o({}, t.shape)), e
		}
		if (t && e) {
			var a = n(t);
			e.traverse(function(t) {
				if (!t.isGroup && t.anid) {
					var e = a[t.anid];
					if (e) {
						var n = r(t);
						t.attr(r(e)), eo(t, n, i, t.dataIndex)
					}
				}
			})
		}
	}

	function so(t, e) {
		return p(t, function(t) {
			var i = t[0];
			i = Oy(i, e.x), i = Ey(i, e.x + e.width);
			var n = t[1];
			return n = Oy(n, e.y), n = Ey(n, e.y + e.height), [i, n]
		})
	}

	function lo(t, e) {
		var i = Oy(t.x, e.x),
			n = Ey(t.x + t.width, e.x + e.width),
			r = Oy(t.y, e.y),
			a = Ey(t.y + t.height, e.y + e.height);
		return n >= i && a >= r ? {
			x: i,
			y: r,
			width: n - i,
			height: a - r
		} : void 0
	}

	function uo(t, e, i) {
		e = o({
			rectHover: !0
		}, e);
		var n = e.style = {
			strokeNoScale: !0
		};
		return i = i || {
			x: -1,
			y: -1,
			width: 2,
			height: 2
		}, t ? 0 === t.indexOf("image://") ? (n.image = t.slice(8), s(n, i), new kn(e)) : xa(t.replace("path://", ""), e, i, "center") : void 0
	}

	function ho(t, e, i, n, r) {
		for (var a = 0, o = r[r.length - 1]; a < r.length; a++) {
			var s = r[a];
			if (co(t, e, i, n, s[0], s[1], o[0], o[1])) return !0;
			o = s
		}
	}

	function co(t, e, i, n, r, a, o, s) {
		var l = i - t,
			u = n - e,
			h = o - r,
			c = s - a,
			d = fo(h, c, l, u);
		if (po(d)) return !1;
		var f = t - r,
			p = e - a,
			g = fo(f, p, l, u) / d;
		if (0 > g || g > 1) return !1;
		var v = fo(f, p, h, c) / d;
		return 0 > v || v > 1 ? !1 : !0
	}

	function fo(t, e, i, n) {
		return t * n - i * e
	}

	function po(t) {
		return 1e-6 >= t && t >= -1e-6
	}

	function go(t, e, i) {
		this.parentModel = e, this.ecModel = i, this.option = t
	}

	function vo(t, e, i) {
		for (var n = 0; n < e.length && (!e[n] || (t = t && "object" == typeof t ? t[e[n]] : null, null != t)); n++);
		return null == t && i && (t = i.get(e)), t
	}

	function mo(t, e) {
		var i = Jy(t).getParent;
		return i ? i.call(t, e) : t.parentModel
	}

	function yo(t) {
		return [t || "", t_++, Math.random().toFixed(5)].join("_")
	}

	function _o(t) {
		var e = {};
		return t.registerSubTypeDefaulter = function(t, i) {
			t = vr(t), e[t.main] = i
		}, t.determineSubType = function(i, n) {
			var r = n.type;
			if (!r) {
				var a = vr(i).main;
				t.hasSubTypes(i) && e[a] && (r = e[a](n))
			}
			return r
		}, t
	}

	function xo(t, e) {
		function i(t) {
			var i = {},
				a = [];
			return f(t, function(o) {
				var s = n(i, o),
					l = s.originalDeps = e(o),
					h = r(l, t);
				s.entryCount = h.length, 0 === s.entryCount && a.push(o), f(h, function(t) {
					u(s.predecessor, t) < 0 && s.predecessor.push(t);
					var e = n(i, t);
					u(e.successor, t) < 0 && e.successor.push(o)
				})
			}), {
				graph: i,
				noEntryList: a
			}
		}

		function n(t, e) {
			return t[e] || (t[e] = {
				predecessor: [],
				successor: []
			}), t[e]
		}

		function r(t, e) {
			var i = [];
			return f(t, function(t) {
				u(e, t) >= 0 && i.push(t)
			}), i
		}
		t.topologicalTravel = function(t, e, n, r) {
			function a(t) {
				l[t].entryCount--, 0 === l[t].entryCount && u.push(t)
			}

			function o(t) {
				h[t] = !0, a(t)
			}
			if (t.length) {
				var s = i(e),
					l = s.graph,
					u = s.noEntryList,
					h = {};
				for (f(t, function(t) {
						h[t] = !0
					}); u.length;) {
					var c = u.pop(),
						d = l[c],
						p = !!h[c];
					p && (n.call(r, c, d.originalDeps.slice()), delete h[c]), f(d.successor, p ? o : a)
				}
				f(h, function() {
					throw new Error("Circle dependency may exists")
				})
			}
		}
	}

	function wo(t) {
		return t.replace(/^\s+|\s+$/g, "")
	}

	function bo(t, e, i, n) {
		var r = e[1] - e[0],
			a = i[1] - i[0];
		if (0 === r) return 0 === a ? i[0] : (i[0] + i[1]) / 2;
		if (n)
			if (r > 0) {
				if (t <= e[0]) return i[0];
				if (t >= e[1]) return i[1]
			} else {
				if (t >= e[0]) return i[0];
				if (t <= e[1]) return i[1]
			}
		else {
			if (t === e[0]) return i[0];
			if (t === e[1]) return i[1]
		}
		return (t - e[0]) / r * a + i[0]
	}

	function So(t, e) {
		switch (t) {
			case "center":
			case "middle":
				t = "50%";
				break;
			case "left":
			case "top":
				t = "0%";
				break;
			case "right":
			case "bottom":
				t = "100%"
		}
		return "string" == typeof t ? wo(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? 0 / 0 : +t
	}

	function Mo(t, e, i) {
		return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), i ? t : +t
	}

	function Io(t) {
		return t.sort(function(t, e) {
			return t - e
		}), t
	}

	function To(t) {
		if (t = +t, isNaN(t)) return 0;
		for (var e = 1, i = 0; Math.round(t * e) / e !== t;) e *= 10, i++;
		return i
	}

	function Co(t) {
		var e = t.toString(),
			i = e.indexOf("e");
		if (i > 0) {
			var n = +e.slice(i + 1);
			return 0 > n ? -n : 0
		}
		var r = e.indexOf(".");
		return 0 > r ? 0 : e.length - 1 - r
	}

	function Do(t, e) {
		var i = Math.log,
			n = Math.LN10,
			r = Math.floor(i(t[1] - t[0]) / n),
			a = Math.round(i(Math.abs(e[1] - e[0])) / n),
			o = Math.min(Math.max(-r + a, 0), 20);
		return isFinite(o) ? o : 20
	}

	function ko(t, e, i) {
		if (!t[e]) return 0;
		var n = g(t, function(t, e) {
			return t + (isNaN(e) ? 0 : e)
		}, 0);
		if (0 === n) return 0;
		for (var r = Math.pow(10, i), a = p(t, function(t) {
				return (isNaN(t) ? 0 : t) / n * r * 100
			}), o = 100 * r, s = p(a, function(t) {
				return Math.floor(t)
			}), l = g(s, function(t, e) {
				return t + e
			}, 0), u = p(a, function(t, e) {
				return t - s[e]
			}); o > l;) {
			for (var h = Number.NEGATIVE_INFINITY, c = null, d = 0, f = u.length; f > d; ++d) u[d] > h && (h = u[d], c = d);
			++s[c], u[c] = 0, ++l
		}
		return s[e] / r
	}

	function Ao(t) {
		var e = 2 * Math.PI;
		return (t % e + e) % e
	}

	function Po(t) {
		return t > -e_ && e_ > t
	}

	function Lo(t) {
		if (t instanceof Date) return t;
		if ("string" == typeof t) {
			var e = n_.exec(t);
			if (!e) return new Date(0 / 0);
			if (e[8]) {
				var i = +e[4] || 0;
				return "Z" !== e[8].toUpperCase() && (i -= e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, i, +(e[5] || 0), +e[6] || 0, +e[7] || 0))
			}
			return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, +e[7] || 0)
		}
		return new Date(null == t ? 0 / 0 : Math.round(t))
	}

	function Oo(t) {
		return Math.pow(10, Eo(t))
	}

	function Eo(t) {
		if (0 === t) return 0;
		var e = Math.floor(Math.log(t) / Math.LN10);
		return t / Math.pow(10, e) >= 10 && e++, e
	}

	function zo(t, e) {
		var i, n = Eo(t),
			r = Math.pow(10, n),
			a = t / r;
		return i = e ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, t = i * r, n >= -20 ? +t.toFixed(0 > n ? -n : 0) : t
	}

	function Bo(t, e) {
		var i = (t.length - 1) * e + 1,
			n = Math.floor(i),
			r = +t[n - 1],
			a = i - n;
		return a ? r + a * (t[n] - r) : r
	}

	function Ro(t) {
		function e(t, i, n) {
			return t.interval[n] < i.interval[n] || t.interval[n] === i.interval[n] && (t.close[n] - i.close[n] === (n ? -1 : 1) || !n && e(t, i, 1))
		}
		t.sort(function(t, i) {
			return e(t, i, 0) ? -1 : 1
		});
		for (var i = -1 / 0, n = 1, r = 0; r < t.length;) {
			for (var a = t[r].interval, o = t[r].close, s = 0; 2 > s; s++) a[s] <= i && (a[s] = i, o[s] = s ? 1 : 1 - n), i = a[s], n = o[s];
			a[0] === a[1] && o[0] * o[1] !== 1 ? t.splice(r, 1) : r++
		}
		return t
	}

	function No(t) {
		return t - parseFloat(t) >= 0
	}

	function Fo(t) {
		return isNaN(t) ? "-" : (t = (t + "").split("."), t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : ""))
	}

	function Vo(t, e) {
		return t = (t || "").toLowerCase().replace(/-(.)/g, function(t, e) {
			return e.toUpperCase()
		}), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t
	}

	function Ho(t) {
		return null == t ? "" : (t + "").replace(o_, function(t, e) {
			return s_[e]
		})
	}

	function Wo(t, e, i) {
		x(e) || (e = [e]);
		var n = e.length;
		if (!n) return "";
		for (var r = e[0].$vars || [], a = 0; a < r.length; a++) {
			var o = l_[a];
			t = t.replace(u_(o), u_(o, 0))
		}
		for (var s = 0; n > s; s++)
			for (var l = 0; l < r.length; l++) {
				var u = e[s][r[l]];
				t = t.replace(u_(l_[l], s), i ? Ho(u) : u)
			}
		return t
	}

	function Go(t, e, i) {
		return f(e, function(e, n) {
			t = t.replace("{" + n + "}", i ? Ho(e) : e)
		}), t
	}

	function Uo(t, e) {
		t = b(t) ? {
			color: t,
			extraCssText: e
		} : t || {};
		var i = t.color,
			n = t.type,
			e = t.extraCssText,
			r = t.renderMode || "html",
			a = t.markerId || "X";
		return i ? "html" === r ? "subItem" === n ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Ho(i) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + Ho(i) + ";" + (e || "") + '"></span>' : {
			renderMode: r,
			content: "{marker" + a + "|}  ",
			style: {
				color: i
			}
		} : ""
	}

	function Xo(t, e) {
		return t += "", "0000".substr(0, e - t.length) + t
	}

	function jo(t, e, i) {
		("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy");
		var n = Lo(e),
			r = i ? "UTC" : "",
			a = n["get" + r + "FullYear"](),
			o = n["get" + r + "Month"]() + 1,
			s = n["get" + r + "Date"](),
			l = n["get" + r + "Hours"](),
			u = n["get" + r + "Minutes"](),
			h = n["get" + r + "Seconds"](),
			c = n["get" + r + "Milliseconds"]();
		return t = t.replace("MM", Xo(o, 2)).replace("M", o).replace("yyyy", a).replace("yy", a % 100).replace("dd", Xo(s, 2)).replace("d", s).replace("hh", Xo(l, 2)).replace("h", l).replace("mm", Xo(u, 2)).replace("m", u).replace("ss", Xo(h, 2)).replace("s", h).replace("SSS", Xo(c, 3))
	}

	function Yo(t) {
		return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
	}

	function qo(t) {
		return ji(t.text, t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich, t.truncate)
	}

	function Zo(t, e, i, n, r, a, o, s) {
		return ji(t, e, i, n, r, s, a, o)
	}

	function Ko(t, e) {
		if ("_blank" === e || "blank" === e) {
			var i = window.open();
			i.opener = null, i.location = t
		} else window.open(t, e)
	}

	function $o(t, e, i, n, r) {
		var a = 0,
			o = 0;
		null == n && (n = 1 / 0), null == r && (r = 1 / 0);
		var s = 0;
		e.eachChild(function(l, u) {
			var h, c, d = l.position,
				f = l.getBoundingRect(),
				p = e.childAt(u + 1),
				g = p && p.getBoundingRect();
			if ("horizontal" === t) {
				var v = f.width + (g ? -g.x + f.x : 0);
				h = a + v, h > n || l.newline ? (a = 0, h = v, o += s + i, s = f.height) : s = Math.max(s, f.height)
			} else {
				var m = f.height + (g ? -g.y + f.y : 0);
				c = o + m, c > r || l.newline ? (a += s + i, o = 0, c = m, s = f.width) : s = Math.max(s, f.width)
			}
			l.newline || (d[0] = a, d[1] = o, "horizontal" === t ? a = h + i : o = c + i)
		})
	}

	function Qo(t, e, i) {
		i = a_(i || 0);
		var n = e.width,
			r = e.height,
			a = So(t.left, n),
			o = So(t.top, r),
			s = So(t.right, n),
			l = So(t.bottom, r),
			u = So(t.width, n),
			h = So(t.height, r),
			c = i[2] + i[0],
			d = i[1] + i[3],
			f = t.aspect;
		switch (isNaN(u) && (u = n - s - d - a), isNaN(h) && (h = r - l - c - o), null != f && (isNaN(u) && isNaN(h) && (f > n / r ? u = .8 * n : h = .8 * r), isNaN(u) && (u = f * h), isNaN(h) && (h = u / f)), isNaN(a) && (a = n - s - u - d), isNaN(o) && (o = r - l - h - c), t.left || t.right) {
			case "center":
				a = n / 2 - u / 2 - i[3];
				break;
			case "right":
				a = n - u - d
		}
		switch (t.top || t.bottom) {
			case "middle":
			case "center":
				o = r / 2 - h / 2 - i[0];
				break;
			case "bottom":
				o = r - h - c
		}
		a = a || 0, o = o || 0, isNaN(u) && (u = n - d - a - (s || 0)), isNaN(h) && (h = r - c - o - (l || 0));
		var p = new Ti(a + i[3], o + i[0], u, h);
		return p.margin = i, p
	}

	function Jo(t, e, i) {
		function n(i, n) {
			var o = {},
				l = 0,
				u = {},
				h = 0,
				c = 2;
			if (d_(i, function(e) {
					u[e] = t[e]
				}), d_(i, function(t) {
					r(e, t) && (o[t] = u[t] = e[t]), a(o, t) && l++, a(u, t) && h++
				}), s[n]) return a(e, i[1]) ? u[i[2]] = null : a(e, i[2]) && (u[i[1]] = null), u;
			if (h !== c && l) {
				if (l >= c) return o;
				for (var d = 0; d < i.length; d++) {
					var f = i[d];
					if (!r(o, f) && r(t, f)) {
						o[f] = t[f];
						break
					}
				}
				return o
			}
			return u
		}

		function r(t, e) {
			return t.hasOwnProperty(e)
		}

		function a(t, e) {
			return null != t[e] && "auto" !== t[e]
		}

		function o(t, e, i) {
			d_(t, function(t) {
				e[t] = i[t]
			})
		}!S(i) && (i = {});
		var s = i.ignoreSize;
		!x(s) && (s = [s, s]);
		var l = n(p_[0], 0),
			u = n(p_[1], 1);
		o(p_[0], t, l), o(p_[1], t, u)
	}

	function ts(t) {
		return es({}, t)
	}

	function es(t, e) {
		return e && t && d_(f_, function(i) {
			e.hasOwnProperty(i) && (t[i] = e[i])
		}), t
	}

	function is(t) {
		var e = [];
		return f(y_.getClassesByMainType(t), function(t) {
			e = e.concat(t.prototype.dependencies || [])
		}), e = p(e, function(t) {
			return vr(t).main
		}), "dataset" !== t && u(e, "dataset") <= 0 && e.unshift("dataset"), e
	}

	function ns(t, e) {
		for (var i = t.length, n = 0; i > n; n++)
			if (t[n].length > e) return t[n];
		return t[i - 1]
	}

	function rs(t) {
		this.fromDataset = t.fromDataset, this.data = t.data || (t.sourceFormat === T_ ? {} : []), this.sourceFormat = t.sourceFormat || C_, this.seriesLayoutBy = t.seriesLayoutBy || k_, this.dimensionsDefine = t.dimensionsDefine, this.encodeDefine = t.encodeDefine && N(t.encodeDefine), this.startIndex = t.startIndex || 0, this.dimensionsDetectCount = t.dimensionsDetectCount
	}

	function as(t) {
		var e = t.option.source,
			i = C_;
		if (I(e)) i = D_;
		else if (x(e)) {
			0 === e.length && (i = M_);
			for (var n = 0, r = e.length; r > n; n++) {
				var a = e[n];
				if (null != a) {
					if (x(a)) {
						i = M_;
						break
					}
					if (S(a)) {
						i = I_;
						break
					}
				}
			}
		} else if (S(e)) {
			for (var o in e)
				if (e.hasOwnProperty(o) && d(e[o])) {
					i = T_;
					break
				}
		} else if (null != e) throw new Error("Invalid data");
		L_(t).sourceFormat = i
	}

	function os(t) {
		return L_(t).source
	}

	function ss(t) {
		L_(t).datasetMap = N()
	}

	function ls(t) {
		var e = t.option,
			i = e.data,
			n = I(i) ? D_ : S_,
			r = !1,
			a = e.seriesLayoutBy,
			o = e.sourceHeader,
			s = e.dimensions,
			l = ps(t);
		if (l) {
			var u = l.option;
			i = u.source, n = L_(l).sourceFormat, r = !0, a = a || u.seriesLayoutBy, null == o && (o = u.sourceHeader), s = s || u.dimensions
		}
		var h = us(i, n, a, o, s);
		L_(t).source = new rs({
			data: i,
			fromDataset: r,
			seriesLayoutBy: a,
			sourceFormat: n,
			dimensionsDefine: h.dimensionsDefine,
			startIndex: h.startIndex,
			dimensionsDetectCount: h.dimensionsDetectCount,
			encodeDefine: e.encode
		})
	}

	function us(t, e, i, n, r) {
		if (!t) return {
			dimensionsDefine: hs(r)
		};
		var a, o;
		if (e === M_) "auto" === n || null == n ? cs(function(t) {
			null != t && "-" !== t && (b(t) ? null == o && (o = 1) : o = 0)
		}, i, t, 10) : o = n ? 1 : 0, r || 1 !== o || (r = [], cs(function(t, e) {
			r[e] = null != t ? t : ""
		}, i, t)), a = r ? r.length : i === A_ ? t.length : t[0] ? t[0].length : null;
		else if (e === I_) r || (r = ds(t));
		else if (e === T_) r || (r = [], f(t, function(t, e) {
			r.push(e)
		}));
		else if (e === S_) {
			var s = nr(t[0]);
			a = x(s) && s.length || 1
		}
		return {
			startIndex: o,
			dimensionsDefine: hs(r),
			dimensionsDetectCount: a
		}
	}

	function hs(t) {
		if (t) {
			var e = N();
			return p(t, function(t) {
				if (t = o({}, S(t) ? t : {
						name: t
					}), null == t.name) return t;
				t.name += "", null == t.displayName && (t.displayName = t.name);
				var i = e.get(t.name);
				return i ? t.name += "-" + i.count++ : e.set(t.name, {
					count: 1
				}), t
			})
		}
	}

	function cs(t, e, i, n) {
		if (null == n && (n = 1 / 0), e === A_)
			for (var r = 0; r < i.length && n > r; r++) t(i[r] ? i[r][0] : null, r);
		else
			for (var a = i[0] || [], r = 0; r < a.length && n > r; r++) t(a[r], r)
	}

	function ds(t) {
		for (var e, i = 0; i < t.length && !(e = t[i++]););
		if (e) {
			var n = [];
			return f(e, function(t, e) {
				n.push(e)
			}), n
		}
	}

	function fs(t, e, i) {
		function n(t, e, i) {
			for (var n = 0; i > n; n++) t.push(e + n)
		}

		function r(t) {
			var e = t.dimsDef;
			return e ? e.length : 1
		}
		var a = {},
			o = ps(e);
		if (!o || !t) return a;
		var s, l, u = [],
			h = [],
			c = e.ecModel,
			d = L_(c).datasetMap,
			p = o.uid + "_" + i.seriesLayoutBy;
		t = t.slice(), f(t, function(e, i) {
			!S(e) && (t[i] = {
				name: e
			}), "ordinal" === e.type && null == s && (s = i, l = r(t[i])), a[e.name] = []
		});
		var g = d.get(p) || d.set(p, {
			categoryWayDim: l,
			valueWayDim: 0
		});
		return f(t, function(t, e) {
			var i = t.name,
				o = r(t);
			if (null == s) {
				var l = g.valueWayDim;
				n(a[i], l, o), n(h, l, o), g.valueWayDim += o
			} else if (s === e) n(a[i], 0, o), n(u, 0, o);
			else {
				var l = g.categoryWayDim;
				n(a[i], l, o), n(h, l, o), g.categoryWayDim += o
			}
		}), u.length && (a.itemName = u), h.length && (a.seriesName = h), a
	}

	function ps(t) {
		var e = t.option,
			i = e.data;
		return i ? void 0 : t.ecModel.getComponent("dataset", e.datasetIndex || 0)
	}

	function gs(t, e) {
		return vs(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, e)
	}

	function vs(t, e, i, n, r, a) {
		function o(t) {
			var e = b(t);
			return null != t && isFinite(t) && "" !== t ? e ? P_.Might : P_.Not : e && "-" !== t ? P_.Must : void 0
		}
		var s, l = 5;
		if (I(t)) return P_.Not;
		var u, h;
		if (n) {
			var c = n[a];
			S(c) ? (u = c.name, h = c.type) : b(c) && (u = c)
		}
		if (null != h) return "ordinal" === h ? P_.Must : P_.Not;
		if (e === M_)
			if (i === A_) {
				for (var d = t[a], f = 0; f < (d || []).length && l > f; f++)
					if (null != (s = o(d[r + f]))) return s
			} else
				for (var f = 0; f < t.length && l > f; f++) {
					var p = t[r + f];
					if (p && null != (s = o(p[a]))) return s
				} else if (e === I_) {
					if (!u) return P_.Not;
					for (var f = 0; f < t.length && l > f; f++) {
						var g = t[f];
						if (g && null != (s = o(g[u]))) return s
					}
				} else if (e === T_) {
			if (!u) return P_.Not;
			var d = t[u];
			if (!d || I(d)) return P_.Not;
			for (var f = 0; f < d.length && l > f; f++)
				if (null != (s = o(d[f]))) return s
		} else if (e === S_)
			for (var f = 0; f < t.length && l > f; f++) {
				var g = t[f],
					v = nr(g);
				if (!x(v)) return P_.Not;
				if (null != (s = o(v[a]))) return s
			}
		return P_.Not
	}

	function ms(t, e) {
		if (e) {
			var i = e.seiresIndex,
				n = e.seriesId,
				r = e.seriesName;
			return null != i && t.componentIndex !== i || null != n && t.id !== n || null != r && t.name !== r
		}
	}

	function ys(t, e) {
		var i = t.color && !t.colorLayer;
		f(e, function(e, a) {
			"colorLayer" === a && i || y_.hasClass(a) || ("object" == typeof e ? t[a] = t[a] ? r(t[a], e, !1) : n(e) : null == t[a] && (t[a] = e))
		})
	}

	function _s(t) {
		t = t, this.option = {}, this.option[O_] = 1, this._componentsMap = N({
			series: []
		}), this._seriesIndices, this._seriesIndicesMap, ys(t, this._theme.option), r(t, x_, !1), this.mergeOption(t)
	}

	function xs(t, e) {
		x(e) || (e = e ? [e] : []);
		var i = {};
		return f(e, function(e) {
			i[e] = (t.get(e) || []).slice()
		}), i
	}

	function ws(t, e, i) {
		var n = e.type ? e.type : i ? i.subType : y_.determineSubType(t, e);
		return n
	}

	function bs(t, e) {
		t._seriesIndicesMap = N(t._seriesIndices = p(e, function(t) {
			return t.componentIndex
		}) || [])
	}

	function Ss(t, e) {
		return e.hasOwnProperty("subType") ? v(t, function(t) {
			return t.subType === e.subType
		}) : t
	}

	function Ms(t) {
		f(z_, function(e) {
			this[e] = y(t[e], t)
		}, this)
	}

	function Is() {
		this._coordinateSystems = []
	}

	function Ts(t) {
		this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption
	}

	function Cs(t, e, i) {
		var n, r, a = [],
			o = [],
			s = t.timeline;
		if (t.baseOption && (r = t.baseOption), (s || t.options) && (r = r || {}, a = (t.options || []).slice()), t.media) {
			r = r || {};
			var l = t.media;
			R_(l, function(t) {
				t && t.option && (t.query ? o.push(t) : n || (n = t))
			})
		}
		return r || (r = t), r.timeline || (r.timeline = s), R_([r].concat(a).concat(p(o, function(t) {
			return t.option
		})), function(t) {
			R_(e, function(e) {
				e(t, i)
			})
		}), {
			baseOption: r,
			timelineOptions: a,
			mediaDefault: n,
			mediaList: o
		}
	}

	function Ds(t, e, i) {
		var n = {
				width: e,
				height: i,
				aspectratio: e / i
			},
			r = !0;
		return f(t, function(t, e) {
			var i = e.match(H_);
			if (i && i[1] && i[2]) {
				var a = i[1],
					o = i[2].toLowerCase();
				ks(n[o], t, a) || (r = !1)
			}
		}), r
	}

	function ks(t, e, i) {
		return "min" === i ? t >= e : "max" === i ? e >= t : t === e
	}

	function As(t, e) {
		return t.join(",") === e.join(",")
	}

	function Ps(t, e) {
		e = e || {}, R_(e, function(e, i) {
			if (null != e) {
				var n = t[i];
				if (y_.hasClass(i)) {
					e = er(e), n = er(n);
					var r = ar(n, e);
					t[i] = F_(r, function(t) {
						return t.option && t.exist ? V_(t.exist, t.option, !0) : t.exist || t.option
					})
				} else t[i] = V_(n, e, !0)
			}
		})
	}

	function Ls(t) {
		var e = t && t.itemStyle;
		if (e)
			for (var i = 0, n = U_.length; n > i; i++) {
				var a = U_[i],
					o = e.normal,
					s = e.emphasis;
				o && o[a] && (t[a] = t[a] || {}, t[a].normal ? r(t[a].normal, o[a]) : t[a].normal = o[a], o[a] = null), s && s[a] && (t[a] = t[a] || {}, t[a].emphasis ? r(t[a].emphasis, s[a]) : t[a].emphasis = s[a], s[a] = null)
			}
	}

	function Os(t, e, i) {
		if (t && t[e] && (t[e].normal || t[e].emphasis)) {
			var n = t[e].normal,
				r = t[e].emphasis;
			n && (i ? (t[e].normal = t[e].emphasis = null, s(t[e], n)) : t[e] = n), r && (t.emphasis = t.emphasis || {}, t.emphasis[e] = r)
		}
	}

	function Es(t) {
		Os(t, "itemStyle"), Os(t, "lineStyle"), Os(t, "areaStyle"), Os(t, "label"), Os(t, "labelLine"), Os(t, "upperLabel"), Os(t, "edgeLabel")
	}

	function zs(t, e) {
		var i = G_(t) && t[e],
			n = G_(i) && i.textStyle;
		if (n)
			for (var r = 0, a = Qv.length; a > r; r++) {
				var e = Qv[r];
				n.hasOwnProperty(e) && (i[e] = n[e])
			}
	}

	function Bs(t) {
		t && (Es(t), zs(t, "label"), t.emphasis && zs(t.emphasis, "label"))
	}

	function Rs(t) {
		if (G_(t)) {
			Ls(t), Es(t), zs(t, "label"), zs(t, "upperLabel"), zs(t, "edgeLabel"), t.emphasis && (zs(t.emphasis, "label"), zs(t.emphasis, "upperLabel"), zs(t.emphasis, "edgeLabel"));
			var e = t.markPoint;
			e && (Ls(e), Bs(e));
			var i = t.markLine;
			i && (Ls(i), Bs(i));
			var n = t.markArea;
			n && Bs(n);
			var r = t.data;
			if ("graph" === t.type) {
				r = r || t.nodes;
				var a = t.links || t.edges;
				if (a && !I(a))
					for (var o = 0; o < a.length; o++) Bs(a[o]);
				f(t.categories, function(t) {
					Es(t)
				})
			}
			if (r && !I(r))
				for (var o = 0; o < r.length; o++) Bs(r[o]);
			var e = t.markPoint;
			if (e && e.data)
				for (var s = e.data, o = 0; o < s.length; o++) Bs(s[o]);
			var i = t.markLine;
			if (i && i.data)
				for (var l = i.data, o = 0; o < l.length; o++) x(l[o]) ? (Bs(l[o][0]), Bs(l[o][1])) : Bs(l[o]);
			"gauge" === t.type ? (zs(t, "axisLabel"), zs(t, "title"), zs(t, "detail")) : "treemap" === t.type ? (Os(t.breadcrumb, "itemStyle"), f(t.levels, function(t) {
				Es(t)
			})) : "tree" === t.type && Es(t.leaves)
		}
	}

	function Ns(t) {
		return x(t) ? t : t ? [t] : []
	}

	function Fs(t) {
		return (x(t) ? t[0] : t) || {}
	}

	function Vs(t, e) {
		e = e.split(",");
		for (var i = t, n = 0; n < e.length && (i = i && i[e[n]], null != i); n++);
		return i
	}

	function Hs(t, e, i, n) {
		e = e.split(",");
		for (var r, a = t, o = 0; o < e.length - 1; o++) r = e[o], null == a[r] && (a[r] = {}), a = a[r];
		(n || null == a[e[o]]) && (a[e[o]] = i)
	}

	function Ws(t) {
		f(j_, function(e) {
			e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]])
		})
	}

	function Gs(t) {
		f(t, function(e, i) {
			var n = [],
				r = [0 / 0, 0 / 0],
				a = [e.stackResultDimension, e.stackedOverDimension],
				o = e.data,
				s = e.isStackedByIndex,
				l = o.map(a, function(a, l, u) {
					var h = o.get(e.stackedDimension, u);
					if (isNaN(h)) return r;
					var c, d;
					s ? d = o.getRawIndex(u) : c = o.get(e.stackedByDimension, u);
					for (var f = 0 / 0, p = i - 1; p >= 0; p--) {
						var g = t[p];
						if (s || (d = g.data.rawIndexOf(g.stackedByDimension, c)), d >= 0) {
							var v = g.data.getByRawIndex(g.stackResultDimension, d);
							if (h >= 0 && v > 0 || 0 >= h && 0 > v) {
								h += v, f = v;
								break
							}
						}
					}
					return n[0] = h, n[1] = f, n
				});
			o.hostModel.setData(l), e.data = l
		})
	}

	function Us(t, e) {
		rs.isInstance(t) || (t = rs.seriesDataToSource(t)), this._source = t;
		var i = this._data = t.data,
			n = t.sourceFormat;
		n === D_ && (this._offset = 0, this._dimSize = e, this._data = i);
		var r = $_[n === M_ ? n + "_" + t.seriesLayoutBy : n];
		o(this, r)
	}

	function Xs() {
		return this._data.length
	}

	function js(t) {
		return this._data[t]
	}

	function Ys(t) {
		for (var e = 0; e < t.length; e++) this._data.push(t[e])
	}

	function qs(t, e, i) {
		return null != i ? t[i] : t
	}

	function Zs(t, e, i, n) {
		return Ks(t[n], this._dimensionInfos[e])
	}

	function Ks(t, e) {
		var i = e && e.type;
		if ("ordinal" === i) {
			var n = e && e.ordinalMeta;
			return n ? n.parseAndCollect(t) : t
		}
		return "time" === i && "number" != typeof t && null != t && "-" !== t && (t = +Lo(t)), null == t || "" === t ? 0 / 0 : +t
	}

	function $s(t, e, i) {
		if (t) {
			var n = t.getRawDataItem(e);
			if (null != n) {
				var r, a, o = t.getProvider().getSource().sourceFormat,
					s = t.getDimensionInfo(i);
				return s && (r = s.name, a = s.index), Q_[o](n, e, a, r)
			}
		}
	}

	function Qs(t) {
		return new Js(t)
	}

	function Js(t) {
		t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0, this.context
	}

	function tl(t, e, i, n, r, a) {
		nx.reset(i, n, r, a), t._callingProgress = e, t._callingProgress({
			start: i,
			end: n,
			count: n - i,
			next: nx.next
		}, t.context)
	}

	function el(t, e) {
		t._dueIndex = t._outputDueEnd = t._dueEnd = 0, t._settedOutputEnd = null;
		var i, n;
		!e && t._reset && (i = t._reset(t.context), i && i.progress && (n = i.forceFirstProgress, i = i.progress), x(i) && !i.length && (i = null)), t._progress = i, t._modBy = t._modDataCount = null;
		var r = t._downstream;
		return r && r.dirty(), n
	}

	function il(t) {
		var e = t.name;
		sr(t) || (t.name = nl(t) || e)
	}

	function nl(t) {
		var e = t.getRawData(),
			i = e.mapDimension("seriesName", !0),
			n = [];
		return f(i, function(t) {
			var i = e.getDimensionInfo(t);
			i.displayName && n.push(i.displayName)
		}), n.join(" ")
	}

	function rl(t) {
		return t.model.getRawData().count()
	}

	function al(t) {
		var e = t.model;
		return e.setData(e.getRawData().cloneShallow()), ol
	}

	function ol(t, e) {
		e.outputData && t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData)
	}

	function sl(t, e) {
		f(t.CHANGABLE_METHODS, function(i) {
			t.wrapMethod(i, _(ll, e))
		})
	}

	function ll(t) {
		var e = ul(t);
		e && e.setOutputEnd(this.count())
	}

	function ul(t) {
		var e = (t.ecModel || {}).scheduler,
			i = e && e.getPipeline(t.uid);
		if (i) {
			var n = i.currentTask;
			if (n) {
				var r = n.agentStubMap;
				r && (n = r.get(t.uid))
			}
			return n
		}
	}

	function hl() {
		this.group = new Zg, this.uid = yo("viewChart"), this.renderTask = Qs({
			plan: fl,
			reset: pl
		}), this.renderTask.context = {
			view: this
		}
	}

	function cl(t, e, i) {
		if (t && (t.trigger(e, i), t.isGroup && !Ha(t)))
			for (var n = 0, r = t.childCount(); r > n; n++) cl(t.childAt(n), e, i)
	}

	function dl(t, e, i) {
		var n = ur(t, e),
			r = e && null != e.highlightKey ? Wa(e.highlightKey) : null;
		null != n ? f(er(n), function(e) {
			cl(t.getItemGraphicEl(e), i, r)
		}) : t.eachItemGraphicEl(function(t) {
			cl(t, i, r)
		})
	}

	function fl(t) {
		return hx(t.model)
	}

	function pl(t) {
		var e = t.model,
			i = t.ecModel,
			n = t.api,
			r = t.payload,
			a = e.pipelineContext.progressiveRender,
			o = t.view,
			s = r && ux(r).updateMethod,
			l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
		return "render" !== l && o[l](e, i, n, r), dx[l]
	}

	function gl(t, e, i) {
		function n() {
			h = (new Date).getTime(), c = null, t.apply(o, s || [])
		}
		var r, a, o, s, l, u = 0,
			h = 0,
			c = null;
		e = e || 0;
		var d = function() {
			r = (new Date).getTime(), o = this, s = arguments;
			var t = l || e,
				d = l || i;
			l = null, a = r - (d ? u : h) - t, clearTimeout(c), d ? c = setTimeout(n, t) : a >= 0 ? n() : c = setTimeout(n, -a), u = r
		};
		return d.clear = function() {
			c && (clearTimeout(c), c = null)
		}, d.debounceNextCall = function(t) {
			l = t
		}, d
	}

	function vl(t, e, i, n) {
		var r = t[e];
		if (r) {
			var a = r[fx] || r,
				o = r[gx],
				s = r[px];
			if (s !== i || o !== n) {
				if (null == i || !n) return t[e] = a;
				r = t[e] = gl(a, i, "debounce" === n), r[fx] = a, r[gx] = n, r[px] = i
			}
			return r
		}
	}

	function ml(t, e, i, n) {
		this.ecInstance = t, this.api = e, this.unfinished;
		var i = this._dataProcessorHandlers = i.slice(),
			n = this._visualHandlers = n.slice();
		this._allHandlers = i.concat(n), this._stageTaskMap = N()
	}

	function yl(t, e, i, n, r) {
		function a(t, e) {
			return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id))
		}
		r = r || {};
		var o;
		f(e, function(e) {
			if (!r.visualType || r.visualType === e.visualType) {
				var s = t._stageTaskMap.get(e.uid),
					l = s.seriesTaskMap,
					u = s.overallTask;
				if (u) {
					var h, c = u.agentStubMap;
					c.each(function(t) {
						a(r, t) && (t.dirty(), h = !0)
					}), h && u.dirty(), Sx(u, n);
					var d = t.getPerformArgs(u, r.block);
					c.each(function(t) {
						t.perform(d)
					}), o |= u.perform(d)
				} else l && l.each(function(s) {
					a(r, s) && s.dirty();
					var l = t.getPerformArgs(s, r.block);
					l.skip = !e.performRawSeries && i.isSeriesFiltered(s.context.model), Sx(s, n), o |= s.perform(l)
				})
			}
		}), t.unfinished |= o
	}

	function _l(t, e, i, n, r) {
		function a(i) {
			var a = i.uid,
				s = o.get(a) || o.set(a, Qs({
					plan: Il,
					reset: Tl,
					count: Dl
				}));
			s.context = {
				model: i,
				ecModel: n,
				api: r,
				useClearVisual: e.isVisual && !e.isLayout,
				plan: e.plan,
				reset: e.reset,
				scheduler: t
			}, kl(t, i, s)
		}
		var o = i.seriesTaskMap || (i.seriesTaskMap = N()),
			s = e.seriesType,
			l = e.getTargetSeries;
		e.createOnAllSeries ? n.eachRawSeries(a) : s ? n.eachRawSeriesByType(s, a) : l && l(n, r).each(a);
		var u = t._pipelineMap;
		o.each(function(t, e) {
			u.get(e) || (t.dispose(), o.removeKey(e))
		})
	}

	function xl(t, e, i, n, r) {
		function a(e) {
			var i = e.uid,
				n = s.get(i);
			n || (n = s.set(i, Qs({
				reset: bl,
				onDirty: Ml
			})), o.dirty()), n.context = {
				model: e,
				overallProgress: h,
				modifyOutputEnd: c
			}, n.agent = o, n.__block = h, kl(t, e, n)
		}
		var o = i.overallTask = i.overallTask || Qs({
			reset: wl
		});
		o.context = {
			ecModel: n,
			api: r,
			overallReset: e.overallReset,
			scheduler: t
		};
		var s = o.agentStubMap = o.agentStubMap || N(),
			l = e.seriesType,
			u = e.getTargetSeries,
			h = !0,
			c = e.modifyOutputEnd;
		l ? n.eachRawSeriesByType(l, a) : u ? u(n, r).each(a) : (h = !1, f(n.getSeries(), a));
		var d = t._pipelineMap;
		s.each(function(t, e) {
			d.get(e) || (t.dispose(), o.dirty(), s.removeKey(e))
		})
	}

	function wl(t) {
		t.overallReset(t.ecModel, t.api, t.payload)
	}

	function bl(t) {
		return t.overallProgress && Sl
	}

	function Sl() {
		this.agent.dirty(), this.getDownstream().dirty()
	}

	function Ml() {
		this.agent && this.agent.dirty()
	}

	function Il(t) {
		return t.plan && t.plan(t.model, t.ecModel, t.api, t.payload)
	}

	function Tl(t) {
		t.useClearVisual && t.data.clearAllVisual();
		var e = t.resetDefines = er(t.reset(t.model, t.ecModel, t.api, t.payload));
		return e.length > 1 ? p(e, function(t, e) {
			return Cl(e)
		}) : Mx
	}

	function Cl(t) {
		return function(e, i) {
			var n = i.data,
				r = i.resetDefines[t];
			if (r && r.dataEach)
				for (var a = e.start; a < e.end; a++) r.dataEach(n, a);
			else r && r.progress && r.progress(e, n)
		}
	}

	function Dl(t) {
		return t.data.count()
	}

	function kl(t, e, i) {
		var n = e.uid,
			r = t._pipelineMap.get(n);
		!r.head && (r.head = i), r.tail && r.tail.pipe(i), r.tail = i, i.__idxInPipeline = r.count++, i.__pipeline = r
	}

	function Al(t) {
		Ix = null;
		try {
			t(Tx, Cx)
		} catch (e) {}
		return Ix
	}

	function Pl(t, e) {
		for (var i in e.prototype) t[i] = V
	}

	function Ll(t) {
		if (b(t)) {
			var e = new DOMParser;
			t = e.parseFromString(t, "text/xml")
		}
		for (9 === t.nodeType && (t = t.firstChild);
			"svg" !== t.nodeName.toLowerCase() || 1 !== t.nodeType;) t = t.nextSibling;
		return t
	}

	function Ol() {
		this._defs = {}, this._root = null, this._isDefine = !1, this._isText = !1
	}

	function El(t, e) {
		for (var i = t.firstChild; i;) {
			if (1 === i.nodeType) {
				var n = i.getAttribute("offset");
				n = n.indexOf("%") > 0 ? parseInt(n, 10) / 100 : n ? parseFloat(n) : 0;
				var r = i.getAttribute("stop-color") || "#000000";
				e.addColorStop(n, r)
			}
			i = i.nextSibling
		}
	}

	function zl(t, e) {
		t && t.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), s(e.__inheritedStyle, t.__inheritedStyle))
	}

	function Bl(t) {
		for (var e = E(t).split(zx), i = [], n = 0; n < e.length; n += 2) {
			var r = parseFloat(e[n]),
				a = parseFloat(e[n + 1]);
			i.push([r, a])
		}
		return i
	}

	function Rl(t, e, i, n) {
		var r = e.__inheritedStyle || {},
			a = "text" === e.type;
		if (1 === t.nodeType && (Fl(t, e), o(r, Vl(t)), !n))
			for (var s in Nx)
				if (Nx.hasOwnProperty(s)) {
					var l = t.getAttribute(s);
					null != l && (r[Nx[s]] = l)
				}
		var u = a ? "textFill" : "fill",
			h = a ? "textStroke" : "stroke";
		e.style = e.style || new rv;
		var c = e.style;
		null != r.fill && c.set(u, Nl(r.fill, i)), null != r.stroke && c.set(h, Nl(r.stroke, i)), f(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function(t) {
			var e = "lineWidth" === t && a ? "textStrokeWidth" : t;
			null != r[t] && c.set(e, parseFloat(r[t]))
		}), r.textBaseline && "auto" !== r.textBaseline || (r.textBaseline = "alphabetic"), "alphabetic" === r.textBaseline && (r.textBaseline = "bottom"), "start" === r.textAlign && (r.textAlign = "left"), "end" === r.textAlign && (r.textAlign = "right"), f(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], function(t) {
			null != r[t] && c.set(t, r[t])
		}), r.lineDash && (e.style.lineDash = E(r.lineDash).split(zx)), c[h] && "none" !== c[h] && (e[h] = !0), e.__inheritedStyle = r
	}

	function Nl(t, e) {
		var i = e && t && t.match(Fx);
		if (i) {
			var n = E(i[1]),
				r = e[n];
			return r
		}
		return t
	}

	function Fl(t, e) {
		var i = t.getAttribute("transform");
		if (i) {
			i = i.replace(/,/g, " ");
			var n = null,
				r = [];
			i.replace(Vx, function(t, e, i) {
				r.push(e, i)
			});
			for (var a = r.length - 1; a > 0; a -= 2) {
				var o = r[a],
					s = r[a - 1];
				switch (n = n || Oe(), s) {
					case "translate":
						o = E(o).split(zx), Re(n, n, [parseFloat(o[0]), parseFloat(o[1] || 0)]);
						break;
					case "scale":
						o = E(o).split(zx), Fe(n, n, [parseFloat(o[0]), parseFloat(o[1] || o[0])]);
						break;
					case "rotate":
						o = E(o).split(zx), Ne(n, n, parseFloat(o[0]));
						break;
					case "skew":
						o = E(o).split(zx), console.warn("Skew transform is not supported yet");
						break;
					case "matrix":
						var o = E(o).split(zx);
						n[0] = parseFloat(o[0]), n[1] = parseFloat(o[1]), n[2] = parseFloat(o[2]), n[3] = parseFloat(o[3]), n[4] = parseFloat(o[4]), n[5] = parseFloat(o[5])
				}
			}
			e.setLocalTransform(n)
		}
	}

	function Vl(t) {
		var e = t.getAttribute("style"),
			i = {};
		if (!e) return i;
		var n = {};
		Hx.lastIndex = 0;
		for (var r; null != (r = Hx.exec(e));) n[r[1]] = r[2];
		for (var a in Nx) Nx.hasOwnProperty(a) && null != n[a] && (i[Nx[a]] = n[a]);
		return i
	}

	function Hl(t, e, i) {
		var n = e / t.width,
			r = i / t.height,
			a = Math.min(n, r),
			o = [a, a],
			s = [-(t.x + t.width / 2) * a + e / 2, -(t.y + t.height / 2) * a + i / 2];
		return {
			scale: o,
			position: s
		}
	}

	function Wl(t, e) {
		return function(i, n, r) {
			(e || !this._disposed) && (i = i && i.toLowerCase(), ng.prototype[t].call(this, i, n, r))
		}
	}

	function Gl() {
		ng.call(this)
	}

	function Ul(t, e, i) {
		function r(t, e) {
			return t.__prio - e.__prio
		}
		i = i || {}, "string" == typeof e && (e = Sw[e]), this.id, this.group, this._dom = t;
		var a = "canvas",
			o = this._zr = Kn(t, {
				renderer: i.renderer || a,
				devicePixelRatio: i.devicePixelRatio,
				width: i.width,
				height: i.height
			});
		this._throttledZrFlush = gl(y(o.flush, o), 17);
		var e = n(e);
		e && q_(e, !0), this._theme = e, this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._coordSysMgr = new Is;
		var s = this._api = lu(this);
		Ei(bw, r), Ei(_w, r), this._scheduler = new ml(this, s, _w, bw), ng.call(this, this._ecEventProcessor = new uu), this._messageCenter = new Gl, this._initEvents(), this.resize = y(this.resize, this), this._pendingActions = [], o.animation.on("frame", this._onframe, this), Ql(o, this), z(this)
	}

	function Xl(t, e, i) {
		if (!this._disposed) {
			var n, r = this._model,
				a = this._coordSysMgr.getCoordinateSystems();
			e = cr(r, e);
			for (var o = 0; o < a.length; o++) {
				var s = a[o];
				if (s[t] && null != (n = s[t](r, e, i))) return n
			}
		}
	}

	function jl(t) {
		var e = t._model,
			i = t._scheduler;
		i.restorePipelines(e), i.prepareStageTasks(), Jl(t, "component", e, i), Jl(t, "chart", e, i), i.plan()
	}

	function Yl(t, e, i, n, r) {
		function a(n) {
			n && n.__alive && n[e] && n[e](n.__model, o, t._api, i)
		}
		var o = t._model;
		if (!n) return void jx(t._componentsViews.concat(t._chartsViews), a);
		var s = {};
		s[n + "Id"] = i[n + "Id"], s[n + "Index"] = i[n + "Index"], s[n + "Name"] = i[n + "Name"];
		var l = {
			mainType: n,
			query: s
		};
		r && (l.subType = r);
		var u = i.excludeSeriesId;
		null != u && (u = N(er(u))), o && o.eachComponent(l, function(e) {
			u && null != u.get(e.id) || a(t["series" === n ? "_chartsMap" : "_componentsMap"][e.__viewId])
		}, t)
	}

	function ql(t, e) {
		var i = t._chartsMap,
			n = t._scheduler;
		e.eachSeries(function(t) {
			n.updateStreamModes(t, i[t.__viewId])
		})
	}

	function Zl(t, e) {
		var i = t.type,
			n = t.escapeConnect,
			r = mw[i],
			a = r.actionInfo,
			l = (a.update || "update").split(":"),
			u = l.pop();
		l = null != l[0] && Zx(l[0]), this[cw] = !0;
		var h = [t],
			c = !1;
		t.batch && (c = !0, h = p(t.batch, function(e) {
			return e = s(o({}, e), t), e.batch = null, e
		}));
		var d, f = [],
			g = "highlight" === i || "downplay" === i;
		jx(h, function(t) {
			d = r.action(t, this._model, this._api), d = d || o({}, t), d.type = a.event || d.type, f.push(d), g ? Yl(this, u, t, "series") : l && Yl(this, u, t, l.main, l.sub)
		}, this), "none" === u || g || l || (this[dw] ? (jl(this), gw.update.call(this, t), this[dw] = !1) : gw[u].call(this, t)), d = c ? {
			type: a.event || i,
			escapeConnect: n,
			batch: f
		} : f[0], this[cw] = !1, !e && this._messageCenter.trigger(d.type, d)
	}

	function Kl(t) {
		for (var e = this._pendingActions; e.length;) {
			var i = e.shift();
			Zl.call(this, i, t)
		}
	}

	function $l(t) {
		!t && this.trigger("updated")
	}

	function Ql(t, e) {
		t.on("rendered", function() {
			e.trigger("rendered"), !t.animation.isFinished() || e[dw] || e._scheduler.unfinished || e._pendingActions.length || e.trigger("finished")
		})
	}

	function Jl(t, e, i, n) {
		function r(t) {
			var e = "_ec_" + t.id + "_" + t.type,
				r = s[e];
			if (!r) {
				var h = Zx(t.type),
					c = a ? ox.getClass(h.main, h.sub) : hl.getClass(h.sub);
				r = new c, r.init(i, u), s[e] = r, o.push(r), l.add(r.group)
			}
			t.__viewId = r.__id = e, r.__alive = !0, r.__model = t, r.group.__ecComponentInfo = {
				mainType: t.mainType,
				index: t.componentIndex
			}, !a && n.prepareView(r, t, i, u)
		}
		for (var a = "component" === e, o = a ? t._componentsViews : t._chartsViews, s = a ? t._componentsMap : t._chartsMap, l = t._zr, u = t._api, h = 0; h < o.length; h++) o[h].__alive = !1;
		a ? i.eachComponent(function(t, e) {
			"series" !== t && r(e)
		}) : i.eachSeries(r);
		for (var h = 0; h < o.length;) {
			var c = o[h];
			c.__alive ? h++ : (!a && c.renderTask.dispose(), l.remove(c.group), c.dispose(i, u), o.splice(h, 1), delete s[c.__id], c.__id = c.group.__ecComponentInfo = null)
		}
	}

	function tu(t) {
		t.clearColorPalette(), t.eachSeries(function(t) {
			t.clearColorPalette()
		})
	}

	function eu(t, e, i, n) {
		iu(t, e, i, n), jx(t._chartsViews, function(t) {
			t.__alive = !1
		}), nu(t, e, i, n), jx(t._chartsViews, function(t) {
			t.__alive || t.remove(e, i)
		})
	}

	function iu(t, e, i, n, r) {
		jx(r || t._componentsViews, function(t) {
			var r = t.__model;
			t.render(r, e, i, n), su(r, t)
		})
	}

	function nu(t, e, i, n, r) {
		var a, o = t._scheduler;
		e.eachSeries(function(e) {
			var i = t._chartsMap[e.__viewId];
			i.__alive = !0;
			var s = i.renderTask;
			o.updatePayload(s, n), r && r.get(e.uid) && s.dirty(), a |= s.perform(o.getPerformArgs(s)), i.group.silent = !!e.get("silent"), su(e, i), ou(e, i)
		}), o.unfinished |= a, au(t, e), yx(t._zr.dom, e)
	}

	function ru(t, e) {
		jx(ww, function(i) {
			i(t, e)
		})
	}

	function au(t, e) {
		var i = t._zr,
			n = i.storage,
			r = 0;
		n.traverse(function() {
			r++
		}), r > e.get("hoverLayerThreshold") && !zp.node && e.eachSeries(function(e) {
			if (!e.preventUsingHoverLayer) {
				var i = t._chartsMap[e.__viewId];
				i.__alive && i.group.traverse(function(t) {
					t.useHoverLayer = !0
				})
			}
		})
	}

	function ou(t, e) {
		var i = t.get("blendMode") || null;
		e.group.traverse(function(t) {
			t.isGroup || t.style.blend !== i && t.setStyle("blend", i), t.eachPendingDisplayable && t.eachPendingDisplayable(function(t) {
				t.setStyle("blend", i)
			})
		})
	}

	function su(t, e) {
		var i = t.get("z"),
			n = t.get("zlevel");
		e.group.traverse(function(t) {
			"group" !== t.type && (null != i && (t.z = i), null != n && (t.zlevel = n))
		})
	}

	function lu(t) {
		var e = t._coordSysMgr;
		return o(new Ms(t), {
			getCoordinateSystems: y(e.getCoordinateSystems, e),
			getComponentByElement: function(e) {
				for (; e;) {
					var i = e.__ecComponentInfo;
					if (null != i) return t._model.getComponent(i.mainType, i.index);
					e = e.parent
				}
			}
		})
	}

	function uu() {
		this.eventInfo
	}

	function hu(t) {
		function e(t, e) {
			for (var i = 0; i < t.length; i++) {
				var n = t[i];
				n[a] = e
			}
		}
		var i = 0,
			n = 1,
			r = 2,
			a = "__connectUpdateStatus";
		jx(yw, function(o, s) {
			t._messageCenter.on(s, function(o) {
				if (Tw[t.group] && t[a] !== i) {
					if (o && o.escapeConnect) return;
					var s = t.makeActionFromEvent(o),
						l = [];
					jx(Iw, function(e) {
						e !== t && e.group === t.group && l.push(e)
					}), e(l, i), jx(l, function(t) {
						t[a] !== n && t.dispatchAction(s)
					}), e(l, r)
				}
			})
		})
	}

	function cu(t, e, i) {
		var n = gu(t);
		if (n) return n;
		var r = new Ul(t, e, i);
		return r.id = "ec_" + Cw++, Iw[r.id] = r, fr(t, kw, r.id), hu(r), r
	}

	function du(t) {
		if (x(t)) {
			var e = t;
			t = null, jx(e, function(e) {
				null != e.group && (t = e.group)
			}), t = t || "g_" + Dw++, jx(e, function(e) {
				e.group = t
			})
		}
		return Tw[t] = !0, t
	}

	function fu(t) {
		Tw[t] = !1
	}

	function pu(t) {
		"string" == typeof t ? t = Iw[t] : t instanceof Ul || (t = gu(t)), t instanceof Ul && !t.isDisposed() && t.dispose()
	}

	function gu(t) {
		return Iw[pr(t, kw)]
	}

	function vu(t) {
		return Iw[t]
	}

	function mu(t, e) {
		Sw[t] = e
	}

	function yu(t) {
		xw.push(t)
	}

	function _u(t, e) {
		Tu(_w, t, e, Jx)
	}

	function xu(t) {
		ww.push(t)
	}

	function wu(t, e, i) {
		"function" == typeof e && (i = e, e = "");
		var n = qx(t) ? t.type : [t, t = {
			event: e
		}][0];
		t.event = (t.event || n).toLowerCase(), e = t.event, Xx(fw.test(n) && fw.test(e)), mw[n] || (mw[n] = {
			action: i,
			actionInfo: t
		}), yw[e] = n
	}

	function bu(t, e) {
		Is.register(t, e)
	}

	function Su(t) {
		var e = Is.get(t);
		return e ? e.getDimensionsInfo ? e.getDimensionsInfo() : e.dimensions.slice() : void 0
	}

	function Mu(t, e) {
		Tu(bw, t, e, nw, "layout")
	}

	function Iu(t, e) {
		Tu(bw, t, e, ow, "visual")
	}

	function Tu(t, e, i, n, r) {
		(Yx(e) || qx(e)) && (i = e, e = n);
		var a = ml.wrapStageHandler(i, r);
		return a.__prio = e, a.__raw = i, t.push(a), a
	}

	function Cu(t, e) {
		Mw[t] = e
	}

	function Du(t) {
		return y_.extend(t)
	}

	function ku(t) {
		return ox.extend(t)
	}

	function Au(t) {
		return ax.extend(t)
	}

	function Pu(t) {
		return hl.extend(t)
	}

	function Lu(t) {
		i("createCanvas", t)
	}

	function Ou(t, e, i) {
		Gx.registerMap(t, e, i)
	}

	function Eu(t) {
		var e = Gx.retrieveMap(t);
		return e && e[0] && {
			geoJson: e[0].geoJSON,
			specialAreas: e[0].specialAreas
		}
	}

	function zu(t) {
		return t
	}

	function Bu(t, e, i, n, r) {
		this._old = t, this._new = e, this._oldKeyGetter = i || zu, this._newKeyGetter = n || zu, this.context = r
	}

	function Ru(t, e, i, n, r) {
		for (var a = 0; a < t.length; a++) {
			var o = "_ec_" + r[n](t[a], a),
				s = e[o];
			null == s ? (i.push(o), e[o] = a) : (s.length || (e[o] = s = [s]), s.push(a))
		}
	}

	function Nu(t) {
		var e = {},
			i = e.encode = {},
			n = N(),
			r = [],
			a = [],
			o = e.userOutput = {
				dimensionNames: t.dimensions.slice(),
				encode: {}
			};
		f(t.dimensions, function(e) {
			var s = t.getDimensionInfo(e),
				l = s.coordDim;
			if (l) {
				var u = s.coordDimIndex;
				Fu(i, l)[u] = e, s.isExtraCoord || (n.set(l, 1), Hu(s.type) && (r[0] = e), Fu(o.encode, l)[u] = s.index), s.defaultTooltip && a.push(e)
			}
			Lw.each(function(t, e) {
				var n = Fu(i, e),
					r = s.otherDims[e];
				null != r && r !== !1 && (n[r] = s.name)
			})
		});
		var s = [],
			l = {};
		n.each(function(t, e) {
			var n = i[e];
			l[e] = n[0], s = s.concat(n)
		}), e.dataDimsOnCoord = s, e.encodeFirstDimNotExtra = l;
		var u = i.label;
		u && u.length && (r = u.slice());
		var h = i.tooltip;
		return h && h.length ? a = h.slice() : a.length || (a = r.slice()), i.defaultedLabel = r, i.defaultedTooltip = a, e
	}

	function Fu(t, e) {
		return t.hasOwnProperty(e) || (t[e] = []), t[e]
	}

	function Vu(t) {
		return "category" === t ? "ordinal" : "time" === t ? "time" : "float"
	}

	function Hu(t) {
		return !("ordinal" === t || "time" === t)
	}

	function Wu(t) {
		null != t && o(this, t), this.otherDims = {}
	}

	function Gu(t) {
		return t._rawCount > 65535 ? Nw : Vw
	}

	function Uu(t) {
		var e = t.constructor;
		return e === Array ? t.slice() : new e(t)
	}

	function Xu(t, e) {
		f(Hw.concat(e.__wrappedMethods || []), function(i) {
			e.hasOwnProperty(i) && (t[i] = e[i])
		}), t.__wrappedMethods = e.__wrappedMethods, f(Ww, function(i) {
			t[i] = n(e[i])
		}), t._calculationInfo = o(e._calculationInfo)
	}

	function ju(t, e, i, n, r) {
		var a = Rw[e.type],
			o = n - 1,
			s = e.name,
			l = t[s][o];
		if (l && l.length < i) {
			for (var u = new a(Math.min(r - o * i, i)), h = 0; h < l.length; h++) u[h] = l[h];
			t[s][o] = u
		}
		for (var c = n * i; r > c; c += i) t[s].push(new a(Math.min(r - c, i)))
	}

	function Yu(t) {
		var e = t._invertedIndicesMap;
		f(e, function(i, n) {
			var r = t._dimensionInfos[n],
				a = r.ordinalMeta;
			if (a) {
				i = e[n] = new Fw(a.categories.length);
				for (var o = 0; o < i.length; o++) i[o] = zw;
				for (var o = 0; o < t._count; o++) i[t.get(n, o)] = o
			}
		})
	}

	function qu(t, e, i) {
		var n;
		if (null != e) {
			var r = t._chunkSize,
				a = Math.floor(i / r),
				o = i % r,
				s = t.dimensions[e],
				l = t._storage[s][a];
			if (l) {
				n = l[o];
				var u = t._dimensionInfos[s].ordinalMeta;
				u && u.categories.length && (n = u.categories[n])
			}
		}
		return n
	}

	function Zu(t) {
		return t
	}

	function Ku(t) {
		return t < this._count && t >= 0 ? this._indices[t] : -1
	}

	function $u(t, e) {
		var i = t._idList[e];
		return null == i && (i = qu(t, t._idDimIdx, e)), null == i && (i = Bw + e), i
	}

	function Qu(t) {
		return x(t) || (t = [t]), t
	}

	function Ju(t, e) {
		var i = t.dimensions,
			n = new Gw(p(i, t.getDimensionInfo, t), t.hostModel);
		Xu(n, t);
		for (var r = n._storage = {}, a = t._storage, o = 0; o < i.length; o++) {
			var s = i[o];
			a[s] && (u(e, s) >= 0 ? (r[s] = th(a[s]), n._rawExtent[s] = eh(), n._extent[s] = null) : r[s] = a[s])
		}
		return n
	}

	function th(t) {
		for (var e = new Array(t.length), i = 0; i < t.length; i++) e[i] = Uu(t[i]);
		return e
	}

	function eh() {
		return [1 / 0, -1 / 0]
	}

	function ih(t, e, i) {
		function r(t, e, i) {
			null != Lw.get(e) ? t.otherDims[e] = i : (t.coordDim = e, t.coordDimIndex = i, u.set(e, !0))
		}
		rs.isInstance(e) || (e = rs.seriesDataToSource(e)), i = i || {}, t = (t || []).slice();
		for (var a = (i.dimsDef || []).slice(), l = N(), u = N(), h = [], c = nh(e, t, a, i.dimCount), d = 0; c > d; d++) {
			var p = a[d] = o({}, S(a[d]) ? a[d] : {
					name: a[d]
				}),
				g = p.name,
				v = h[d] = new Wu;
			null != g && null == l.get(g) && (v.name = v.displayName = g, l.set(g, d)), null != p.type && (v.type = p.type), null != p.displayName && (v.displayName = p.displayName)
		}
		var m = i.encodeDef;
		!m && i.encodeDefaulter && (m = i.encodeDefaulter(e, c)), m = N(m), m.each(function(t, e) {
			if (t = er(t).slice(), 1 === t.length && !b(t[0]) && t[0] < 0) return void m.set(e, !1);
			var i = m.set(e, []);
			f(t, function(t, n) {
				b(t) && (t = l.get(t)), null != t && c > t && (i[n] = t, r(h[t], e, n))
			})
		});
		var y = 0;
		f(t, function(t) {
			var e, t, i, a;
			if (b(t)) e = t, t = {};
			else {
				e = t.name;
				var o = t.ordinalMeta;
				t.ordinalMeta = null, t = n(t), t.ordinalMeta = o, i = t.dimsDef, a = t.otherDims, t.name = t.coordDim = t.coordDimIndex = t.dimsDef = t.otherDims = null
			}
			var l = m.get(e);
			if (l !== !1) {
				var l = er(l);
				if (!l.length)
					for (var u = 0; u < (i && i.length || 1); u++) {
						for (; y < h.length && null != h[y].coordDim;) y++;
						y < h.length && l.push(y++)
					}
				f(l, function(n, o) {
					var l = h[n];
					if (r(s(l, t), e, o), null == l.name && i) {
						var u = i[o];
						!S(u) && (u = {
							name: u
						}), l.name = l.displayName = u.name, l.defaultTooltip = u.defaultTooltip
					}
					a && s(l.otherDims, a)
				})
			}
		});
		var _ = i.generateCoord,
			x = i.generateCoordCount,
			w = null != x;
		x = _ ? x || 1 : 0;
		for (var M = _ || "value", I = 0; c > I; I++) {
			var v = h[I] = h[I] || new Wu,
				T = v.coordDim;
			null == T && (v.coordDim = rh(M, u, w), v.coordDimIndex = 0, (!_ || 0 >= x) && (v.isExtraCoord = !0), x--), null == v.name && (v.name = rh(v.coordDim, l)), null != v.type || gs(e, I, v.name) !== P_.Must && (!v.isExtraCoord || null == v.otherDims.itemName && null == v.otherDims.seriesName) || (v.type = "ordinal")
		}
		return h
	}

	function nh(t, e, i, n) {
		var r = Math.max(t.dimensionsDetectCount || 1, e.length, i.length, n || 0);
		return f(e, function(t) {
			var e = t.dimsDef;
			e && (r = Math.max(r, e.length))
		}), r
	}

	function rh(t, e, i) {
		if (i || null != e.get(t)) {
			for (var n = 0; null != e.get(t + n);) n++;
			t += n
		}
		return e.set(t, !0), t
	}

	function ah(t) {
		this.coordSysName = t, this.coordSysDims = [], this.axisMap = N(), this.categoryAxisMap = N(), this.firstCategoryDimIndex = null
	}

	function oh(t) {
		var e = t.get("coordinateSystem"),
			i = new ah(e),
			n = Yw[e];
		return n ? (n(t, i, i.axisMap, i.categoryAxisMap), i) : void 0
	}

	function sh(t) {
		return "category" === t.get("type")
	}

	function lh(t, e, i) {
		i = i || {};
		var n, r, a, o, s = i.byIndex,
			l = i.stackedCoordDimension,
			u = !(!t || !t.get("stack"));
		if (f(e, function(t, i) {
				b(t) && (e[i] = t = {
					name: t
				}), u && !t.isExtraCoord && (s || n || !t.ordinalMeta || (n = t), r || "ordinal" === t.type || "time" === t.type || l && l !== t.coordDim || (r = t))
			}), !r || s || n || (s = !0), r) {
			a = "__\x00ecstackresult", o = "__\x00ecstackedover", n && (n.createInvertedIndices = !0);
			var h = r.coordDim,
				c = r.type,
				d = 0;
			f(e, function(t) {
				t.coordDim === h && d++
			}), e.push({
				name: a,
				coordDim: h,
				coordDimIndex: d,
				type: c,
				isExtraCoord: !0,
				isCalculationCoord: !0
			}), d++, e.push({
				name: o,
				coordDim: o,
				coordDimIndex: d,
				type: c,
				isExtraCoord: !0,
				isCalculationCoord: !0
			})
		}
		return {
			stackedDimension: r && r.name,
			stackedByDimension: n && n.name,
			isStackedByIndex: s,
			stackedOverDimension: o,
			stackResultDimension: a
		}
	}

	function uh(t, e) {
		return !!e && e === t.getCalculationInfo("stackedDimension")
	}

	function hh(t, e) {
		return uh(t, e) ? t.getCalculationInfo("stackResultDimension") : e
	}

	function ch(t, e, i) {
		i = i || {}, rs.isInstance(t) || (t = rs.seriesDataToSource(t));
		var n, r = e.get("coordinateSystem"),
			a = Is.get(r),
			o = oh(e);
		o && (n = p(o.coordSysDims, function(t) {
			var e = {
					name: t
				},
				i = o.axisMap.get(t);
			if (i) {
				var n = i.get("type");
				e.type = Vu(n)
			}
			return e
		})), n || (n = a && (a.getDimensionsInfo ? a.getDimensionsInfo() : a.dimensions.slice()) || ["x", "y"]);
		var s, l, u = jw(t, {
			coordDimensions: n,
			generateCoord: i.generateCoord,
			encodeDefaulter: i.useEncodeDefaulter ? _(fs, n, e) : null
		});
		o && f(u, function(t, e) {
			var i = t.coordDim,
				n = o.categoryAxisMap.get(i);
			n && (null == s && (s = e), t.ordinalMeta = n.getOrdinalMeta()), null != t.otherDims.itemName && (l = !0)
		}), l || null == s || (u[s].otherDims.itemName = 0);
		var h = lh(e, u),
			c = new Gw(u, e);
		c.setCalculationInfo(h);
		var d = null != s && dh(t) ? function(t, e, i, n) {
			return n === s ? i : this.defaultDimValueGetter(t, e, i, n)
		} : null;
		return c.hasItemOption = !1, c.initData(t, null, d), c
	}

	function dh(t) {
		if (t.sourceFormat === S_) {
			var e = fh(t.data || []);
			return null != e && !x(nr(e))
		}
	}

	function fh(t) {
		for (var e = 0; e < t.length && null == t[e];) e++;
		return t[e]
	}

	function ph(t) {
		this._setting = t || {}, this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments)
	}

	function gh(t) {
		this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this._map
	}

	function vh(t) {
		return t._map || (t._map = N(t.categories))
	}

	function mh(t) {
		return S(t) && null != t.value ? t.value : t + ""
	}

	function yh(t, e, i, n) {
		var r = {},
			a = t[1] - t[0],
			o = r.interval = zo(a / e, !0);
		null != i && i > o && (o = r.interval = i), null != n && o > n && (o = r.interval = n);
		var s = r.intervalPrecision = _h(o),
			l = r.niceTickExtent = [$w(Math.ceil(t[0] / o) * o, s), $w(Math.floor(t[1] / o) * o, s)];
		return wh(l, t), r
	}

	function _h(t) {
		return Co(t) + 2
	}

	function xh(t, e, i) {
		t[e] = Math.max(Math.min(t[e], i[1]), i[0])
	}

	function wh(t, e) {
		!isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), xh(t, 0, e), xh(t, 1, e), t[0] > t[1] && (t[0] = t[1])
	}

	function bh(t) {
		return t.get("stack") || tb + t.seriesIndex
	}

	function Sh(t) {
		return t.dim + t.index
	}

	function Mh(t, e) {
		var i = [];
		return e.eachSeriesByType(t, function(t) {
			kh(t) && !Ah(t) && i.push(t)
		}), i
	}

	function Ih(t) {
		var e = {};
		f(t, function(t) {
			var i = t.coordinateSystem,
				n = i.getBaseAxis();
			if ("time" === n.type || "value" === n.type)
				for (var r = t.getData(), a = n.dim + "_" + n.index, o = r.mapDimension(n.dim), s = 0, l = r.count(); l > s; ++s) {
					var u = r.get(o, s);
					e[a] ? e[a].push(u) : e[a] = [u]
				}
		});
		var i = [];
		for (var n in e)
			if (e.hasOwnProperty(n)) {
				var r = e[n];
				if (r) {
					r.sort(function(t, e) {
						return t - e
					});
					for (var a = null, o = 1; o < r.length; ++o) {
						var s = r[o] - r[o - 1];
						s > 0 && (a = null === a ? s : Math.min(a, s))
					}
					i[n] = a
				}
			}
		return i
	}

	function Th(t) {
		var e = Ih(t),
			i = [];
		return f(t, function(t) {
			var n, r = t.coordinateSystem,
				a = r.getBaseAxis(),
				o = a.getExtent();
			if ("category" === a.type) n = a.getBandWidth();
			else if ("value" === a.type || "time" === a.type) {
				var s = a.dim + "_" + a.index,
					l = e[s],
					u = Math.abs(o[1] - o[0]),
					h = a.scale.getExtent(),
					c = Math.abs(h[1] - h[0]);
				n = l ? u / c * l : u
			} else {
				var d = t.getData();
				n = Math.abs(o[1] - o[0]) / d.count()
			}
			var f = So(t.get("barWidth"), n),
				p = So(t.get("barMaxWidth"), n),
				g = So(t.get("barMinWidth") || 1, n),
				v = t.get("barGap"),
				m = t.get("barCategoryGap");
			i.push({
				bandWidth: n,
				barWidth: f,
				barMaxWidth: p,
				barMinWidth: g,
				barGap: v,
				barCategoryGap: m,
				axisKey: Sh(a),
				stackId: bh(t)
			})
		}), Ch(i)
	}

	function Ch(t) {
		var e = {};
		f(t, function(t) {
			var i = t.axisKey,
				n = t.bandWidth,
				r = e[i] || {
					bandWidth: n,
					remainedWidth: n,
					autoWidthCount: 0,
					categoryGap: "20%",
					gap: "30%",
					stacks: {}
				},
				a = r.stacks;
			e[i] = r;
			var o = t.stackId;
			a[o] || r.autoWidthCount++, a[o] = a[o] || {
				width: 0,
				maxWidth: 0
			};
			var s = t.barWidth;
			s && !a[o].width && (a[o].width = s, s = Math.min(r.remainedWidth, s), r.remainedWidth -= s);
			var l = t.barMaxWidth;
			l && (a[o].maxWidth = l);
			var u = t.barMinWidth;
			u && (a[o].minWidth = u);
			var h = t.barGap;
			null != h && (r.gap = h);
			var c = t.barCategoryGap;
			null != c && (r.categoryGap = c)
		});
		var i = {};
		return f(e, function(t, e) {
			i[e] = {};
			var n = t.stacks,
				r = t.bandWidth,
				a = So(t.categoryGap, r),
				o = So(t.gap, 1),
				s = t.remainedWidth,
				l = t.autoWidthCount,
				u = (s - a) / (l + (l - 1) * o);
			u = Math.max(u, 0), f(n, function(t) {
				var e = t.maxWidth,
					i = t.minWidth;
				if (t.width) {
					var n = t.width;
					e && (n = Math.min(n, e)), i && (n = Math.max(n, i)), t.width = n, s -= n + o * n, l--
				} else {
					var n = u;
					e && n > e && (n = Math.min(e, s)), i && i > n && (n = i), n !== u && (t.width = n, s -= n + o * n, l--)
				}
			}), u = (s - a) / (l + (l - 1) * o), u = Math.max(u, 0);
			var h, c = 0;
			f(n, function(t) {
				t.width || (t.width = u), h = t, c += t.width * (1 + o)
			}), h && (c -= h.width * o);
			var d = -c / 2;
			f(n, function(t, n) {
				i[e][n] = i[e][n] || {
					bandWidth: r,
					offset: d,
					width: t.width
				}, d += t.width * (1 + o)
			})
		}), i
	}

	function Dh(t, e, i) {
		if (t && e) {
			var n = t[Sh(e)];
			return null != n && null != i && (n = n[bh(i)]), n
		}
	}

	function kh(t) {
		return t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type
	}

	function Ah(t) {
		return t.pipelineContext && t.pipelineContext.large
	}

	function Ph(t, e) {
		return e.toGlobalCoord(e.dataToCoord("log" === e.type ? 1 : 0))
	}

	function Lh(t, e) {
		return vb(t, gb(e))
	}

	function Oh(t, e) {
		var i, n, r, a = t.type,
			o = e.getMin(),
			s = e.getMax(),
			l = t.getExtent();
		"ordinal" === a ? i = e.getCategories().length : (n = e.get("boundaryGap"), x(n) || (n = [n || 0, n || 0]), "boolean" == typeof n[0] && (n = [0, 0]), n[0] = So(n[0], 1), n[1] = So(n[1], 1), r = l[1] - l[0] || Math.abs(l[0])), "dataMin" === o ? o = l[0] : "function" == typeof o && (o = o({
			min: l[0],
			max: l[1]
		})), "dataMax" === s ? s = l[1] : "function" == typeof s && (s = s({
			min: l[0],
			max: l[1]
		}));
		var u = null != o,
			h = null != s;
		null == o && (o = "ordinal" === a ? i ? 0 : 0 / 0 : l[0] - n[0] * r), null == s && (s = "ordinal" === a ? i ? i - 1 : 0 / 0 : l[1] + n[1] * r), (null == o || !isFinite(o)) && (o = 0 / 0), (null == s || !isFinite(s)) && (s = 0 / 0), t.setBlank(C(o) || C(s) || "ordinal" === a && !t.getOrdinalMeta().categories.length), e.getNeedCrossZero() && (o > 0 && s > 0 && !u && (o = 0), 0 > o && 0 > s && !h && (s = 0));
		var c = e.ecModel;
		if (c && "time" === a) {
			var d, p = Mh("bar", c);
			if (f(p, function(t) {
					d |= t.getBaseAxis() === e.axis
				}), d) {
				var g = Th(p),
					v = Eh(o, s, e, g);
				o = v.min, s = v.max
			}
		}
		return {
			extent: [o, s],
			fixMin: u,
			fixMax: h
		}
	}

	function Eh(t, e, i, n) {
		var r = i.axis.getExtent(),
			a = r[1] - r[0],
			o = Dh(n, i.axis);
		if (void 0 === o) return {
			min: t,
			max: e
		};
		var s = 1 / 0;
		f(o, function(t) {
			s = Math.min(t.offset, s)
		});
		var l = -1 / 0;
		f(o, function(t) {
			l = Math.max(t.offset + t.width, l)
		}), s = Math.abs(s), l = Math.abs(l);
		var u = s + l,
			h = e - t,
			c = 1 - (s + l) / a,
			d = h / c - h;
		return e += d * (l / u), t -= d * (s / u), {
			min: t,
			max: e
		}
	}

	function zh(t, e) {
		var i = Oh(t, e),
			n = i.extent,
			r = e.get("splitNumber");
		"log" === t.type && (t.base = e.get("logBase"));
		var a = t.type;
		t.setExtent(n[0], n[1]), t.niceExtent({
			splitNumber: r,
			fixMin: i.fixMin,
			fixMax: i.fixMax,
			minInterval: "interval" === a || "time" === a ? e.get("minInterval") : null,
			maxInterval: "interval" === a || "time" === a ? e.get("maxInterval") : null
		});
		var o = e.get("interval");
		null != o && t.setInterval && t.setInterval(o)
	}

	function Bh(t, e) {
		if (e = e || t.get("type")) switch (e) {
			case "category":
				return new Kw(t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(), [1 / 0, -1 / 0]);
			case "value":
				return new Jw;
			default:
				return (ph.getClass(e) || Jw).create(t)
		}
	}

	function Rh(t) {
		var e = t.getLabelModel().get("formatter"),
			i = "category" === t.type ? t.scale.getExtent()[0] : null;
		return "string" == typeof e ? e = function(e) {
			return function(i) {
				return i = t.scale.getLabel(i), e.replace("{value}", null != i ? i : "")
			}
		}(e) : "function" == typeof e ? function(n, r) {
			return null != i && (r = n - i), e(Nh(t, n), r)
		} : function(e) {
			return t.scale.getLabel(e)
		}
	}

	function Nh(t, e) {
		return "category" === t.type ? t.scale.getLabel(e) : e
	}

	function Fh(t) {
		var e = t.get("interval");
		return null == e ? "auto" : e
	}

	function Vh(t) {
		return "category" === t.type && 0 === Fh(t.getLabelModel())
	}

	function Hh(t, e) {
		if ("image" !== this.type) {
			var i = this.style,
				n = this.shape;
			n && "line" === n.symbolType ? i.stroke = t : this.__isEmptyBrush ? (i.stroke = t, i.fill = e || "#fff") : (i.fill && (i.fill = t), i.stroke && (i.stroke = t)), this.dirty(!1)
		}
	}

	function Wh(t, e, i, n, r, a, o) {
		var s = 0 === t.indexOf("empty");
		s && (t = t.substr(5, 1).toLowerCase() + t.substr(6));
		var l;
		return l = 0 === t.indexOf("image://") ? wa(t.slice(8), new Ti(e, i, n, r), o ? "center" : "cover") : 0 === t.indexOf("path://") ? xa(t.slice(7), {}, new Ti(e, i, n, r), o ? "center" : "cover") : new Ab({
			shape: {
				symbolType: t,
				x: e,
				y: i,
				width: n,
				height: r
			}
		}), l.__isEmptyBrush = s, l.setColor = Hh, l.setColor(a), l
	}

	function Gh(t) {
		return ch(t.getSource(), t)
	}

	function Uh(t, e) {
		var i = e;
		go.isInstance(e) || (i = new go(e), c(i, bb));
		var n = Bh(i);
		return n.setExtent(t[0], t[1]), zh(n, i), n
	}

	function Xh(t) {
		c(t, bb)
	}

	function jh(t, e) {
		return Math.abs(t - e) < Ob
	}

	function Yh(t, e, i) {
		var n = 0,
			r = t[0];
		if (!r) return !1;
		for (var a = 1; a < t.length; a++) {
			var o = t[a];
			n += Yr(r[0], r[1], o[0], o[1], e, i), r = o
		}
		var s = t[0];
		return jh(r[0], s[0]) && jh(r[1], s[1]) || (n += Yr(r[0], r[1], s[0], s[1], e, i)), 0 !== n
	}

	function qh(t, e, i) {
		if (this.name = t, this.geometries = e, i) i = [i[0], i[1]];
		else {
			var n = this.getBoundingRect();
			i = [n.x + n.width / 2, n.y + n.height / 2]
		}
		this.center = i
	}

	function Zh(t) {
		if (!t.UTF8Encoding) return t;
		var e = t.UTF8Scale;
		null == e && (e = 1024);
		for (var i = t.features, n = 0; n < i.length; n++)
			for (var r = i[n], a = r.geometry, o = a.coordinates, s = a.encodeOffsets, l = 0; l < o.length; l++) {
				var u = o[l];
				if ("Polygon" === a.type) o[l] = Kh(u, s[l], e);
				else if ("MultiPolygon" === a.type)
					for (var h = 0; h < u.length; h++) {
						var c = u[h];
						u[h] = Kh(c, s[l][h], e)
					}
			}
		return t.UTF8Encoding = !1, t
	}

	function Kh(t, e, i) {
		for (var n = [], r = e[0], a = e[1], o = 0; o < t.length; o += 2) {
			var s = t.charCodeAt(o) - 64,
				l = t.charCodeAt(o + 1) - 64;
			s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), s += r, l += a, r = s, a = l, n.push([s / i, l / i])
		}
		return n
	}

	function $h(t) {
		return "category" === t.type ? Jh(t) : ic(t)
	}

	function Qh(t, e) {
		return "category" === t.type ? ec(t, e) : {
			ticks: t.scale.getTicks()
		}
	}

	function Jh(t) {
		var e = t.getLabelModel(),
			i = tc(t, e);
		return !e.get("show") || t.scale.isBlank() ? {
			labels: [],
			labelCategoryInterval: i.labelCategoryInterval
		} : i
	}

	function tc(t, e) {
		var i = nc(t, "labels"),
			n = Fh(e),
			r = rc(i, n);
		if (r) return r;
		var a, o;
		return w(n) ? a = hc(t, n) : (o = "auto" === n ? oc(t) : n, a = uc(t, o)), ac(i, n, {
			labels: a,
			labelCategoryInterval: o
		})
	}

	function ec(t, e) {
		var i = nc(t, "ticks"),
			n = Fh(e),
			r = rc(i, n);
		if (r) return r;
		var a, o;
		if ((!e.get("show") || t.scale.isBlank()) && (a = []), w(n)) a = hc(t, n, !0);
		else if ("auto" === n) {
			var s = tc(t, t.getLabelModel());
			o = s.labelCategoryInterval, a = p(s.labels, function(t) {
				return t.tickValue
			})
		} else o = n, a = uc(t, o, !0);
		return ac(i, n, {
			ticks: a,
			tickCategoryInterval: o
		})
	}

	function ic(t) {
		var e = t.scale.getTicks(),
			i = Rh(t);
		return {
			labels: p(e, function(e, n) {
				return {
					formattedLabel: i(e, n),
					rawLabel: t.scale.getLabel(e),
					tickValue: e
				}
			})
		}
	}

	function nc(t, e) {
		return zb(t)[e] || (zb(t)[e] = [])
	}

	function rc(t, e) {
		for (var i = 0; i < t.length; i++)
			if (t[i].key === e) return t[i].value
	}

	function ac(t, e, i) {
		return t.push({
			key: e,
			value: i
		}), i
	}

	function oc(t) {
		var e = zb(t).autoInterval;
		return null != e ? e : zb(t).autoInterval = t.calculateCategoryInterval()
	}

	function sc(t) {
		var e = lc(t),
			i = Rh(t),
			n = (e.axisRotate - e.labelRotate) / 180 * Math.PI,
			r = t.scale,
			a = r.getExtent(),
			o = r.count();
		if (a[1] - a[0] < 1) return 0;
		var s = 1;
		o > 40 && (s = Math.max(1, Math.floor(o / 40)));
		for (var l = a[0], u = t.dataToCoord(l + 1) - t.dataToCoord(l), h = Math.abs(u * Math.cos(n)), c = Math.abs(u * Math.sin(n)), d = 0, f = 0; l <= a[1]; l += s) {
			var p = 0,
				g = 0,
				v = ji(i(l), e.font, "center", "top");
			p = 1.3 * v.width, g = 1.3 * v.height, d = Math.max(d, p, 7), f = Math.max(f, g, 7)
		}
		var m = d / h,
			y = f / c;
		isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0);
		var _ = Math.max(0, Math.floor(Math.min(m, y))),
			x = zb(t.model),
			w = t.getExtent(),
			b = x.lastAutoInterval,
			S = x.lastTickCount;
		return null != b && null != S && Math.abs(b - _) <= 1 && Math.abs(S - o) <= 1 && b > _ && x.axisExtend0 === w[0] && x.axisExtend1 === w[1] ? _ = b : (x.lastTickCount = o, x.lastAutoInterval = _, x.axisExtend0 = w[0], x.axisExtend1 = w[1]), _
	}

	function lc(t) {
		var e = t.getLabelModel();
		return {
			axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0,
			labelRotate: e.get("rotate") || 0,
			font: e.getFont()
		}
	}

	function uc(t, e, i) {
		function n(t) {
			l.push(i ? t : {
				formattedLabel: r(t),
				rawLabel: a.getLabel(t),
				tickValue: t
			})
		}
		var r = Rh(t),
			a = t.scale,
			o = a.getExtent(),
			s = t.getLabelModel(),
			l = [],
			u = Math.max((e || 0) + 1, 1),
			h = o[0],
			c = a.count();
		0 !== h && u > 1 && c / u > 2 && (h = Math.round(Math.ceil(h / u) * u));
		var d = Vh(t),
			f = s.get("showMinLabel") || d,
			p = s.get("showMaxLabel") || d;
		f && h !== o[0] && n(o[0]);
		for (var g = h; g <= o[1]; g += u) n(g);
		return p && g - u !== o[1] && n(o[1]), l
	}

	function hc(t, e, i) {
		var n = t.scale,
			r = Rh(t),
			a = [];
		return f(n.getTicks(), function(t) {
			var o = n.getLabel(t);
			e(t, o) && a.push(i ? t : {
				formattedLabel: r(t),
				rawLabel: o,
				tickValue: t
			})
		}), a
	}

	function cc(t, e) {
		var i = t[1] - t[0],
			n = e,
			r = i / n / 2;
		t[0] += r, t[1] -= r
	}

	function dc(t, e, i, n) {
		function r(t, e) {
			return t = Mo(t), e = Mo(e), d ? t > e : e > t
		}
		var a = e.length;
		if (t.onBand && !i && a) {
			var o, s, l = t.getExtent();
			if (1 === a) e[0].coord = l[0], o = e[1] = {
				coord: l[0]
			};
			else {
				var u = e[a - 1].tickValue - e[0].tickValue,
					h = (e[a - 1].coord - e[0].coord) / u;
				f(e, function(t) {
					t.coord -= h / 2
				});
				var c = t.scale.getExtent();
				s = 1 + c[1] - e[a - 1].tickValue, o = {
					coord: e[a - 1].coord + h * s
				}, e.push(o)
			}
			var d = l[0] > l[1];
			r(e[0].coord, l[0]) && (n ? e[0].coord = l[0] : e.shift()), n && r(l[0], e[0].coord) && e.unshift({
				coord: l[0]
			}), r(l[1], o.coord) && (n ? o.coord = l[1] : e.pop()), n && r(o.coord, l[1]) && e.push({
				coord: l[1]
			})
		}
	}

	function fc(t) {
		return "_EC_" + t
	}

	function pc(t, e) {
		this.id = null == t ? "" : t, this.inEdges = [], this.outEdges = [], this.edges = [], this.hostGraph, this.dataIndex = null == e ? -1 : e
	}

	function gc(t, e, i) {
		this.node1 = t, this.node2 = e, this.dataIndex = null == i ? -1 : i
	}

	function vc(t) {
		var e = t.mainData,
			i = t.datas;
		i || (i = {
			main: e
		}, t.datasAttr = {
			main: "data"
		}), t.datas = t.mainData = null, bc(e, i, t), Ub(i, function(i) {
			Ub(e.TRANSFERABLE_METHODS, function(e) {
				i.wrapMethod(e, _(mc, t))
			})
		}), e.wrapMethod("cloneShallow", _(_c, t)), Ub(e.CHANGABLE_METHODS, function(i) {
			e.wrapMethod(i, _(yc, t))
		}), O(i[e.dataType] === e)
	}

	function mc(t, e) {
		if (wc(this)) {
			var i = o({}, this[Xb]);
			i[this.dataType] = e, bc(e, i, t)
		} else Sc(e, this.dataType, this[jb], t);
		return e
	}

	function yc(t, e) {
		return t.struct && t.struct.update(this), e
	}

	function _c(t, e) {
		return Ub(e[Xb], function(i, n) {
			i !== e && Sc(i.cloneShallow(), n, e, t)
		}), e
	}

	function xc(t) {
		var e = this[jb];
		return null == t || null == e ? e : e[Xb][t]
	}

	function wc(t) {
		return t[jb] === t
	}

	function bc(t, e, i) {
		t[Xb] = {}, Ub(e, function(e, n) {
			Sc(e, n, t, i)
		})
	}

	function Sc(t, e, i, n) {
		i[Xb][e] = t, t[jb] = i, t.dataType = e, n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t), t.getLinkedData = xc
	}

	function Mc(t, e) {
		this.getAllNames = function() {
			var t = e();
			return t.mapArray(t.getName)
		}, this.containName = function(t) {
			var i = e();
			return i.indexOfName(t) >= 0
		}, this.indexOfName = function(e) {
			var i = t();
			return i.indexOfName(e)
		}, this.getItemVisual = function(e, i) {
			var n = t();
			return n.getItemVisual(e, i)
		}
	}

	function Ic(t) {
		Zb(t) && (t.__curvenessList = [], t.__edgeMap = {}, Kb(t))
	}

	function Tc(t, e, i, n) {
		if (Zb(i)) {
			var r = $b(t, e, i),
				a = i.__edgeMap,
				o = a[Qb(r)];
			a[r] && !o ? a[r].isForward = !0 : o && a[r] && (o.isForward = !0, a[r].isForward = !1), a[r] = a[r] || [], a[r].push(n)
		}
	}

	function Cc(t, e, i, n) {
		var r = Zb(e),
			a = x(r);
		if (!r) return null;
		var o = Jb(t, e);
		if (!o) return null;
		for (var s = -1, l = 0; l < o.length; l++)
			if (o[l] === i) {
				s = l;
				break
			}
		var u = tS(t, e);
		Kb(e, u), t.lineStyle = t.lineStyle || {};
		var h = $b(t.node1, t.node2, e),
			c = e.__curvenessList,
			d = a ? 0 : u % 2 ? 0 : 1;
		if (o.isForward) return c[d + s];
		var f = Qb(h),
			p = eS(f, e),
			g = c[s + p + d];
		return n ? a ? r && 0 === r[0] ? (p + d) % 2 ? g : -g : ((p % 2 ? 0 : 1) + d) % 2 ? g : -g : (p + d) % 2 ? g : -g : c[s + p + d]
	}

	function Dc(t, e) {
		var i = t.mapDimension("defaultedLabel", !0),
			n = i.length;
		if (1 === n) return $s(t, e, i[0]);
		if (n) {
			for (var r = [], a = 0; a < i.length; a++) {
				var o = $s(t, e, i[a]);
				r.push(o)
			}
			return r.join(" ")
		}
	}

	function kc(t, e, i) {
		Zg.call(this), this.updateData(t, e, i)
	}

	function Ac(t) {
		return [t[0] / 2, t[1] / 2]
	}

	function Pc(t, e) {
		this.parent.drift(t, e)
	}

	function Lc(t, e) {
		if (!this.incremental && !this.useHoverLayer)
			if ("emphasis" === e) {
				var i = this.__symbolOriginalScale,
					n = i[1] / i[0],
					r = {
						scale: [Math.max(1.1 * i[0], i[0] + 3), Math.max(1.1 * i[1], i[1] + 3 * n)]
					};
				this.animateTo(r, 400, "elasticOut")
			} else "normal" === e && this.animateTo({
				scale: this.__symbolOriginalScale
			}, 400, "elasticOut")
	}

	function Oc(t) {
		this.group = new Zg, this._symbolCtor = t || kc
	}

	function Ec(t, e, i, n) {
		return !(!e || isNaN(e[0]) || isNaN(e[1]) || n.isIgnore && n.isIgnore(i) || n.clipShape && !n.clipShape.contain(e[0], e[1]) || "none" === t.getItemVisual(i, "symbol"))
	}

	function zc(t) {
		return null == t || S(t) || (t = {
			isIgnore: t
		}), t || {}
	}

	function Bc(t) {
		var e = t.hostModel;
		return {
			itemStyle: e.getModel("itemStyle").getItemStyle(["color"]),
			hoverItemStyle: e.getModel("emphasis.itemStyle").getItemStyle(),
			symbolRotate: e.get("symbolRotate"),
			symbolOffset: e.get("symbolOffset"),
			hoverAnimation: e.get("hoverAnimation"),
			labelModel: e.getModel("label"),
			hoverLabelModel: e.getModel("emphasis.label"),
			cursorStyle: e.get("cursor")
		}
	}

	function Rc(t) {
		return isNaN(+t.cpx1) || isNaN(+t.cpy1)
	}

	function Nc(t) {
		return "_" + t + "Type"
	}

	function Fc(t, e, i) {
		var n = e.getItemVisual(i, t);
		if (n && "none" !== n) {
			var r = e.getItemVisual(i, "color"),
				a = e.getItemVisual(i, t + "Size"),
				o = e.getItemVisual(i, t + "Rotate");
			x(a) || (a = [a, a]);
			var s = Wh(n, -a[0] / 2, -a[1] / 2, a[0], a[1], r);
			return s.__specifiedRotation = null == o || isNaN(o) ? void 0 : +o * Math.PI / 180 || 0, s.name = t, s
		}
	}

	function Vc(t) {
		var e = new dS({
			name: "line",
			subPixelOptimize: !0
		});
		return Hc(e.shape, t), e
	}

	function Hc(t, e) {
		t.x1 = e[0][0], t.y1 = e[0][1], t.x2 = e[1][0], t.y2 = e[1][1], t.percent = 1;
		var i = e[2];
		i ? (t.cpx1 = i[0], t.cpy1 = i[1]) : (t.cpx1 = 0 / 0, t.cpy1 = 0 / 0)
	}

	function Wc() {
		var t = this,
			e = t.childOfName("fromSymbol"),
			i = t.childOfName("toSymbol"),
			n = t.childOfName("label");
		if (e || i || !n.ignore) {
			for (var r = 1, a = this.parent; a;) a.scale && (r /= a.scale[0]), a = a.parent;
			var o = t.childOfName("line");
			if (this.__dirty || o.__dirty) {
				var s = o.shape.percent,
					l = o.pointAt(0),
					u = o.pointAt(s),
					h = Y([], u, l);
				if (te(h, h), e) {
					e.attr("position", l);
					var c = e.__specifiedRotation;
					if (null == c) {
						var d = o.tangentAt(0);
						e.attr("rotation", Math.PI / 2 - Math.atan2(d[1], d[0]))
					} else e.attr("rotation", c);
					e.attr("scale", [r * s, r * s])
				}
				if (i) {
					i.attr("position", u);
					var c = i.__specifiedRotation;
					if (null == c) {
						var d = o.tangentAt(1);
						i.attr("rotation", -Math.PI / 2 - Math.atan2(d[1], d[0]))
					} else i.attr("rotation", c);
					i.attr("scale", [r * s, r * s])
				}
				if (!n.ignore) {
					n.attr("position", u);
					var f, p, g, v, m = n.__labelDistance,
						y = m[0] * r,
						_ = m[1] * r,
						x = s / 2,
						d = o.tangentAt(x),
						w = [d[1], -d[0]],
						b = o.pointAt(x);
					w[1] > 0 && (w[0] = -w[0], w[1] = -w[1]);
					var S = d[0] < 0 ? -1 : 1;
					if ("start" !== n.__position && "end" !== n.__position) {
						var M = -Math.atan2(d[1], d[0]);
						u[0] < l[0] && (M = Math.PI + M), n.attr("rotation", M)
					}
					var I;
					switch (n.__position) {
						case "insideStartTop":
						case "insideMiddleTop":
						case "insideEndTop":
						case "middle":
							I = -_, g = "bottom";
							break;
						case "insideStartBottom":
						case "insideMiddleBottom":
						case "insideEndBottom":
							I = _, g = "top";
							break;
						default:
							I = 0, g = "middle"
					}
					switch (n.__position) {
						case "end":
							f = [h[0] * y + u[0], h[1] * _ + u[1]], p = h[0] > .8 ? "left" : h[0] < -.8 ? "right" : "center", g = h[1] > .8 ? "top" : h[1] < -.8 ? "bottom" : "middle";
							break;
						case "start":
							f = [-h[0] * y + l[0], -h[1] * _ + l[1]], p = h[0] > .8 ? "right" : h[0] < -.8 ? "left" : "center", g = h[1] > .8 ? "bottom" : h[1] < -.8 ? "top" : "middle";
							break;
						case "insideStartTop":
						case "insideStart":
						case "insideStartBottom":
							f = [y * S + l[0], l[1] + I], p = d[0] < 0 ? "right" : "left", v = [-y * S, -I];
							break;
						case "insideMiddleTop":
						case "insideMiddle":
						case "insideMiddleBottom":
						case "middle":
							f = [b[0], b[1] + I], p = "center", v = [0, -I];
							break;
						case "insideEndTop":
						case "insideEnd":
						case "insideEndBottom":
							f = [-y * S + u[0], u[1] + I], p = d[0] >= 0 ? "right" : "left", v = [y * S, -I]
					}
					n.attr({
						style: {
							textVerticalAlign: n.__verticalAlign || g,
							textAlign: n.__textAlign || p
						},
						position: f,
						scale: [r, r],
						origin: v
					})
				}
			}
		}
	}

	function Gc(t, e, i) {
		Zg.call(this), this._createLine(t, e, i)
	}

	function Uc(t) {
		this._ctor = t || Gc, this.group = new Zg
	}

	function Xc(t, e, i, n) {
		var r = e.getItemLayout(i);
		if (Kc(r)) {
			var a = new t._ctor(e, i, n);
			e.setItemGraphicEl(i, a), t.group.add(a)
		}
	}

	function jc(t, e, i, n, r, a) {
		var o = e.getItemGraphicEl(n);
		return Kc(i.getItemLayout(r)) ? (o ? o.updateData(i, r, a) : o = new t._ctor(i, r, a), i.setItemGraphicEl(r, o), void t.group.add(o)) : void t.group.remove(o)
	}

	function Yc(t) {
		return t.animators && t.animators.length > 0
	}

	function qc(t) {
		var e = t.hostModel;
		return {
			lineStyle: e.getModel("lineStyle").getLineStyle(),
			hoverLineStyle: e.getModel("emphasis.lineStyle").getLineStyle(),
			labelModel: e.getModel("label"),
			hoverLabelModel: e.getModel("emphasis.label")
		}
	}

	function Zc(t) {
		return isNaN(t[0]) || isNaN(t[1])
	}

	function Kc(t) {
		return !Zc(t[0]) && !Zc(t[1])
	}

	function $c(t, e) {
		return !!Qc(t)[e]
	}

	function Qc(t) {
		return t[vS] || (t[vS] = {})
	}

	function Jc(t) {
		this.pointerChecker, this._zr = t, this._opt = {};
		var e = y,
			i = e(td, this),
			r = e(ed, this),
			a = e(id, this),
			o = e(nd, this),
			l = e(rd, this);
		ng.call(this), this.setPointerChecker = function(t) {
			this.pointerChecker = t
		}, this.enable = function(e, u) {
			this.disable(), this._opt = s(n(u) || {}, {
				zoomOnMouseWheel: !0,
				moveOnMouseMove: !0,
				moveOnMouseWheel: !1,
				preventDefaultMouseMove: !0
			}), null == e && (e = !0), (e === !0 || "move" === e || "pan" === e) && (t.on("mousedown", i), t.on("mousemove", r), t.on("mouseup", a)), (e === !0 || "scale" === e || "zoom" === e) && (t.on("mousewheel", o), t.on("pinch", l))
		}, this.disable = function() {
			t.off("mousedown", i), t.off("mousemove", r), t.off("mouseup", a), t.off("mousewheel", o), t.off("pinch", l)
		}, this.dispose = this.disable, this.isDragging = function() {
			return this._dragging
		}, this.isPinching = function() {
			return this._pinching
		}
	}

	function td(t) {
		if (!(Ie(t) || t.target && t.target.draggable)) {
			var e = t.offsetX,
				i = t.offsetY;
			this.pointerChecker && this.pointerChecker(t, e, i) && (this._x = e, this._y = i, this._dragging = !0)
		}
	}

	function ed(t) {
		if (this._dragging && sd("moveOnMouseMove", t, this._opt) && "pinch" !== t.gestureEvent && !$c(this._zr, "globalPan")) {
			var e = t.offsetX,
				i = t.offsetY,
				n = this._x,
				r = this._y,
				a = e - n,
				o = i - r;
			this._x = e, this._y = i, this._opt.preventDefaultMouseMove && hg(t.event), od(this, "pan", "moveOnMouseMove", t, {
				dx: a,
				dy: o,
				oldX: n,
				oldY: r,
				newX: e,
				newY: i
			})
		}
	}

	function id(t) {
		Ie(t) || (this._dragging = !1)
	}

	function nd(t) {
		var e = sd("zoomOnMouseWheel", t, this._opt),
			i = sd("moveOnMouseWheel", t, this._opt),
			n = t.wheelDelta,
			r = Math.abs(n),
			a = t.offsetX,
			o = t.offsetY;
		if (0 !== n && (e || i)) {
			if (e) {
				var s = r > 3 ? 1.4 : r > 1 ? 1.2 : 1.1,
					l = n > 0 ? s : 1 / s;
				ad(this, "zoom", "zoomOnMouseWheel", t, {
					scale: l,
					originX: a,
					originY: o
				})
			}
			if (i) {
				var u = Math.abs(n),
					h = (n > 0 ? 1 : -1) * (u > 3 ? .4 : u > 1 ? .15 : .05);
				ad(this, "scrollMove", "moveOnMouseWheel", t, {
					scrollDelta: h,
					originX: a,
					originY: o
				})
			}
		}
	}

	function rd(t) {
		if (!$c(this._zr, "globalPan")) {
			var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
			ad(this, "zoom", null, t, {
				scale: e,
				originX: t.pinchX,
				originY: t.pinchY
			})
		}
	}

	function ad(t, e, i, n, r) {
		t.pointerChecker && t.pointerChecker(n, r.originX, r.originY) && (hg(n.event), od(t, e, i, n, r))
	}

	function od(t, e, i, n, r) {
		r.isAvailableBehavior = y(sd, null, i, n), t.trigger(e, r)
	}

	function sd(t, e, i) {
		var n = i[t];
		return !t || n && (!b(n) || e.event[n + "Key"])
	}

	function ld(t, e, i) {
		var n = t.target,
			r = n.position;
		r[0] += e, r[1] += i, n.dirty()
	}

	function ud(t, e, i, n) {
		var r = t.target,
			a = t.zoomLimit,
			o = r.position,
			s = r.scale,
			l = t.zoom = t.zoom || 1;
		if (l *= e, a) {
			var u = a.min || 0,
				h = a.max || 1 / 0;
			l = Math.max(Math.min(h, l), u)
		}
		var c = l / t.zoom;
		t.zoom = l, o[0] -= (i - o[0]) * (c - 1), o[1] -= (n - o[1]) * (c - 1), s[0] *= c, s[1] *= c, r.dirty()
	}

	function hd(t, e, i) {
		var n = e.getComponentByElement(t.topTarget),
			r = n && n.coordinateSystem;
		return n && n !== i && !mS[n.mainType] && r && r.model !== i
	}

	function cd(t) {
		var e = t.coordinateSystem;
		if ("view" !== e.type) return 1;
		var i = t.option.nodeScaleRatio,
			n = e.scale,
			r = n && n[0] || 1,
			a = e.getZoom(),
			o = (a - 1) * i + 1;
		return o / r
	}

	function dd(t) {
		var e = t.getVisual("symbolSize");
		return e instanceof Array && (e = (e[0] + e[1]) / 2), +e
	}

	function fd(t, e, i) {
		for (var n, r = t[0], a = t[1], o = t[2], s = 1 / 0, l = i * i, u = .1, h = .1; .9 >= h; h += .1) {
			yS[0] = wS(r[0], a[0], o[0], h), yS[1] = wS(r[1], a[1], o[1], h);
			var c = SS(bS(yS, e) - l);
			s > c && (s = c, n = h)
		}
		for (var d = 0; 32 > d; d++) {
			var f = n + u;
			_S[0] = wS(r[0], a[0], o[0], n), _S[1] = wS(r[1], a[1], o[1], n), xS[0] = wS(r[0], a[0], o[0], f), xS[1] = wS(r[1], a[1], o[1], f);
			var c = bS(_S, e) - l;
			if (SS(c) < .01) break;
			var p = bS(xS, e) - l;
			u /= 2, 0 > c ? p >= 0 ? n += u : n -= u : p >= 0 ? n -= u : n += u
		}
		return n
	}

	function pd(t, e) {
		var i = t.getVisual("opacity");
		return null != i ? i : t.getModel().get(e)
	}

	function gd(t, e, i) {
		var n = t.getGraphicEl(),
			r = pd(t, e);
		null != i && (null == r && (r = 1), r *= i), n.downplay && n.downplay(), n.traverse(function(t) {
			if (!t.isGroup) {
				var e = t.lineLabelOriginalOpacity;
				(null == e || null != i) && (e = r), t.setStyle("opacity", e)
			}
		})
	}

	function vd(t, e) {
		var i = pd(t, e),
			n = t.getGraphicEl();
		n.traverse(function(t) {
			!t.isGroup && t.setStyle("opacity", i)
		}), n.highlight && n.highlight()
	}

	function md(t, e, i) {
		var n = t.getZoom(),
			r = t.getCenter(),
			a = e.zoom,
			o = t.dataToPoint(r);
		if (null != e.dx && null != e.dy) {
			o[0] -= e.dx, o[1] -= e.dy;
			var r = t.pointToData(o);
			t.setCenter(r)
		}
		if (null != a) {
			if (i) {
				var s = i.min || 0,
					l = i.max || 1 / 0;
				a = Math.max(Math.min(n * a, l), s) / n
			}
			t.scale[0] *= a, t.scale[1] *= a;
			var u = t.position,
				h = (e.originX - u[0]) * (a - 1),
				c = (e.originY - u[1]) * (a - 1);
			u[0] -= h, u[1] -= c, t.updateTransform();
			var r = t.pointToData(o);
			t.setCenter(r), t.setZoom(a * n)
		}
		return {
			center: t.getCenter(),
			zoom: t.getZoom()
		}
	}

	function yd(t) {
		return t instanceof Array || (t = [t, t]), t
	}

	function _d(t) {
		var e = t.coordinateSystem;
		if (!e || "view" === e.type) {
			var i = t.getGraph();
			i.eachNode(function(t) {
				var e = t.getModel();
				t.setLayout([+e.get("x"), +e.get("y")])
			}), xd(i, t)
		}
	}

	function xd(t, e) {
		t.eachEdge(function(t, i) {
			var n = A(t.getModel().get("lineStyle.curveness"), -Cc(t, e, i, !0), 0),
				r = G(t.node1.getLayout()),
				a = G(t.node2.getLayout()),
				o = [r, a]; + n && o.push([(r[0] + a[0]) / 2 - (r[1] - a[1]) * n, (r[1] + a[1]) / 2 - (a[0] - r[0]) * n]), t.setLayout(o)
		})
	}

	function wd(t, e) {
		var i = t.coordinateSystem;
		if (!i || "view" === i.type) {
			var n = i.getBoundingRect(),
				r = t.getData(),
				a = r.graph,
				o = n.width / 2 + n.x,
				s = n.height / 2 + n.y,
				l = Math.min(n.width, n.height) / 2,
				u = r.count();
			r.setLayout({
				cx: o,
				cy: s
			}), u && (RS[e](t, i, a, r, l, o, s, u), a.eachEdge(function(e, i) {
				var n, r = A(e.getModel().get("lineStyle.curveness"), Cc(e, t, i), 0),
					a = G(e.node1.getLayout()),
					l = G(e.node2.getLayout()),
					u = (a[0] + l[0]) / 2,
					h = (a[1] + l[1]) / 2; + r && (r *= 3, n = [o * r + u * (1 - r), s * r + h * (1 - r)]), e.setLayout([a, l, n])
			}))
		}
	}

	function bd(t, e, i) {
		for (var n = i.rect, r = n.width, a = n.height, o = [n.x + r / 2, n.y + a / 2], s = null == i.gravity ? .1 : i.gravity, l = 0; l < t.length; l++) {
			var u = t[l];
			u.p || (u.p = H(r * (Math.random() - .5) + o[0], a * (Math.random() - .5) + o[1])), u.pp = G(u.p), u.edges = null
		}
		var h = null == i.friction ? .6 : i.friction,
			c = h;
		return {
			warmUp: function() {
				c = .8 * h
			},
			setFixed: function(e) {
				t[e].fixed = !0
			},
			setUnfixed: function(e) {
				t[e].fixed = !1
			},
			step: function(i) {
				for (var n = [], r = t.length, a = 0; a < e.length; a++) {
					var l = e[a];
					if (!l.ignoreForceLayout) {
						var u = l.n1,
							h = l.n2;
						Y(n, h.p, u.p);
						var d = q(n) - l.d,
							f = h.w / (u.w + h.w);
						isNaN(f) && (f = 0), te(n, n), !u.fixed && FS(u.p, u.p, n, f * d * c), !h.fixed && FS(h.p, h.p, n, -(1 - f) * d * c)
					}
				}
				for (var a = 0; r > a; a++) {
					var p = t[a];
					p.fixed || (Y(n, o, p.p), FS(p.p, p.p, n, s * c))
				}
				for (var a = 0; r > a; a++)
					for (var u = t[a], g = a + 1; r > g; g++) {
						var h = t[g];
						Y(n, h.p, u.p);
						var d = q(n);
						0 === d && (U(n, Math.random() - .5, Math.random() - .5), d = 1);
						var v = (u.rep + h.rep) / d / d;
						!u.fixed && FS(u.pp, u.pp, n, v), !h.fixed && FS(h.pp, h.pp, n, -v)
					}
				for (var m = [], a = 0; r > a; a++) {
					var p = t[a];
					p.fixed || (Y(m, p.p, p.pp), FS(p.p, p.p, m, c), W(p.pp, p.p))
				}
				c = .992 * c, i && i(t, e, .01 > c)
			}
		}
	}

	function Sd() {
		xg.call(this)
	}

	function Md(t) {
		this.name = t, this.zoomLimit, xg.call(this), this._roamTransformable = new Sd, this._rawTransformable = new Sd, this._center, this._zoom
	}

	function Id(t, e, i, n) {
		var r = i.seriesModel,
			a = r ? r.coordinateSystem : null;
		return a === this ? a[t](n) : null
	}

	function Td(t, e, i) {
		var n = t.getBoxLayoutParams();
		return n.aspect = i, Qo(n, {
			width: e.getWidth(),
			height: e.getHeight()
		})
	}

	function Cd(t, e, i) {
		var n, r = {},
			a = "toggleSelected" === t;
		return i.eachComponent("legend", function(i) {
			a && null != n ? i[n ? "select" : "unSelect"](e.name) : "allSelect" === t || "inverseSelect" === t ? i[t]() : (i[t](e.name), n = i.isSelected(e.name));
			var o = i.getData();
			f(o, function(t) {
				var e = t.get("name");
				if ("\n" !== e && "" !== e) {
					var n = i.isSelected(e);
					r[e] = r.hasOwnProperty(e) ? r[e] && n : n
				}
			})
		}), "allSelect" === t || "inverseSelect" === t ? {
			selected: r
		} : {
			name: e.name,
			selected: r
		}
	}

	function Dd(t, e) {
		var i = a_(e.get("padding")),
			n = e.getItemStyle(["color", "opacity"]);
		n.fill = e.get("backgroundColor");
		var t = new by({
			shape: {
				x: t.x - i[3],
				y: t.y - i[0],
				width: t.width + i[1] + i[3],
				height: t.height + i[0] + i[2],
				r: e.get("borderRadius")
			},
			style: n,
			silent: !0,
			z2: -1
		});
		return t
	}

	function kd(t, e, i, n, r, a) {
		var o;
		return "line" !== e && e.indexOf("empty") < 0 ? (o = i.getItemStyle(), t.style.stroke = n, a || (o.stroke = r)) : o = i.getItemStyle(["borderWidth", "borderColor"]), t.setStyle(o)
	}

	function Ad(t, e, i, n) {
		Ld(t, e, i, n), i.dispatchAction({
			type: "legendToggleSelect",
			name: null != t ? t : e
		}), Pd(t, e, i, n)
	}

	function Pd(t, e, i, n) {
		var r = i.getZr().storage.getDisplayList()[0];
		r && r.useHoverLayer || i.dispatchAction({
			type: "highlight",
			seriesName: t,
			name: e,
			excludeSeriesId: n
		})
	}

	function Ld(t, e, i, n) {
		var r = i.getZr().storage.getDisplayList()[0];
		r && r.useHoverLayer || i.dispatchAction({
			type: "downplay",
			seriesName: t,
			name: e,
			excludeSeriesId: n
		})
	}

	function Od(t, e, i) {
		var n = t.getOrient(),
			r = [1, 1];
		r[n.index] = 0, Jo(e, i, {
			type: "box",
			ignoreSize: r
		})
	}

	function Ed(t, e) {
		var i = {
			axesInfo: {},
			seriesInvolved: !1,
			coordSysAxesInfo: {},
			coordSysMap: {}
		};
		return zd(i, t, e), i.seriesInvolved && Rd(i, t), i
	}

	function zd(t, e, i) {
		var n = e.getComponent("tooltip"),
			r = e.getComponent("axisPointer"),
			a = r.get("link", !0) || [],
			o = [];
		iM(i.getCoordinateSystems(), function(i) {
			function s(n, s, l) {
				var h = l.model.getModel("axisPointer", r),
					d = h.get("show");
				if (d && ("auto" !== d || n || Gd(h))) {
					null == s && (s = h.get("triggerTooltip")), h = n ? Bd(l, c, r, e, n, s) : h;
					var f = h.get("snap"),
						p = Ud(l.model),
						g = s || f || "category" === l.type,
						v = t.axesInfo[p] = {
							key: p,
							axis: l,
							coordSys: i,
							axisPointerModel: h,
							triggerTooltip: s,
							involveSeries: g,
							snap: f,
							useHandle: Gd(h),
							seriesModels: []
						};
					u[p] = v, t.seriesInvolved |= g;
					var m = Nd(a, l);
					if (null != m) {
						var y = o[m] || (o[m] = {
							axesInfo: {}
						});
						y.axesInfo[p] = v, y.mapper = a[m].mapper, v.linkGroup = y
					}
				}
			}
			if (i.axisPointerEnabled) {
				var l = Ud(i.model),
					u = t.coordSysAxesInfo[l] = {};
				t.coordSysMap[l] = i;
				var h = i.model,
					c = h.getModel("tooltip", n);
				if (iM(i.getAxes(), nM(s, !1, null)), i.getTooltipAxes && n && c.get("show")) {
					var d = "axis" === c.get("trigger"),
						f = "cross" === c.get("axisPointer.type"),
						p = i.getTooltipAxes(c.get("axisPointer.axis"));
					(d || f) && iM(p.baseAxes, nM(s, f ? "cross" : !0, d)), f && iM(p.otherAxes, nM(s, "cross", !1))
				}
			}
		})
	}

	function Bd(t, e, i, r, a, o) {
		var l = e.getModel("axisPointer"),
			u = {};
		iM(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function(t) {
			u[t] = n(l.get(t))
		}), u.snap = "category" !== t.type && !!o, "cross" === l.get("type") && (u.type = "line");
		var h = u.label || (u.label = {});
		if (null == h.show && (h.show = !1), "cross" === a) {
			var c = l.get("label.show");
			if (h.show = null != c ? c : !0, !o) {
				var d = u.lineStyle = l.get("crossStyle");
				d && s(h, d.textStyle)
			}
		}
		return t.model.getModel("axisPointer", new go(u, i, r))
	}

	function Rd(t, e) {
		e.eachSeries(function(e) {
			var i = e.coordinateSystem,
				n = e.get("tooltip.trigger", !0),
				r = e.get("tooltip.show", !0);
			i && "none" !== n && n !== !1 && "item" !== n && r !== !1 && e.get("axisPointer.show", !0) !== !1 && iM(t.coordSysAxesInfo[Ud(i.model)], function(t) {
				var n = t.axis;
				i.getAxis(n.dim) === n && (t.seriesModels.push(e), null == t.seriesDataCount && (t.seriesDataCount = 0), t.seriesDataCount += e.getData().count())
			})
		}, this)
	}

	function Nd(t, e) {
		for (var i = e.model, n = e.dim, r = 0; r < t.length; r++) {
			var a = t[r] || {};
			if (Fd(a[n + "AxisId"], i.id) || Fd(a[n + "AxisIndex"], i.componentIndex) || Fd(a[n + "AxisName"], i.name)) return r
		}
	}

	function Fd(t, e) {
		return "all" === t || x(t) && u(t, e) >= 0 || t === e
	}

	function Vd(t) {
		var e = Hd(t);
		if (e) {
			var i = e.axisPointerModel,
				n = e.axis.scale,
				r = i.option,
				a = i.get("status"),
				o = i.get("value");
			null != o && (o = n.parse(o));
			var s = Gd(i);
			null == a && (r.status = s ? "show" : "hide");
			var l = n.getExtent().slice();
			l[0] > l[1] && l.reverse(), (null == o || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), r.value = o, s && (r.status = e.axis.scale.isBlank() ? "hide" : "show")
		}
	}

	function Hd(t) {
		var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
		return e && e.axesInfo[Ud(t)]
	}

	function Wd(t) {
		var e = Hd(t);
		return e && e.axisPointerModel
	}

	function Gd(t) {
		return !!t.get("handle.show")
	}

	function Ud(t) {
		return t.type + "||" + t.id
	}

	function Xd(t, e, i, n, r) {
		var a = t.axis;
		if (!a.scale.isBlank() && a.containData(e)) {
			if (!t.involveSeries) return void i.showPointer(t, e);
			var s = jd(e, t),
				l = s.payloadBatch,
				u = s.snapToValue;
			l[0] && null == r.seriesIndex && o(r, l[0]), !n && t.snap && a.containData(u) && null != u && (e = u), i.showPointer(t, e, l, r), i.showTooltip(t, s, u)
		}
	}

	function jd(t, e) {
		var i = e.axis,
			n = i.dim,
			r = t,
			a = [],
			o = Number.MAX_VALUE,
			s = -1;
		return aM(e.seriesModels, function(e) {
			var l, u, h = e.getData().mapDimension(n, !0);
			if (e.getAxisTooltipData) {
				var c = e.getAxisTooltipData(h, t, i);
				u = c.dataIndices, l = c.nestestValue
			} else {
				if (u = e.getData().indicesOfNearest(h[0], t, "category" === i.type ? .5 : null), !u.length) return;
				l = e.getData().get(h[0], u[0])
			}
			if (null != l && isFinite(l)) {
				var d = t - l,
					f = Math.abs(d);
				o >= f && ((o > f || d >= 0 && 0 > s) && (o = f, s = d, r = l, a.length = 0), aM(u, function(t) {
					a.push({
						seriesIndex: e.seriesIndex,
						dataIndexInside: t,
						dataIndex: e.getData().getRawIndex(t)
					})
				}))
			}
		}), {
			payloadBatch: a,
			snapToValue: r
		}
	}

	function Yd(t, e, i, n) {
		t[e.key] = {
			value: i,
			payloadBatch: n
		}
	}

	function qd(t, e, i, n) {
		var r = i.payloadBatch,
			a = e.axis,
			o = a.model,
			s = e.axisPointerModel;
		if (e.triggerTooltip && r.length) {
			var l = e.coordSys.model,
				u = Ud(l),
				h = t.map[u];
			h || (h = t.map[u] = {
				coordSysId: l.id,
				coordSysIndex: l.componentIndex,
				coordSysType: l.type,
				coordSysMainType: l.mainType,
				dataByAxis: []
			}, t.list.push(h)), h.dataByAxis.push({
				axisDim: a.dim,
				axisIndex: o.componentIndex,
				axisType: o.type,
				axisId: o.id,
				value: n,
				valueLabelOpt: {
					precision: s.get("label.precision"),
					formatter: s.get("label.formatter")
				},
				seriesDataIndices: r.slice()
			})
		}
	}

	function Zd(t, e, i) {
		var n = i.axesInfo = [];
		aM(e, function(e, i) {
			var r = e.axisPointerModel.option,
				a = t[i];
			a ? (!e.useHandle && (r.status = "show"), r.value = a.value, r.seriesDataIndices = (a.payloadBatch || []).slice()) : !e.useHandle && (r.status = "hide"), "show" === r.status && n.push({
				axisDim: e.axis.dim,
				axisIndex: e.axis.model.componentIndex,
				value: r.value
			})
		})
	}

	function Kd(t, e, i, n) {
		if (tf(e) || !t.list.length) return void n({
			type: "hideTip"
		});
		var r = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
		n({
			type: "showTip",
			escapeConnect: !0,
			x: e[0],
			y: e[1],
			tooltipOption: i.tooltipOption,
			position: i.position,
			dataIndexInside: r.dataIndexInside,
			dataIndex: r.dataIndex,
			seriesIndex: r.seriesIndex,
			dataByCoordSys: t.list
		})
	}

	function $d(t, e, i) {
		var n = i.getZr(),
			r = "axisPointerLastHighlights",
			a = sM(n)[r] || {},
			o = sM(n)[r] = {};
		aM(t, function(t) {
			var e = t.axisPointerModel.option;
			"show" === e.status && aM(e.seriesDataIndices, function(t) {
				var e = t.seriesIndex + " | " + t.dataIndex;
				o[e] = t
			})
		});
		var s = [],
			l = [];
		f(a, function(t, e) {
			!o[e] && l.push(t)
		}), f(o, function(t, e) {
			!a[e] && s.push(t)
		}), l.length && i.dispatchAction({
			type: "downplay",
			escapeConnect: !0,
			batch: l
		}), s.length && i.dispatchAction({
			type: "highlight",
			escapeConnect: !0,
			batch: s
		})
	}

	function Qd(t, e) {
		for (var i = 0; i < (t || []).length; i++) {
			var n = t[i];
			if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n
		}
	}

	function Jd(t) {
		var e = t.axis.model,
			i = {},
			n = i.axisDim = t.axis.dim;
		return i.axisIndex = i[n + "AxisIndex"] = e.componentIndex, i.axisName = i[n + "AxisName"] = e.name, i.axisId = i[n + "AxisId"] = e.id, i
	}

	function tf(t) {
		return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1])
	}

	function ef(t, e, i) {
		if (!zp.node) {
			var n = e.getZr();
			uM(n).records || (uM(n).records = {}), nf(n, e);
			var r = uM(n).records[t] || (uM(n).records[t] = {});
			r.handler = i
		}
	}

	function nf(t, e) {
		function i(i, n) {
			t.on(i, function(i) {
				var r = sf(e);
				hM(uM(t).records, function(t) {
					t && n(t, i, r.dispatchAction)
				}), rf(r.pendings, e)
			})
		}
		uM(t).initialized || (uM(t).initialized = !0, i("click", _(of, "click")), i("mousemove", _(of, "mousemove")), i("globalout", af))
	}

	function rf(t, e) {
		var i, n = t.showTip.length,
			r = t.hideTip.length;
		n ? i = t.showTip[n - 1] : r && (i = t.hideTip[r - 1]), i && (i.dispatchAction = null, e.dispatchAction(i))
	}

	function af(t, e, i) {
		t.handler("leave", null, i)
	}

	function of(t, e, i, n) {
		e.handler(t, i, n)
	}

	function sf(t) {
		var e = {
				showTip: [],
				hideTip: []
			},
			i = function(n) {
				var r = e[n.type];
				r ? r.push(n) : (n.dispatchAction = i, t.dispatchAction(n))
			};
		return {
			dispatchAction: i,
			pendings: e
		}
	}

	function lf(t, e) {
		if (!zp.node) {
			var i = e.getZr(),
				n = (uM(i).records || {})[t];
			n && (uM(i).records[t] = null)
		}
	}

	function uf() {}

	function hf(t, e, i, n) {
		cf(dM(i).lastProp, n) || (dM(i).lastProp = n, e ? eo(i, n, t) : (i.stopAnimation(), i.attr(n)))
	}

	function cf(t, e) {
		if (S(t) && S(e)) {
			var i = !0;
			return f(e, function(e, n) {
				i = i && cf(t[n], e)
			}), !!i
		}
		return t === e
	}

	function df(t, e) {
		t[e.get("label.show") ? "show" : "hide"]()
	}

	function ff(t) {
		return {
			position: t.position.slice(),
			rotation: t.rotation || 0
		}
	}

	function pf(t, e, i) {
		var n = e.get("z"),
			r = e.get("zlevel");
		t && t.traverse(function(t) {
			"group" !== t.type && (null != n && (t.z = n), null != r && (t.zlevel = r), t.silent = i)
		})
	}

	function gf(t, e, i, n) {
		var r, a, o = Ao(i - t.rotation),
			s = n[0] > n[1],
			l = "start" === e && !s || "start" !== e && s;
		return Po(o - gM / 2) ? (a = l ? "bottom" : "top", r = "center") : Po(o - 1.5 * gM) ? (a = l ? "top" : "bottom", r = "center") : (a = "middle", r = 1.5 * gM > o && o > gM / 2 ? l ? "left" : "right" : l ? "right" : "left"), {
			rotation: o,
			textAlign: r,
			textVerticalAlign: a
		}
	}

	function vf(t, e, i) {
		if (!Vh(t.axis)) {
			var n = t.get("axisLabel.showMinLabel"),
				r = t.get("axisLabel.showMaxLabel");
			e = e || [], i = i || [];
			var a = e[0],
				o = e[1],
				s = e[e.length - 1],
				l = e[e.length - 2],
				u = i[0],
				h = i[1],
				c = i[i.length - 1],
				d = i[i.length - 2];
			n === !1 ? (mf(a), mf(u)) : yf(a, o) && (n ? (mf(o), mf(h)) : (mf(a), mf(u))), r === !1 ? (mf(s), mf(c)) : yf(l, s) && (r ? (mf(l), mf(d)) : (mf(s), mf(c)))
		}
	}

	function mf(t) {
		t && (t.ignore = !0)
	}

	function yf(t, e) {
		var i = t && t.getBoundingRect().clone(),
			n = e && e.getBoundingRect().clone();
		if (i && n) {
			var r = Ee([]);
			return Ne(r, r, -t.rotation), i.applyTransform(Be([], r, t.getLocalTransform())), n.applyTransform(Be([], r, e.getLocalTransform())), i.intersect(n)
		}
	}

	function _f(t) {
		return "middle" === t || "center" === t
	}

	function xf(t, e, i, n, r) {
		for (var a = [], o = [], s = [], l = 0; l < t.length; l++) {
			var u = t[l].coord;
			o[0] = u, o[1] = 0, s[0] = u, s[1] = i, e && (ae(o, o, e), ae(s, s, e));
			var h = new My({
				anid: r + "_" + t[l].tickValue,
				subPixelOptimize: !0,
				shape: {
					x1: o[0],
					y1: o[1],
					x2: s[0],
					y2: s[1]
				},
				style: n,
				z2: 2,
				silent: !0
			});
			a.push(h)
		}
		return a
	}

	function wf(t, e, i) {
		var n = e.axis,
			r = e.getModel("axisTick");
		if (r.get("show") && !n.scale.isBlank()) {
			for (var a = r.getModel("lineStyle"), o = i.tickDirection * r.get("length"), l = n.getTicksCoords(), u = xf(l, t._transform, o, s(a.getLineStyle(), {
					stroke: e.get("axisLine.lineStyle.color")
				}), "ticks"), h = 0; h < u.length; h++) t.group.add(u[h]);
			return u
		}
	}

	function bf(t, e, i) {
		var n = e.axis,
			r = e.getModel("minorTick");
		if (r.get("show") && !n.scale.isBlank()) {
			var a = n.getMinorTicksCoords();
			if (a.length)
				for (var o = r.getModel("lineStyle"), l = i.tickDirection * r.get("length"), u = s(o.getLineStyle(), s(e.getModel("axisTick").getLineStyle(), {
						stroke: e.get("axisLine.lineStyle.color")
					})), h = 0; h < a.length; h++)
					for (var c = xf(a[h], t._transform, l, u, "minorticks_" + h), d = 0; d < c.length; d++) t.group.add(c[d])
		}
	}

	function Sf(t, e, i) {
		var n = e.axis,
			r = D(i.axisLabelShow, e.get("axisLabel.show"));
		if (r && !n.scale.isBlank()) {
			var a = e.getModel("axisLabel"),
				o = a.get("margin"),
				s = n.getViewLabels(),
				l = (D(i.labelRotate, a.get("rotate")) || 0) * gM / 180,
				u = _M(i.rotation, l, i.labelDirection),
				h = e.getCategories && e.getCategories(!0),
				c = [],
				d = xM(e),
				p = e.get("triggerEvent");
			return f(s, function(r, s) {
				var l = r.tickValue,
					f = r.formattedLabel,
					g = r.rawLabel,
					v = a;
				h && h[l] && h[l].textStyle && (v = new go(h[l].textStyle, a, e.ecModel));
				var m = v.getTextColor() || e.get("axisLine.lineStyle.color"),
					y = n.dataToCoord(l),
					_ = [y, i.labelOffset + i.labelDirection * o],
					x = new hy({
						anid: "label_" + l,
						position: _,
						rotation: u.rotation,
						silent: d,
						z2: 10
					});
				Xa(x.style, v, {
					text: f,
					textAlign: v.getShallow("align", !0) || u.textAlign,
					textVerticalAlign: v.getShallow("verticalAlign", !0) || v.getShallow("baseline", !0) || u.textVerticalAlign,
					textFill: "function" == typeof m ? m("category" === n.type ? g : "value" === n.type ? l + "" : l, s) : m
				}), p && (x.eventData = yM(e), x.eventData.targetType = "axisLabel", x.eventData.value = g), t._dumbGroup.add(x), x.updateTransform(), c.push(x), t.group.add(x), x.decomposeTransform()
			}), c
		}
	}

	function Mf(t) {
		var e, i = t.get("type"),
			n = t.getModel(i + "Style");
		return "line" === i ? (e = n.getLineStyle(), e.fill = null) : "shadow" === i && (e = n.getAreaStyle(), e.stroke = null), e
	}

	function If(t, e, i, n, r) {
		var a = i.get("value"),
			o = Cf(a, e.axis, e.ecModel, i.get("seriesDataIndices"), {
				precision: i.get("label.precision"),
				formatter: i.get("label.formatter")
			}),
			s = i.getModel("label"),
			l = a_(s.get("padding") || 0),
			u = s.getFont(),
			h = ji(o, u),
			c = r.position,
			d = h.width + l[1] + l[3],
			f = h.height + l[0] + l[2],
			p = r.align;
		"right" === p && (c[0] -= d), "center" === p && (c[0] -= d / 2);
		var g = r.verticalAlign;
		"bottom" === g && (c[1] -= f), "middle" === g && (c[1] -= f / 2), Tf(c, d, f, n);
		var v = s.get("backgroundColor");
		v && "auto" !== v || (v = e.get("axisLine.lineStyle.color")), t.label = {
			shape: {
				x: 0,
				y: 0,
				width: d,
				height: f,
				r: s.get("borderRadius")
			},
			position: c.slice(),
			style: {
				text: o,
				textFont: u,
				textFill: s.getTextColor(),
				textPosition: "inside",
				textPadding: l,
				fill: v,
				stroke: s.get("borderColor") || "transparent",
				lineWidth: s.get("borderWidth") || 0,
				shadowBlur: s.get("shadowBlur"),
				shadowColor: s.get("shadowColor"),
				shadowOffsetX: s.get("shadowOffsetX"),
				shadowOffsetY: s.get("shadowOffsetY")
			},
			z2: 10
		}
	}

	function Tf(t, e, i, n) {
		var r = n.getWidth(),
			a = n.getHeight();
		t[0] = Math.min(t[0] + e, r) - e, t[1] = Math.min(t[1] + i, a) - i, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0)
	}

	function Cf(t, e, i, n, r) {
		t = e.scale.parse(t);
		var a = e.scale.getLabel(t, {
				precision: r.precision
			}),
			o = r.formatter;
		if (o) {
			var s = {
				value: Nh(e, t),
				axisDimension: e.dim,
				axisIndex: e.index,
				seriesData: []
			};
			f(n, function(t) {
				var e = i.getSeriesByIndex(t.seriesIndex),
					n = t.dataIndexInside,
					r = e && e.getDataParams(n);
				r && s.seriesData.push(r)
			}), b(o) ? a = o.replace("{value}", a) : w(o) && (a = o(s))
		}
		return a
	}

	function Df(t, e, i) {
		var n = Oe();
		return Ne(n, n, i.rotation), Re(n, n, i.position), ro([t.dataToCoord(e), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n)
	}

	function kf(t, e, i, n, r, a) {
		var o = vM.innerTextLayout(i.rotation, 0, i.labelDirection);
		i.labelMargin = r.get("label.margin"), If(e, n, r, a, {
			position: Df(n.axis, t, i),
			align: o.textAlign,
			verticalAlign: o.textVerticalAlign
		})
	}

	function Af(t, e, i) {
		return i = i || 0, {
			x1: t[i],
			y1: t[1 - i],
			x2: e[i],
			y2: e[1 - i]
		}
	}

	function Pf(t, e, i) {
		return i = i || 0, {
			x: t[i],
			y: t[1 - i],
			width: e[i],
			height: e[1 - i]
		}
	}

	function Lf(t, e, i) {
		i = i || {};
		var n = t.coordinateSystem,
			r = e.axis,
			a = {},
			o = r.getAxesOnZeroOf()[0],
			s = r.position,
			l = o ? "onZero" : s,
			u = r.dim,
			h = n.getRect(),
			c = [h.x, h.x + h.width, h.y, h.y + h.height],
			d = {
				left: 0,
				right: 1,
				top: 0,
				bottom: 1,
				onZero: 2
			},
			f = e.get("offset") || 0,
			p = "x" === u ? [c[2] - f, c[3] + f] : [c[0] - f, c[1] + f];
		if (o) {
			var g = o.toGlobalCoord(o.dataToCoord(0));
			p[d.onZero] = Math.max(Math.min(g, p[1]), p[0])
		}
		a.position = ["y" === u ? p[d[l]] : c[0], "x" === u ? p[d[l]] : c[3]], a.rotation = Math.PI / 2 * ("x" === u ? 0 : 1);
		var v = {
			top: -1,
			bottom: 1,
			left: -1,
			right: 1
		};
		a.labelDirection = a.tickDirection = a.nameDirection = v[s], a.labelOffset = o ? p[d[s]] - p[d.onZero] : 0, e.get("axisTick.inside") && (a.tickDirection = -a.tickDirection), D(i.labelInside, e.get("axisLabel.inside")) && (a.labelDirection = -a.labelDirection);
		var m = e.get("axisLabel.rotate");
		return a.labelRotate = "top" === l ? -m : m, a.z2 = 1, a
	}

	function Of(t, e, i, n, r, a) {
		var o = wM.getAxisPointerClass(t.axisPointerClass);
		if (o) {
			var s = Wd(e);
			s ? (t._axisPointer || (t._axisPointer = new o)).render(e, s, n, a) : Ef(t, n)
		}
	}

	function Ef(t, e, i) {
		var n = t._axisPointer;
		n && n.dispose(e, i), t._axisPointer = null
	}

	function zf(t, e) {
		var i = {};
		return i[e.dim + "AxisIndex"] = e.index, t.getCartesian(i)
	}

	function Bf(t) {
		return "x" === t.dim ? 0 : 1
	}

	function Rf(t) {
		var e = "cubic-bezier(0.23, 1, 0.32, 1)",
			i = "left " + t + "s " + e + ",top " + t + "s " + e;
		return p(CM, function(t) {
			return t + "transition:" + i
		}).join(";")
	}

	function Nf(t) {
		var e = [],
			i = t.get("fontSize"),
			n = t.getTextColor();
		n && e.push("color:" + n), e.push("font:" + t.getFont());
		var r = t.get("lineHeight");
		null == r && (r = Math.round(3 * i / 2)), i && e.push("line-height:" + r + "px");
		var a = t.get("textShadowColor"),
			o = t.get("textShadowBlur") || 0,
			s = t.get("textShadowOffsetX") || 0,
			l = t.get("textShadowOffsetY") || 0;
		return o && e.push("text-shadow:" + s + "px " + l + "px " + o + "px " + a), IM(["decoration", "align"], function(i) {
			var n = t.get(i);
			n && e.push("text-" + i + ":" + n)
		}), e.join(";")
	}

	function Ff(t) {
		var e = [],
			i = t.get("transitionDuration"),
			n = t.get("backgroundColor"),
			r = t.getModel("textStyle"),
			a = t.get("padding");
		return i && e.push(Rf(i)), n && (zp.canvasSupported ? e.push("background-Color:" + n) : (e.push("background-Color:#" + ri(n)), e.push("filter:alpha(opacity=70)"))), IM(["width", "color", "radius"], function(i) {
			var n = "border-" + i,
				r = TM(n),
				a = t.get(r);
			null != a && e.push(n + ":" + a + ("color" === i ? "" : "px"))
		}), e.push(Nf(r)), null != a && e.push("padding:" + a_(a).join("px ") + "px"), e.join(";") + ";"
	}

	function Vf(t, e, i, n, r) {
		var a = e && e.painter;
		if (i) {
			var o = a && a.getViewportRoot();
			o && pe(t, o, document.body, n, r)
		} else {
			t[0] = n, t[1] = r;
			var s = a && a.getViewportRootOffset();
			s && (t[0] += s.offsetLeft, t[1] += s.offsetTop)
		}
		t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight()
	}

	function Hf(t, e, i) {
		if (zp.wxa) return null;
		var n = document.createElement("div");
		n.domBelongToZr = !0, this.el = n;
		var r = this._zr = e.getZr(),
			a = this._appendToBody = i && i.appendToBody;
		this._styleCoord = [0, 0, 0, 0], Vf(this._styleCoord, r, a, e.getWidth() / 2, e.getHeight() / 2), a ? document.body.appendChild(n) : t.appendChild(n), this._container = t, this._show = !1, this._hideTimeout;
		var o = this;
		n.onmouseenter = function() {
			o._enterable && (clearTimeout(o._hideTimeout), o._show = !0), o._inContent = !0
		}, n.onmousemove = function(t) {
			if (t = t || window.event, !o._enterable) {
				var e = r.handler,
					i = r.painter.getViewportRoot();
				be(i, t, !0), e.dispatch("mousemove", t)
			}
		}, n.onmouseleave = function() {
			o._enterable && o._show && o.hideLater(o._hideDelay), o._inContent = !1
		}
	}

	function Wf(t, e, i, n) {
		t[0] = i, t[1] = n, t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight()
	}

	function Gf(t) {
		var e = this._zr = t.getZr();
		this._styleCoord = [0, 0, 0, 0], Wf(this._styleCoord, e, t.getWidth() / 2, t.getHeight() / 2), this._show = !1, this._hideTimeout
	}

	function Uf(t) {
		for (var e = t.pop(); t.length;) {
			var i = t.pop();
			i && (go.isInstance(i) && (i = i.get("tooltip", !0)), "string" == typeof i && (i = {
				formatter: i
			}), e = new go(i, e, e.ecModel))
		}
		return e
	}

	function Xf(t, e) {
		return t.dispatchAction || y(e.dispatchAction, e)
	}

	function jf(t, e, i, n, r, a, o) {
		var s = i.getOuterSize(),
			l = s.width,
			u = s.height;
		return null != a && (t + l + a > n ? t -= l + a : t += a), null != o && (e + u + o > r ? e -= u + o : e += o), [t, e]
	}

	function Yf(t, e, i, n, r) {
		var a = i.getOuterSize(),
			o = a.width,
			s = a.height;
		return t = Math.min(t + o, n) - o, e = Math.min(e + s, r) - s, t = Math.max(t, 0), e = Math.max(e, 0), [t, e]
	}

	function qf(t, e, i) {
		var n = i[0],
			r = i[1],
			a = 5,
			o = 0,
			s = 0,
			l = e.width,
			u = e.height;
		switch (t) {
			case "inside":
				o = e.x + l / 2 - n / 2, s = e.y + u / 2 - r / 2;
				break;
			case "top":
				o = e.x + l / 2 - n / 2, s = e.y - r - a;
				break;
			case "bottom":
				o = e.x + l / 2 - n / 2, s = e.y + u + a;
				break;
			case "left":
				o = e.x - n - a, s = e.y + u / 2 - r / 2;
				break;
			case "right":
				o = e.x + l + a, s = e.y + u / 2 - r / 2
		}
		return [o, s]
	}

	function Zf(t) {
		return "center" === t || "middle" === t
	}

	function Kf(t) {
		return OM(t)
	}

	function $f() {
		if (!BM && RM) {
			BM = !0;
			var t = RM.styleSheets;
			t.length < 31 ? RM.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)")
		}
	}

	function Qf(t) {
		return parseInt(t, 10)
	}

	function Jf(t, e) {
		$f(), this.root = t, this.storage = e;
		var i = document.createElement("div"),
			n = document.createElement("div");
		i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this.resize();
		var r = e.delFromStorage,
			a = e.addToStorage;
		e.delFromStorage = function(t) {
			r.call(e, t), t && t.onRemove && t.onRemove(n)
		}, e.addToStorage = function(t) {
			t.onAdd && t.onAdd(n), a.call(e, t)
		}, this._firstPaint = !0
	}

	function tp(t) {
		return function() {
			Gg('In IE8.0 VML mode painter not support method "' + t + '"')
		}
	}

	function ep(t) {
		return document.createElementNS(CI, t)
	}

	function ip(t) {
		return PI(1e4 * t) / 1e4
	}

	function np(t) {
		return RI > t && t > -RI
	}

	function rp(t, e) {
		var i = e ? t.textFill : t.fill;
		return null != i && i !== AI
	}

	function ap(t, e) {
		var i = e ? t.textStroke : t.stroke;
		return null != i && i !== AI
	}

	function op(t, e) {
		e && sp(t, "transform", "matrix(" + kI.call(e, ",") + ")")
	}

	function sp(t, e, i) {
		(!i || "linear" !== i.type && "radial" !== i.type) && t.setAttribute(e, i)
	}

	function lp(t, e, i) {
		t.setAttributeNS("http://www.w3.org/1999/xlink", e, i)
	}

	function up(t, e, i, n) {
		if (rp(e, i)) {
			var r = i ? e.textFill : e.fill;
			r = "transparent" === r ? AI : r, sp(t, "fill", r), sp(t, "fill-opacity", null != e.fillOpacity ? e.fillOpacity * e.opacity : e.opacity)
		} else sp(t, "fill", AI);
		if (ap(e, i)) {
			var a = i ? e.textStroke : e.stroke;
			a = "transparent" === a ? AI : a, sp(t, "stroke", a);
			var o = i ? e.textStrokeWidth : e.lineWidth,
				s = !i && e.strokeNoScale ? n.getLineScale() : 1;
			sp(t, "stroke-width", o / s), sp(t, "paint-order", i ? "stroke" : "fill"), sp(t, "stroke-opacity", null != e.strokeOpacity ? e.strokeOpacity : e.opacity);
			var l = e.lineDash;
			l ? (sp(t, "stroke-dasharray", e.lineDash.join(",")), sp(t, "stroke-dashoffset", PI(e.lineDashOffset || 0))) : sp(t, "stroke-dasharray", ""), e.lineCap && sp(t, "stroke-linecap", e.lineCap), e.lineJoin && sp(t, "stroke-linejoin", e.lineJoin), e.miterLimit && sp(t, "stroke-miterlimit", e.miterLimit)
		} else sp(t, "stroke", AI)
	}

	function hp(t) {
		for (var e = [], i = t.data, n = t.len(), r = 0; n > r;) {
			var a = i[r++],
				o = "",
				s = 0;
			switch (a) {
				case DI.M:
					o = "M", s = 2;
					break;
				case DI.L:
					o = "L", s = 2;
					break;
				case DI.Q:
					o = "Q", s = 4;
					break;
				case DI.C:
					o = "C", s = 6;
					break;
				case DI.A:
					var l = i[r++],
						u = i[r++],
						h = i[r++],
						c = i[r++],
						d = i[r++],
						f = i[r++],
						p = i[r++],
						g = i[r++],
						v = Math.abs(f),
						m = np(v - zI) || (g ? f >= zI : -f >= zI),
						y = f > 0 ? f % zI : f % zI + zI,
						_ = !1;
					_ = m ? !0 : np(v) ? !1 : y >= EI == !!g;
					var x = ip(l + h * OI(d)),
						w = ip(u + c * LI(d));
					m && (f = g ? zI - 1e-4 : -zI + 1e-4, _ = !0, 9 === r && e.push("M", x, w));
					var b = ip(l + h * OI(d + f)),
						S = ip(u + c * LI(d + f));
					e.push("A", ip(h), ip(c), PI(p * BI), +_, +g, b, S);
					break;
				case DI.Z:
					o = "Z";
					break;
				case DI.R:
					var b = ip(i[r++]),
						S = ip(i[r++]),
						M = ip(i[r++]),
						I = ip(i[r++]);
					e.push("M", b, S, "L", b + M, S, "L", b + M, S + I, "L", b, S + I, "L", b, S)
			}
			o && e.push(o);
			for (var T = 0; s > T; T++) e.push(ip(i[r++]))
		}
		return e.join(" ")
	}

	function cp(t, e, i, n, r, a, o) {
		Ee(GI), e && i && ze(GI, i);
		var s = n.textRotation;
		if (r && s) {
			var l = n.textOrigin;
			"center" === l ? (a = r.width / 2 + r.x, o = r.height / 2 + r.y) : l && (a = l[0] + r.x, o = l[1] + r.y), GI[4] -= a, GI[5] -= o, Ne(GI, GI, s), GI[4] += a, GI[5] += o
		}
		op(t, GI)
	}

	function dp(t, e, i) {
		return "right" === e ? t - i[1] : "center" === e ? t + i[3] / 2 - i[1] / 2 : t + i[3]
	}

	function fp(t, e, i, n) {
		sp(t, "dominant-baseline", "middle"), sp(t, "text-anchor", UI[e]), sp(t, "x", i), sp(t, "y", n)
	}

	function pp(t) {
		t && t.__textSvgEl && (t.__textSvgEl.parentNode && t.__textSvgEl.parentNode.removeChild(t.__textSvgEl), t.__textSvgEl = null, t.__tspanList = [], t.__text = null)
	}

	function gp() {}

	function vp(t, e) {
		for (var i = 0, n = e.length, r = 0, a = 0; n > i; i++) {
			var o = e[i];
			if (o.removed) {
				for (var s = [], l = a; l < a + o.count; l++) s.push(l);
				o.indices = s, a += o.count
			} else {
				for (var s = [], l = r; l < r + o.count; l++) s.push(l);
				o.indices = s, r += o.count, o.added || (a += o.count)
			}
		}
		return e
	}

	function mp(t) {
		return {
			newPos: t.newPos,
			components: t.components.slice(0)
		}
	}

	function yp(t, e, i, n, r) {
		this._zrId = t, this._svgRoot = e, this._tagNames = "string" == typeof i ? [i] : i, this._markLabel = n, this._domName = r || "_dom", this.nextId = 0
	}

	function _p(t, e) {
		yp.call(this, t, e, ["linearGradient", "radialGradient"], "__gradient_in_use__")
	}

	function xp(t, e) {
		yp.call(this, t, e, "clipPath", "__clippath_in_use__")
	}

	function wp(t, e) {
		yp.call(this, t, e, ["filter"], "__filter_in_use__", "_shadowDom")
	}

	function bp(t) {
		return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY || t.textShadowBlur || t.textShadowOffsetX || t.textShadowOffsetY)
	}

	function Sp(t) {
		return parseInt(t, 10)
	}

	function Mp(t) {
		return t instanceof ia ? NI : t instanceof kn ? FI : t instanceof hy ? VI : NI
	}

	function Ip(t, e) {
		return e && t && e.parentNode !== t
	}

	function Tp(t, e, i) {
		if (Ip(t, e) && i) {
			var n = i.nextSibling;
			n ? t.insertBefore(e, n) : t.appendChild(e)
		}
	}

	function Cp(t, e) {
		if (Ip(t, e)) {
			var i = t.firstChild;
			i ? t.insertBefore(e, i) : t.appendChild(e)
		}
	}

	function Dp(t, e) {
		e && t && e.parentNode === t && t.removeChild(e)
	}

	function kp(t) {
		return t.__textSvgEl
	}

	function Ap(t) {
		return t.__svgEl
	}

	function Pp(t) {
		return function() {
			Gg('In SVG mode painter not support method "' + t + '"')
		}
	}
	var Lp = 2311,
		Op = function() {
			return Lp++
		},
		Ep = {};
	Ep = "object" == typeof wx && "function" == typeof wx.getSystemInfoSync ? {
		browser: {},
		os: {},
		node: !1,
		wxa: !0,
		canvasSupported: !0,
		svgSupported: !1,
		touchEventsSupported: !0,
		domSupported: !1
	} : "undefined" == typeof document && "undefined" != typeof self ? {
		browser: {},
		os: {},
		node: !1,
		worker: !0,
		canvasSupported: !0,
		domSupported: !1
	} : "undefined" == typeof navigator ? {
		browser: {},
		os: {},
		node: !0,
		worker: !1,
		canvasSupported: !0,
		svgSupported: !0,
		domSupported: !1
	} : e(navigator.userAgent);
	var zp = Ep,
		Bp = {
			"[object Function]": 1,
			"[object RegExp]": 1,
			"[object Date]": 1,
			"[object Error]": 1,
			"[object CanvasGradient]": 1,
			"[object CanvasPattern]": 1,
			"[object Image]": 1,
			"[object Canvas]": 1
		},
		Rp = {
			"[object Int8Array]": 1,
			"[object Uint8Array]": 1,
			"[object Uint8ClampedArray]": 1,
			"[object Int16Array]": 1,
			"[object Uint16Array]": 1,
			"[object Int32Array]": 1,
			"[object Uint32Array]": 1,
			"[object Float32Array]": 1,
			"[object Float64Array]": 1
		},
		Np = Object.prototype.toString,
		Fp = Array.prototype,
		Vp = Fp.forEach,
		Hp = Fp.filter,
		Wp = Fp.slice,
		Gp = Fp.map,
		Up = Fp.reduce,
		Xp = {},
		jp = function() {
			return Xp.createCanvas()
		};
	Xp.createCanvas = function() {
		return document.createElement("canvas")
	};
	var Yp, qp = "__ec_primitive__";
	R.prototype = {
		constructor: R,
		get: function(t) {
			return this.data.hasOwnProperty(t) ? this.data[t] : null
		},
		set: function(t, e) {
			return this.data[t] = e
		},
		each: function(t, e) {
			void 0 !== e && (t = y(t, e));
			for (var i in this.data) this.data.hasOwnProperty(i) && t(this.data[i], i)
		},
		removeKey: function(t) {
			delete this.data[t]
		}
	};
	var Zp = (Object.freeze || Object)({
			$override: i,
			clone: n,
			merge: r,
			mergeAll: a,
			extend: o,
			defaults: s,
			createCanvas: jp,
			getContext: l,
			indexOf: u,
			inherits: h,
			mixin: c,
			isArrayLike: d,
			each: f,
			map: p,
			reduce: g,
			filter: v,
			find: m,
			bind: y,
			curry: _,
			isArray: x,
			isFunction: w,
			isString: b,
			isObject: S,
			isBuiltInObject: M,
			isTypedArray: I,
			isDom: T,
			eqNaN: C,
			retrieve: D,
			retrieve2: k,
			retrieve3: A,
			slice: P,
			normalizeCssArray: L,
			assert: O,
			trim: E,
			setAsPrimitive: z,
			isPrimitive: B,
			createHashMap: N,
			concatArray: F,
			noop: V
		}),
		Kp = "undefined" == typeof Float32Array ? Array : Float32Array,
		$p = q,
		Qp = Z,
		Jp = ee,
		tg = ie,
		eg = (Object.freeze || Object)({
			create: H,
			copy: W,
			clone: G,
			set: U,
			add: X,
			scaleAndAdd: j,
			sub: Y,
			len: q,
			length: $p,
			lenSquare: Z,
			lengthSquare: Qp,
			mul: K,
			div: $,
			dot: Q,
			scale: J,
			normalize: te,
			distance: ee,
			dist: Jp,
			distanceSquare: ie,
			distSquare: tg,
			negate: ne,
			lerp: re,
			applyTransform: ae,
			min: oe,
			max: se
		});
	le.prototype = {
		constructor: le,
		_dragStart: function(t) {
			for (var e = t.target; e && !e.draggable;) e = e.parent;
			e && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(ue(e, t), "dragstart", t.event))
		},
		_drag: function(t) {
			var e = this._draggingTarget;
			if (e) {
				var i = t.offsetX,
					n = t.offsetY,
					r = i - this._x,
					a = n - this._y;
				this._x = i, this._y = n, e.drift(r, a, t), this.dispatchToElement(ue(e, t), "drag", t.event);
				var o = this.findHover(i, n, e).target,
					s = this._dropTarget;
				this._dropTarget = o, e !== o && (s && o !== s && this.dispatchToElement(ue(s, t), "dragleave", t.event), o && o !== s && this.dispatchToElement(ue(o, t), "dragenter", t.event))
			}
		},
		_dragEnd: function(t) {
			var e = this._draggingTarget;
			e && (e.dragging = !1), this.dispatchToElement(ue(e, t), "dragend", t.event), this._dropTarget && this.dispatchToElement(ue(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null
		}
	};
	var ig = Array.prototype.slice,
		ng = function(t) {
			this._$handlers = {}, this._$eventProcessor = t
		};
	ng.prototype = {
		constructor: ng,
		one: function(t, e, i, n) {
			return ce(this, t, e, i, n, !0)
		},
		on: function(t, e, i, n) {
			return ce(this, t, e, i, n, !1)
		},
		isSilent: function(t) {
			var e = this._$handlers;
			return !e[t] || !e[t].length
		},
		off: function(t, e) {
			var i = this._$handlers;
			if (!t) return this._$handlers = {}, this;
			if (e) {
				if (i[t]) {
					for (var n = [], r = 0, a = i[t].length; a > r; r++) i[t][r].h !== e && n.push(i[t][r]);
					i[t] = n
				}
				i[t] && 0 === i[t].length && delete i[t]
			} else delete i[t];
			return this
		},
		trigger: function(t) {
			var e = this._$handlers[t],
				i = this._$eventProcessor;
			if (e) {
				var n = arguments,
					r = n.length;
				r > 3 && (n = ig.call(n, 1));
				for (var a = e.length, o = 0; a > o;) {
					var s = e[o];
					if (i && i.filter && null != s.query && !i.filter(t, s.query)) o++;
					else {
						switch (r) {
							case 1:
								s.h.call(s.ctx);
								break;
							case 2:
								s.h.call(s.ctx, n[1]);
								break;
							case 3:
								s.h.call(s.ctx, n[1], n[2]);
								break;
							default:
								s.h.apply(s.ctx, n)
						}
						s.one ? (e.splice(o, 1), a--) : o++
					}
				}
			}
			return i && i.afterTrigger && i.afterTrigger(t), this
		},
		triggerWithContext: function(t) {
			var e = this._$handlers[t],
				i = this._$eventProcessor;
			if (e) {
				var n = arguments,
					r = n.length;
				r > 4 && (n = ig.call(n, 1, n.length - 1));
				for (var a = n[n.length - 1], o = e.length, s = 0; o > s;) {
					var l = e[s];
					if (i && i.filter && null != l.query && !i.filter(t, l.query)) s++;
					else {
						switch (r) {
							case 1:
								l.h.call(a);
								break;
							case 2:
								l.h.call(a, n[1]);
								break;
							case 3:
								l.h.call(a, n[1], n[2]);
								break;
							default:
								l.h.apply(a, n)
						}
						l.one ? (e.splice(s, 1), o--) : s++
					}
				}
			}
			return i && i.afterTrigger && i.afterTrigger(t), this
		}
	};
	var rg = Math.log(2),
		ag = "___zrEVENTSAVED",
		og = [],
		sg = "undefined" != typeof window && !!window.addEventListener,
		lg = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		ug = [],
		hg = sg ? function(t) {
			t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
		} : function(t) {
			t.returnValue = !1, t.cancelBubble = !0
		},
		cg = function() {
			this._track = []
		};
	cg.prototype = {
		constructor: cg,
		recognize: function(t, e, i) {
			return this._doTrack(t, e, i), this._recognize(t)
		},
		clear: function() {
			return this._track.length = 0, this
		},
		_doTrack: function(t, e, i) {
			var n = t.touches;
			if (n) {
				for (var r = {
						points: [],
						touches: [],
						target: e,
						event: t
					}, a = 0, o = n.length; o > a; a++) {
					var s = n[a],
						l = _e(i, s, {});
					r.points.push([l.zrX, l.zrY]), r.touches.push(s)
				}
				this._track.push(r)
			}
		},
		_recognize: function(t) {
			for (var e in dg)
				if (dg.hasOwnProperty(e)) {
					var i = dg[e](this._track, t);
					if (i) return i
				}
		}
	};
	var dg = {
			pinch: function(t, e) {
				var i = t.length;
				if (i) {
					var n = (t[i - 1] || {}).points,
						r = (t[i - 2] || {}).points || n;
					if (r && r.length > 1 && n && n.length > 1) {
						var a = Te(n) / Te(r);
						!isFinite(a) && (a = 1), e.pinchScale = a;
						var o = Ce(n);
						return e.pinchX = o[0], e.pinchY = o[1], {
							type: "pinch",
							target: t[0].target,
							event: e
						}
					}
				}
			}
		},
		fg = "silent";
	Ae.prototype.dispose = function() {};
	var pg = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
		gg = function(t, e, i, n) {
			ng.call(this), this.storage = t, this.painter = e, this.painterRoot = n, i = i || new Ae, this.proxy = null, this._hovered = {}, this._lastTouchMoment, this._lastX, this._lastY, this._gestureMgr, le.call(this), this.setHandlerProxy(i)
		};
	gg.prototype = {
		constructor: gg,
		setHandlerProxy: function(t) {
			this.proxy && this.proxy.dispose(), t && (f(pg, function(e) {
				t.on && t.on(e, this[e], this)
			}, this), t.handler = this), this.proxy = t
		},
		mousemove: function(t) {
			var e = t.zrX,
				i = t.zrY,
				n = Le(this, e, i),
				r = this._hovered,
				a = r.target;
			a && !a.__zr && (r = this.findHover(r.x, r.y), a = r.target);
			var o = this._hovered = n ? {
					x: e,
					y: i
				} : this.findHover(e, i),
				s = o.target,
				l = this.proxy;
			l.setCursor && l.setCursor(s ? s.cursor : "default"), a && s !== a && this.dispatchToElement(r, "mouseout", t), this.dispatchToElement(o, "mousemove", t), s && s !== a && this.dispatchToElement(o, "mouseover", t)
		},
		mouseout: function(t) {
			var e = t.zrEventControl,
				i = t.zrIsToLocalDOM;
			"only_globalout" !== e && this.dispatchToElement(this._hovered, "mouseout", t), "no_globalout" !== e && !i && this.trigger("globalout", {
				type: "globalout",
				event: t
			})
		},
		resize: function() {
			this._hovered = {}
		},
		dispatch: function(t, e) {
			var i = this[t];
			i && i.call(this, e)
		},
		dispose: function() {
			this.proxy.dispose(), this.storage = this.proxy = this.painter = null
		},
		setCursorStyle: function(t) {
			var e = this.proxy;
			e.setCursor && e.setCursor(t)
		},
		dispatchToElement: function(t, e, i) {
			t = t || {};
			var n = t.target;
			if (!n || !n.silent) {
				for (var r = "on" + e, a = De(e, t, i); n && (n[r] && (a.cancelBubble = n[r].call(n, a)), n.trigger(e, a), n = n.parent, !a.cancelBubble););
				a.cancelBubble || (this.trigger(e, a), this.painter && this.painter.eachOtherLayer(function(t) {
					"function" == typeof t[r] && t[r].call(t, a), t.trigger && t.trigger(e, a)
				}))
			}
		},
		findHover: function(t, e, i) {
			for (var n = this.storage.getDisplayList(), r = {
					x: t,
					y: e
				}, a = n.length - 1; a >= 0; a--) {
				var o;
				if (n[a] !== i && !n[a].ignore && (o = Pe(n[a], t, e)) && (!r.topTarget && (r.topTarget = n[a]), o !== fg)) {
					r.target = n[a];
					break
				}
			}
			return r
		},
		processGesture: function(t, e) {
			this._gestureMgr || (this._gestureMgr = new cg);
			var i = this._gestureMgr;
			"start" === e && i.clear();
			var n = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
			if ("end" === e && i.clear(), n) {
				var r = n.type;
				t.gestureEvent = r, this.dispatchToElement({
					target: n.target
				}, r, n.event)
			}
		}
	}, f(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(t) {
		gg.prototype[t] = function(e) {
			var i, n, r = e.zrX,
				a = e.zrY,
				o = Le(this, r, a);
			if ("mouseup" === t && o || (i = this.findHover(r, a), n = i.target), "mousedown" === t) this._downEl = n, this._downPoint = [e.zrX, e.zrY], this._upEl = n;
			else if ("mouseup" === t) this._upEl = n;
			else if ("click" === t) {
				if (this._downEl !== this._upEl || !this._downPoint || Jp(this._downPoint, [e.zrX, e.zrY]) > 4) return;
				this._downPoint = null
			}
			this.dispatchToElement(i, t, e)
		}
	}), c(gg, ng), c(gg, le);
	var vg = "undefined" == typeof Float32Array ? Array : Float32Array,
		mg = (Object.freeze || Object)({
			create: Oe,
			identity: Ee,
			copy: ze,
			mul: Be,
			translate: Re,
			rotate: Ne,
			scale: Fe,
			invert: Ve,
			clone: He
		}),
		yg = Ee,
		_g = 5e-5,
		xg = function(t) {
			t = t || {}, t.position || (this.position = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null
		},
		wg = xg.prototype;
	wg.transform = null, wg.needLocalTransform = function() {
		return We(this.rotation) || We(this.position[0]) || We(this.position[1]) || We(this.scale[0] - 1) || We(this.scale[1] - 1)
	};
	var bg = [];
	wg.updateTransform = function() {
		var t = this.parent,
			e = t && t.transform,
			i = this.needLocalTransform(),
			n = this.transform;
		if (!i && !e) return void(n && yg(n));
		n = n || Oe(), i ? this.getLocalTransform(n) : yg(n), e && (i ? Be(n, t.transform, n) : ze(n, t.transform)), this.transform = n;
		var r = this.globalScaleRatio;
		if (null != r && 1 !== r) {
			this.getGlobalScale(bg);
			var a = bg[0] < 0 ? -1 : 1,
				o = bg[1] < 0 ? -1 : 1,
				s = ((bg[0] - a) * r + a) / bg[0] || 0,
				l = ((bg[1] - o) * r + o) / bg[1] || 0;
			n[0] *= s, n[1] *= s, n[2] *= l, n[3] *= l
		}
		this.invTransform = this.invTransform || Oe(), Ve(this.invTransform, n)
	}, wg.getLocalTransform = function(t) {
		return xg.getLocalTransform(this, t)
	}, wg.setTransform = function(t) {
		var e = this.transform,
			i = t.dpr || 1;
		e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0)
	}, wg.restoreTransform = function(t) {
		var e = t.dpr || 1;
		t.setTransform(e, 0, 0, e, 0, 0)
	};
	var Sg = [],
		Mg = Oe();
	wg.setLocalTransform = function(t) {
		if (t) {
			var e = t[0] * t[0] + t[1] * t[1],
				i = t[2] * t[2] + t[3] * t[3],
				n = this.position,
				r = this.scale;
			We(e - 1) && (e = Math.sqrt(e)), We(i - 1) && (i = Math.sqrt(i)), t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), n[0] = t[4], n[1] = t[5], r[0] = e, r[1] = i, this.rotation = Math.atan2(-t[1] / i, t[0] / e)
		}
	}, wg.decomposeTransform = function() {
		if (this.transform) {
			var t = this.parent,
				e = this.transform;
			t && t.transform && (Be(Sg, t.invTransform, e), e = Sg);
			var i = this.origin;
			i && (i[0] || i[1]) && (Mg[4] = i[0], Mg[5] = i[1], Be(Sg, e, Mg), Sg[4] -= i[0], Sg[5] -= i[1], e = Sg), this.setLocalTransform(e)
		}
	}, wg.getGlobalScale = function(t) {
		var e = this.transform;
		return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t)
	}, wg.transformCoordToLocal = function(t, e) {
		var i = [t, e],
			n = this.invTransform;
		return n && ae(i, i, n), i
	}, wg.transformCoordToGlobal = function(t, e) {
		var i = [t, e],
			n = this.transform;
		return n && ae(i, i, n), i
	}, xg.getLocalTransform = function(t, e) {
		e = e || [], yg(e);
		var i = t.origin,
			n = t.scale || [1, 1],
			r = t.rotation || 0,
			a = t.position || [0, 0];
		return i && (e[4] -= i[0], e[5] -= i[1]), Fe(e, e, n), r && Ne(e, e, r), i && (e[4] += i[0], e[5] += i[1]), e[4] += a[0], e[5] += a[1], e
	};
	var Ig = {
		linear: function(t) {
			return t
		},
		quadraticIn: function(t) {
			return t * t
		},
		quadraticOut: function(t) {
			return t * (2 - t)
		},
		quadraticInOut: function(t) {
			return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
		},
		cubicIn: function(t) {
			return t * t * t
		},
		cubicOut: function(t) {
			return --t * t * t + 1
		},
		cubicInOut: function(t) {
			return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
		},
		quarticIn: function(t) {
			return t * t * t * t
		},
		quarticOut: function(t) {
			return 1 - --t * t * t * t
		},
		quarticInOut: function(t) {
			return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
		},
		quinticIn: function(t) {
			return t * t * t * t * t
		},
		quinticOut: function(t) {
			return --t * t * t * t * t + 1
		},
		quinticInOut: function(t) {
			return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
		},
		sinusoidalIn: function(t) {
			return 1 - Math.cos(t * Math.PI / 2)
		},
		sinusoidalOut: function(t) {
			return Math.sin(t * Math.PI / 2)
		},
		sinusoidalInOut: function(t) {
			return .5 * (1 - Math.cos(Math.PI * t))
		},
		exponentialIn: function(t) {
			return 0 === t ? 0 : Math.pow(1024, t - 1)
		},
		exponentialOut: function(t) {
			return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
		},
		exponentialInOut: function(t) {
			return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
		},
		circularIn: function(t) {
			return 1 - Math.sqrt(1 - t * t)
		},
		circularOut: function(t) {
			return Math.sqrt(1 - --t * t)
		},
		circularInOut: function(t) {
			return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
		},
		elasticIn: function(t) {
			var e, i = .1,
				n = .4;
			return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n)))
		},
		elasticOut: function(t) {
			var e, i = .1,
				n = .4;
			return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1)
		},
		elasticInOut: function(t) {
			var e, i = .1,
				n = .4;
			return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1)
		},
		backIn: function(t) {
			var e = 1.70158;
			return t * t * ((e + 1) * t - e)
		},
		backOut: function(t) {
			var e = 1.70158;
			return --t * t * ((e + 1) * t + e) + 1
		},
		backInOut: function(t) {
			var e = 2.5949095;
			return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
		},
		bounceIn: function(t) {
			return 1 - Ig.bounceOut(1 - t)
		},
		bounceOut: function(t) {
			return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
		},
		bounceInOut: function(t) {
			return .5 > t ? .5 * Ig.bounceIn(2 * t) : .5 * Ig.bounceOut(2 * t - 1) + .5
		}
	};
	Ge.prototype = {
		constructor: Ge,
		step: function(t, e) {
			if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), this._paused) return void(this._pausedTime += e);
			var i = (t - this._startTime - this._pausedTime) / this._life;
			if (!(0 > i)) {
				i = Math.min(i, 1);
				var n = this.easing,
					r = "string" == typeof n ? Ig[n] : n,
					a = "function" == typeof r ? r(i) : i;
				return this.fire("frame", a), 1 === i ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null
			}
		},
		restart: function(t) {
			var e = (t - this._startTime - this._pausedTime) % this._life;
			this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1
		},
		fire: function(t, e) {
			t = "on" + t, this[t] && this[t](this._target, e)
		},
		pause: function() {
			this._paused = !0
		},
		resume: function() {
			this._paused = !1
		}
	};
	var Tg = function() {
			this.head = null, this.tail = null, this._len = 0
		},
		Cg = Tg.prototype;
	Cg.insert = function(t) {
		var e = new Dg(t);
		return this.insertEntry(e), e
	}, Cg.insertEntry = function(t) {
		this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++
	}, Cg.remove = function(t) {
		var e = t.prev,
			i = t.next;
		e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--
	}, Cg.len = function() {
		return this._len
	}, Cg.clear = function() {
		this.head = this.tail = null, this._len = 0
	};
	var Dg = function(t) {
			this.value = t, this.next, this.prev
		},
		kg = function(t) {
			this._list = new Tg, this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null
		},
		Ag = kg.prototype;
	Ag.put = function(t, e) {
		var i = this._list,
			n = this._map,
			r = null;
		if (null == n[t]) {
			var a = i.len(),
				o = this._lastRemovedEntry;
			if (a >= this._maxSize && a > 0) {
				var s = i.head;
				i.remove(s), delete n[s.key], r = s.value, this._lastRemovedEntry = s
			}
			o ? o.value = e : o = new Dg(e), o.key = t, i.insertEntry(o), n[t] = o
		}
		return r
	}, Ag.get = function(t) {
		var e = this._map[t],
			i = this._list;
		return null != e ? (e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value) : void 0
	}, Ag.clear = function() {
		this._list.clear(), this._map = {}
	};
	var Pg = {
			transparent: [0, 0, 0, 0],
			aliceblue: [240, 248, 255, 1],
			antiquewhite: [250, 235, 215, 1],
			aqua: [0, 255, 255, 1],
			aquamarine: [127, 255, 212, 1],
			azure: [240, 255, 255, 1],
			beige: [245, 245, 220, 1],
			bisque: [255, 228, 196, 1],
			black: [0, 0, 0, 1],
			blanchedalmond: [255, 235, 205, 1],
			blue: [0, 0, 255, 1],
			blueviolet: [138, 43, 226, 1],
			brown: [165, 42, 42, 1],
			burlywood: [222, 184, 135, 1],
			cadetblue: [95, 158, 160, 1],
			chartreuse: [127, 255, 0, 1],
			chocolate: [210, 105, 30, 1],
			coral: [255, 127, 80, 1],
			cornflowerblue: [100, 149, 237, 1],
			cornsilk: [255, 248, 220, 1],
			crimson: [220, 20, 60, 1],
			cyan: [0, 255, 255, 1],
			darkblue: [0, 0, 139, 1],
			darkcyan: [0, 139, 139, 1],
			darkgoldenrod: [184, 134, 11, 1],
			darkgray: [169, 169, 169, 1],
			darkgreen: [0, 100, 0, 1],
			darkgrey: [169, 169, 169, 1],
			darkkhaki: [189, 183, 107, 1],
			darkmagenta: [139, 0, 139, 1],
			darkolivegreen: [85, 107, 47, 1],
			darkorange: [255, 140, 0, 1],
			darkorchid: [153, 50, 204, 1],
			darkred: [139, 0, 0, 1],
			darksalmon: [233, 150, 122, 1],
			darkseagreen: [143, 188, 143, 1],
			darkslateblue: [72, 61, 139, 1],
			darkslategray: [47, 79, 79, 1],
			darkslategrey: [47, 79, 79, 1],
			darkturquoise: [0, 206, 209, 1],
			darkviolet: [148, 0, 211, 1],
			deeppink: [255, 20, 147, 1],
			deepskyblue: [0, 191, 255, 1],
			dimgray: [105, 105, 105, 1],
			dimgrey: [105, 105, 105, 1],
			dodgerblue: [30, 144, 255, 1],
			firebrick: [178, 34, 34, 1],
			floralwhite: [255, 250, 240, 1],
			forestgreen: [34, 139, 34, 1],
			fuchsia: [255, 0, 255, 1],
			gainsboro: [220, 220, 220, 1],
			ghostwhite: [248, 248, 255, 1],
			gold: [255, 215, 0, 1],
			goldenrod: [218, 165, 32, 1],
			gray: [128, 128, 128, 1],
			green: [0, 128, 0, 1],
			greenyellow: [173, 255, 47, 1],
			grey: [128, 128, 128, 1],
			honeydew: [240, 255, 240, 1],
			hotpink: [255, 105, 180, 1],
			indianred: [205, 92, 92, 1],
			indigo: [75, 0, 130, 1],
			ivory: [255, 255, 240, 1],
			khaki: [240, 230, 140, 1],
			lavender: [230, 230, 250, 1],
			lavenderblush: [255, 240, 245, 1],
			lawngreen: [124, 252, 0, 1],
			lemonchiffon: [255, 250, 205, 1],
			lightblue: [173, 216, 230, 1],
			lightcoral: [240, 128, 128, 1],
			lightcyan: [224, 255, 255, 1],
			lightgoldenrodyellow: [250, 250, 210, 1],
			lightgray: [211, 211, 211, 1],
			lightgreen: [144, 238, 144, 1],
			lightgrey: [211, 211, 211, 1],
			lightpink: [255, 182, 193, 1],
			lightsalmon: [255, 160, 122, 1],
			lightseagreen: [32, 178, 170, 1],
			lightskyblue: [135, 206, 250, 1],
			lightslategray: [119, 136, 153, 1],
			lightslategrey: [119, 136, 153, 1],
			lightsteelblue: [176, 196, 222, 1],
			lightyellow: [255, 255, 224, 1],
			lime: [0, 255, 0, 1],
			limegreen: [50, 205, 50, 1],
			linen: [250, 240, 230, 1],
			magenta: [255, 0, 255, 1],
			maroon: [128, 0, 0, 1],
			mediumaquamarine: [102, 205, 170, 1],
			mediumblue: [0, 0, 205, 1],
			mediumorchid: [186, 85, 211, 1],
			mediumpurple: [147, 112, 219, 1],
			mediumseagreen: [60, 179, 113, 1],
			mediumslateblue: [123, 104, 238, 1],
			mediumspringgreen: [0, 250, 154, 1],
			mediumturquoise: [72, 209, 204, 1],
			mediumvioletred: [199, 21, 133, 1],
			midnightblue: [25, 25, 112, 1],
			mintcream: [245, 255, 250, 1],
			mistyrose: [255, 228, 225, 1],
			moccasin: [255, 228, 181, 1],
			navajowhite: [255, 222, 173, 1],
			navy: [0, 0, 128, 1],
			oldlace: [253, 245, 230, 1],
			olive: [128, 128, 0, 1],
			olivedrab: [107, 142, 35, 1],
			orange: [255, 165, 0, 1],
			orangered: [255, 69, 0, 1],
			orchid: [218, 112, 214, 1],
			palegoldenrod: [238, 232, 170, 1],
			palegreen: [152, 251, 152, 1],
			paleturquoise: [175, 238, 238, 1],
			palevioletred: [219, 112, 147, 1],
			papayawhip: [255, 239, 213, 1],
			peachpuff: [255, 218, 185, 1],
			peru: [205, 133, 63, 1],
			pink: [255, 192, 203, 1],
			plum: [221, 160, 221, 1],
			powderblue: [176, 224, 230, 1],
			purple: [128, 0, 128, 1],
			red: [255, 0, 0, 1],
			rosybrown: [188, 143, 143, 1],
			royalblue: [65, 105, 225, 1],
			saddlebrown: [139, 69, 19, 1],
			salmon: [250, 128, 114, 1],
			sandybrown: [244, 164, 96, 1],
			seagreen: [46, 139, 87, 1],
			seashell: [255, 245, 238, 1],
			sienna: [160, 82, 45, 1],
			silver: [192, 192, 192, 1],
			skyblue: [135, 206, 235, 1],
			slateblue: [106, 90, 205, 1],
			slategray: [112, 128, 144, 1],
			slategrey: [112, 128, 144, 1],
			snow: [255, 250, 250, 1],
			springgreen: [0, 255, 127, 1],
			steelblue: [70, 130, 180, 1],
			tan: [210, 180, 140, 1],
			teal: [0, 128, 128, 1],
			thistle: [216, 191, 216, 1],
			tomato: [255, 99, 71, 1],
			turquoise: [64, 224, 208, 1],
			violet: [238, 130, 238, 1],
			wheat: [245, 222, 179, 1],
			white: [255, 255, 255, 1],
			whitesmoke: [245, 245, 245, 1],
			yellow: [255, 255, 0, 1],
			yellowgreen: [154, 205, 50, 1]
		},
		Lg = new kg(20),
		Og = null,
		Eg = ai,
		zg = oi,
		Bg = (Object.freeze || Object)({
			parse: ti,
			lift: ni,
			toHex: ri,
			fastLerp: ai,
			fastMapToColor: Eg,
			lerp: oi,
			mapToColor: zg,
			modifyHSL: si,
			modifyAlpha: li,
			stringify: ui
		}),
		Rg = Array.prototype.slice,
		Ng = function(t, e, i, n) {
			this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = i || hi, this._setter = n || ci, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []
		};
	Ng.prototype = {
		when: function(t, e) {
			var i = this._tracks;
			for (var n in e)
				if (e.hasOwnProperty(n)) {
					if (!i[n]) {
						i[n] = [];
						var r = this._getter(this._target, n);
						if (null == r) continue;
						0 !== t && i[n].push({
							time: 0,
							value: _i(r)
						})
					}
					i[n].push({
						time: t,
						value: e[n]
					})
				}
			return this
		},
		during: function(t) {
			return this._onframeList.push(t), this
		},
		pause: function() {
			for (var t = 0; t < this._clipList.length; t++) this._clipList[t].pause();
			this._paused = !0
		},
		resume: function() {
			for (var t = 0; t < this._clipList.length; t++) this._clipList[t].resume();
			this._paused = !1
		},
		isPaused: function() {
			return !!this._paused
		},
		_doneCallback: function() {
			this._tracks = {}, this._clipList.length = 0;
			for (var t = this._doneList, e = t.length, i = 0; e > i; i++) t[i].call(this)
		},
		start: function(t, e) {
			var i, n = this,
				r = 0,
				a = function() {
					r--, r || n._doneCallback()
				};
			for (var o in this._tracks)
				if (this._tracks.hasOwnProperty(o)) {
					var s = bi(this, t, a, this._tracks[o], o, e);
					s && (this._clipList.push(s), r++, this.animation && this.animation.addClip(s), i = s)
				}
			if (i) {
				var l = i.onframe;
				i.onframe = function(t, e) {
					l(t, e);
					for (var i = 0; i < n._onframeList.length; i++) n._onframeList[i](t, e)
				}
			}
			return r || this._doneCallback(), this
		},
		stop: function(t) {
			for (var e = this._clipList, i = this.animation, n = 0; n < e.length; n++) {
				var r = e[n];
				t && r.onframe(this._target, 1), i && i.removeClip(r)
			}
			e.length = 0
		},
		delay: function(t) {
			return this._delay = t, this
		},
		done: function(t) {
			return t && this._doneList.push(t), this
		},
		getClips: function() {
			return this._clipList
		}
	};
	var Fg = 1;
	"undefined" != typeof window && (Fg = Math.max(window.devicePixelRatio || 1, 1));
	var Vg = 0,
		Hg = Fg,
		Wg = function() {};
	1 === Vg && (Wg = console.error);
	var Gg = Wg,
		Ug = function() {
			this.animators = []
		};
	Ug.prototype = {
		constructor: Ug,
		animate: function(t, e) {
			var i, n = !1,
				r = this,
				a = this.__zr;
			if (t) {
				var o = t.split("."),
					s = r;
				n = "shape" === o[0];
				for (var l = 0, h = o.length; h > l; l++) s && (s = s[o[l]]);
				s && (i = s)
			} else i = r;
			if (!i) return void Gg('Property "' + t + '" is not existed in element ' + r.id);
			var c = r.animators,
				d = new Ng(i, e);
			return d.during(function() {
				r.dirty(n)
			}).done(function() {
				c.splice(u(c, d), 1)
			}), c.push(d), a && a.animation.addAnimator(d), d
		},
		stopAnimation: function(t) {
			for (var e = this.animators, i = e.length, n = 0; i > n; n++) e[n].stop(t);
			return e.length = 0, this
		},
		animateTo: function(t, e, i, n, r, a) {
			Si(this, t, e, i, n, r, a)
		},
		animateFrom: function(t, e, i, n, r, a) {
			Si(this, t, e, i, n, r, a, !0)
		}
	};
	var Xg = function(t) {
		xg.call(this, t), ng.call(this, t), Ug.call(this, t), this.id = t.id || Op()
	};
	Xg.prototype = {
		type: "element",
		name: "",
		__zr: null,
		ignore: !1,
		clipPath: null,
		isGroup: !1,
		drift: function(t, e) {
			switch (this.draggable) {
				case "horizontal":
					e = 0;
					break;
				case "vertical":
					t = 0
			}
			var i = this.transform;
			i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1)
		},
		beforeUpdate: function() {},
		afterUpdate: function() {},
		update: function() {
			this.updateTransform()
		},
		traverse: function() {},
		attrKV: function(t, e) {
			if ("position" === t || "scale" === t || "origin" === t) {
				if (e) {
					var i = this[t];
					i || (i = this[t] = []), i[0] = e[0], i[1] = e[1]
				}
			} else this[t] = e
		},
		hide: function() {
			this.ignore = !0, this.__zr && this.__zr.refresh()
		},
		show: function() {
			this.ignore = !1, this.__zr && this.__zr.refresh()
		},
		attr: function(t, e) {
			if ("string" == typeof t) this.attrKV(t, e);
			else if (S(t))
				for (var i in t) t.hasOwnProperty(i) && this.attrKV(i, t[i]);
			return this.dirty(!1), this
		},
		setClipPath: function(t) {
			var e = this.__zr;
			e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1)
		},
		removeClipPath: function() {
			var t = this.clipPath;
			t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1))
		},
		addSelfToZr: function(t) {
			this.__zr = t;
			var e = this.animators;
			if (e)
				for (var i = 0; i < e.length; i++) t.animation.addAnimator(e[i]);
			this.clipPath && this.clipPath.addSelfToZr(t)
		},
		removeSelfFromZr: function(t) {
			this.__zr = null;
			var e = this.animators;
			if (e)
				for (var i = 0; i < e.length; i++) t.animation.removeAnimator(e[i]);
			this.clipPath && this.clipPath.removeSelfFromZr(t)
		}
	}, c(Xg, Ug), c(Xg, xg), c(Xg, ng);
	var jg = ae,
		Yg = Math.min,
		qg = Math.max;
	Ti.prototype = {
		constructor: Ti,
		union: function(t) {
			var e = Yg(t.x, this.x),
				i = Yg(t.y, this.y);
			this.width = qg(t.x + t.width, this.x + this.width) - e, this.height = qg(t.y + t.height, this.y + this.height) - i, this.x = e, this.y = i
		},
		applyTransform: function() {
			var t = [],
				e = [],
				i = [],
				n = [];
			return function(r) {
				if (r) {
					t[0] = i[0] = this.x, t[1] = n[1] = this.y, e[0] = n[0] = this.x + this.width, e[1] = i[1] = this.y + this.height, jg(t, t, r), jg(e, e, r), jg(i, i, r), jg(n, n, r), this.x = Yg(t[0], e[0], i[0], n[0]), this.y = Yg(t[1], e[1], i[1], n[1]);
					var a = qg(t[0], e[0], i[0], n[0]),
						o = qg(t[1], e[1], i[1], n[1]);
					this.width = a - this.x, this.height = o - this.y
				}
			}
		}(),
		calculateTransform: function(t) {
			var e = this,
				i = t.width / e.width,
				n = t.height / e.height,
				r = Oe();
			return Re(r, r, [-e.x, -e.y]), Fe(r, r, [i, n]), Re(r, r, [t.x, t.y]), r
		},
		intersect: function(t) {
			if (!t) return !1;
			t instanceof Ti || (t = Ti.create(t));
			var e = this,
				i = e.x,
				n = e.x + e.width,
				r = e.y,
				a = e.y + e.height,
				o = t.x,
				s = t.x + t.width,
				l = t.y,
				u = t.y + t.height;
			return !(o > n || i > s || l > a || r > u)
		},
		contain: function(t, e) {
			var i = this;
			return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height
		},
		clone: function() {
			return new Ti(this.x, this.y, this.width, this.height)
		},
		copy: function(t) {
			this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height
		},
		plain: function() {
			return {
				x: this.x,
				y: this.y,
				width: this.width,
				height: this.height
			}
		}
	}, Ti.create = function(t) {
		return new Ti(t.x, t.y, t.width, t.height)
	};
	var Zg = function(t) {
		t = t || {}, Xg.call(this, t);
		for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
		this._children = [], this.__storage = null, this.__dirty = !0
	};
	Zg.prototype = {
		constructor: Zg,
		isGroup: !0,
		type: "group",
		silent: !1,
		children: function() {
			return this._children.slice()
		},
		childAt: function(t) {
			return this._children[t]
		},
		childOfName: function(t) {
			for (var e = this._children, i = 0; i < e.length; i++)
				if (e[i].name === t) return e[i]
		},
		childCount: function() {
			return this._children.length
		},
		add: function(t) {
			return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this
		},
		addBefore: function(t, e) {
			if (t && t !== this && t.parent !== this && e && e.parent === this) {
				var i = this._children,
					n = i.indexOf(e);
				n >= 0 && (i.splice(n, 0, t), this._doAdd(t))
			}
			return this
		},
		_doAdd: function(t) {
			t.parent && t.parent.remove(t), t.parent = this;
			var e = this.__storage,
				i = this.__zr;
			e && e !== t.__storage && (e.addToStorage(t), t instanceof Zg && t.addChildrenToStorage(e)), i && i.refresh()
		},
		remove: function(t) {
			var e = this.__zr,
				i = this.__storage,
				n = this._children,
				r = u(n, t);
			return 0 > r ? this : (n.splice(r, 1), t.parent = null, i && (i.delFromStorage(t), t instanceof Zg && t.delChildrenFromStorage(i)), e && e.refresh(), this)
		},
		removeAll: function() {
			var t, e, i = this._children,
				n = this.__storage;
			for (e = 0; e < i.length; e++) t = i[e], n && (n.delFromStorage(t), t instanceof Zg && t.delChildrenFromStorage(n)), t.parent = null;
			return i.length = 0, this
		},
		eachChild: function(t, e) {
			for (var i = this._children, n = 0; n < i.length; n++) {
				var r = i[n];
				t.call(e, r, n)
			}
			return this
		},
		traverse: function(t, e) {
			for (var i = 0; i < this._children.length; i++) {
				var n = this._children[i];
				t.call(e, n), "group" === n.type && n.traverse(t, e)
			}
			return this
		},
		addChildrenToStorage: function(t) {
			for (var e = 0; e < this._children.length; e++) {
				var i = this._children[e];
				t.addToStorage(i), i instanceof Zg && i.addChildrenToStorage(t)
			}
		},
		delChildrenFromStorage: function(t) {
			for (var e = 0; e < this._children.length; e++) {
				var i = this._children[e];
				t.delFromStorage(i), i instanceof Zg && i.delChildrenFromStorage(t)
			}
		},
		dirty: function() {
			return this.__dirty = !0, this.__zr && this.__zr.refresh(), this
		},
		getBoundingRect: function(t) {
			for (var e = null, i = new Ti(0, 0, 0, 0), n = t || this._children, r = [], a = 0; a < n.length; a++) {
				var o = n[a];
				if (!o.ignore && !o.invisible) {
					var s = o.getBoundingRect(),
						l = o.getLocalTransform(r);
					l ? (i.copy(s), i.applyTransform(l), e = e || i.clone(), e.union(i)) : (e = e || s.clone(), e.union(s))
				}
			}
			return e || i
		}
	}, h(Zg, Xg);
	var Kg = 32,
		$g = 7,
		Qg = function() {
			this._roots = [], this._displayList = [], this._displayListLen = 0
		};
	Qg.prototype = {
		constructor: Qg,
		traverse: function(t, e) {
			for (var i = 0; i < this._roots.length; i++) this._roots[i].traverse(t, e)
		},
		getDisplayList: function(t, e) {
			return e = e || !1, t && this.updateDisplayList(e), this._displayList
		},
		updateDisplayList: function(t) {
			this._displayListLen = 0;
			for (var e = this._roots, i = this._displayList, n = 0, r = e.length; r > n; n++) this._updateAndAddDisplayable(e[n], null, t);
			i.length = this._displayListLen, zp.canvasSupported && Ei(i, zi)
		},
		_updateAndAddDisplayable: function(t, e, i) {
			if (!t.ignore || i) {
				t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate();
				var n = t.clipPath;
				if (n) {
					e = e ? e.slice() : [];
					for (var r = n, a = t; r;) r.parent = a, r.updateTransform(), e.push(r), a = r, r = r.clipPath
				}
				if (t.isGroup) {
					for (var o = t._children, s = 0; s < o.length; s++) {
						var l = o[s];
						t.__dirty && (l.__dirty = !0), this._updateAndAddDisplayable(l, e, i)
					}
					t.__dirty = !1
				} else t.__clipPaths = e, this._displayList[this._displayListLen++] = t
			}
		},
		addRoot: function(t) {
			t.__storage !== this && (t instanceof Zg && t.addChildrenToStorage(this), this.addToStorage(t), this._roots.push(t))
		},
		delRoot: function(t) {
			if (null == t) {
				for (var e = 0; e < this._roots.length; e++) {
					var i = this._roots[e];
					i instanceof Zg && i.delChildrenFromStorage(this)
				}
				return this._roots = [], this._displayList = [], void(this._displayListLen = 0)
			}
			if (t instanceof Array)
				for (var e = 0, n = t.length; n > e; e++) this.delRoot(t[e]);
			else {
				var r = u(this._roots, t);
				r >= 0 && (this.delFromStorage(t), this._roots.splice(r, 1), t instanceof Zg && t.delChildrenFromStorage(this))
			}
		},
		addToStorage: function(t) {
			return t && (t.__storage = this, t.dirty(!1)), this
		},
		delFromStorage: function(t) {
			return t && (t.__storage = null), this
		},
		dispose: function() {
			this._renderList = this._roots = null
		},
		displayableSortFunc: zi
	};
	var Jg = {
			shadowBlur: 1,
			shadowOffsetX: 1,
			shadowOffsetY: 1,
			textShadowBlur: 1,
			textShadowOffsetX: 1,
			textShadowOffsetY: 1,
			textBoxShadowBlur: 1,
			textBoxShadowOffsetX: 1,
			textBoxShadowOffsetY: 1
		},
		tv = function(t, e, i) {
			return Jg.hasOwnProperty(e) ? i *= t.dpr : i
		},
		ev = {
			NONE: 0,
			STYLE_BIND: 1,
			PLAIN_TEXT: 2
		},
		iv = 9,
		nv = [
			["shadowBlur", 0],
			["shadowOffsetX", 0],
			["shadowOffsetY", 0],
			["shadowColor", "#000"],
			["lineCap", "butt"],
			["lineJoin", "miter"],
			["miterLimit", 10]
		],
		rv = function(t) {
			this.extendFrom(t, !1)
		};
	rv.prototype = {
		constructor: rv,
		fill: "#000",
		stroke: null,
		opacity: 1,
		fillOpacity: null,
		strokeOpacity: null,
		lineDash: null,
		lineDashOffset: 0,
		shadowBlur: 0,
		shadowOffsetX: 0,
		shadowOffsetY: 0,
		lineWidth: 1,
		strokeNoScale: !1,
		text: null,
		font: null,
		textFont: null,
		fontStyle: null,
		fontWeight: null,
		fontSize: null,
		fontFamily: null,
		textTag: null,
		textFill: "#000",
		textStroke: null,
		textWidth: null,
		textHeight: null,
		textStrokeWidth: 0,
		textLineHeight: null,
		textPosition: "inside",
		textRect: null,
		textOffset: null,
		textAlign: null,
		textVerticalAlign: null,
		textDistance: 5,
		textShadowColor: "transparent",
		textShadowBlur: 0,
		textShadowOffsetX: 0,
		textShadowOffsetY: 0,
		textBoxShadowColor: "transparent",
		textBoxShadowBlur: 0,
		textBoxShadowOffsetX: 0,
		textBoxShadowOffsetY: 0,
		transformText: !1,
		textRotation: 0,
		textOrigin: null,
		textBackgroundColor: null,
		textBorderColor: null,
		textBorderWidth: 0,
		textBorderRadius: 0,
		textPadding: null,
		rich: null,
		truncate: null,
		blend: null,
		bind: function(t, e, i) {
			var n = this,
				r = i && i.style,
				a = !r || t.__attrCachedBy !== ev.STYLE_BIND;
			t.__attrCachedBy = ev.STYLE_BIND;
			for (var o = 0; o < nv.length; o++) {
				var s = nv[o],
					l = s[0];
				(a || n[l] !== r[l]) && (t[l] = tv(t, l, n[l] || s[1]))
			}
			if ((a || n.fill !== r.fill) && (t.fillStyle = n.fill), (a || n.stroke !== r.stroke) && (t.strokeStyle = n.stroke), (a || n.opacity !== r.opacity) && (t.globalAlpha = null == n.opacity ? 1 : n.opacity), (a || n.blend !== r.blend) && (t.globalCompositeOperation = n.blend || "source-over"), this.hasStroke()) {
				var u = n.lineWidth;
				t.lineWidth = u / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1)
			}
		},
		hasFill: function() {
			var t = this.fill;
			return null != t && "none" !== t
		},
		hasStroke: function() {
			var t = this.stroke;
			return null != t && "none" !== t && this.lineWidth > 0
		},
		extendFrom: function(t, e) {
			if (t)
				for (var i in t) !t.hasOwnProperty(i) || e !== !0 && (e === !1 ? this.hasOwnProperty(i) : null == t[i]) || (this[i] = t[i])
		},
		set: function(t, e) {
			"string" == typeof t ? this[t] = e : this.extendFrom(t, !0)
		},
		clone: function() {
			var t = new this.constructor;
			return t.extendFrom(this, !0), t
		},
		getGradient: function(t, e, i) {
			for (var n = "radial" === e.type ? Ri : Bi, r = n(t, e, i), a = e.colorStops, o = 0; o < a.length; o++) r.addColorStop(a[o].offset, a[o].color);
			return r
		}
	};
	for (var av = rv.prototype, ov = 0; ov < nv.length; ov++) {
		var sv = nv[ov];
		sv[0] in av || (av[sv[0]] = sv[1])
	}
	rv.getGradient = av.getGradient;
	var lv = function(t, e) {
		this.image = t, this.repeat = e, this.type = "pattern"
	};
	lv.prototype.getCanvasPattern = function(t) {
		return t.createPattern(this.image, this.repeat || "repeat")
	};
	var uv = function(t, e, i) {
		var n;
		i = i || Hg, "string" == typeof t ? n = Fi(t, e, i) : S(t) && (n = t, t = n.id), this.id = t, this.dom = n;
		var r = n.style;
		r && (n.onselectstart = Ni, r["-webkit-user-select"] = "none", r["user-select"] = "none", r["-webkit-touch-callout"] = "none", r["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", r.padding = 0, r.margin = 0, r["border-width"] = 0), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = i
	};
	uv.prototype = {
		constructor: uv,
		__dirty: !0,
		__used: !1,
		__drawIndex: 0,
		__startIndex: 0,
		__endIndex: 0,
		incremental: !1,
		getElementCount: function() {
			return this.__endIndex - this.__startIndex
		},
		initContext: function() {
			this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr
		},
		createBackBuffer: function() {
			var t = this.dpr;
			this.domBack = Fi("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 !== t && this.ctxBack.scale(t, t)
		},
		resize: function(t, e) {
			var i = this.dpr,
				n = this.dom,
				r = n.style,
				a = this.domBack;
			r && (r.width = t + "px", r.height = e + "px"), n.width = t * i, n.height = e * i, a && (a.width = t * i, a.height = e * i, 1 !== i && this.ctxBack.scale(i, i))
		},
		clear: function(t, e) {
			var i = this.dom,
				n = this.ctx,
				r = i.width,
				a = i.height,
				e = e || this.clearColor,
				o = this.motionBlur && !t,
				s = this.lastFrameAlpha,
				l = this.dpr;
			if (o && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(i, 0, 0, r / l, a / l)), n.clearRect(0, 0, r, a), e && "transparent" !== e) {
				var u;
				e.colorStops ? (u = e.__canvasGradient || rv.getGradient(n, e, {
					x: 0,
					y: 0,
					width: r,
					height: a
				}), e.__canvasGradient = u) : e.image && (u = lv.prototype.getCanvasPattern.call(e, n)), n.save(), n.fillStyle = u || e, n.fillRect(0, 0, r, a), n.restore()
			}
			if (o) {
				var h = this.domBack;
				n.save(), n.globalAlpha = s, n.drawImage(h, 0, 0, r, a), n.restore()
			}
		}
	};
	var hv = "undefined" != typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) {
			setTimeout(t, 16)
		},
		cv = new kg(50),
		dv = {},
		fv = 0,
		pv = 5e3,
		gv = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g,
		vv = "12px sans-serif",
		mv = {};
	mv.measureText = function(t, e) {
		var i = l();
		return i.font = e || vv, i.measureText(t)
	};
	var yv = vv,
		_v = {
			left: 1,
			right: 1,
			center: 1
		},
		xv = {
			top: 1,
			bottom: 1,
			middle: 1
		},
		wv = [
			["textShadowBlur", "shadowBlur", 0],
			["textShadowOffsetX", "shadowOffsetX", 0],
			["textShadowOffsetY", "shadowOffsetY", 0],
			["textShadowColor", "shadowColor", "transparent"]
		],
		bv = {},
		Sv = {},
		Mv = new Ti,
		Iv = function() {};
	Iv.prototype = {
		constructor: Iv,
		drawRectText: function(t, e) {
			var i = this.style;
			e = i.textRect || e, this.__dirty && hn(i, !0);
			var n = i.text;
			if (null != n && (n += ""), Cn(n, i)) {
				t.save();
				var r = this.transform;
				i.transformText ? this.setTransform(t) : r && (Mv.copy(e), Mv.applyTransform(r), e = Mv), dn(this, t, n, i, e, iv), t.restore()
			}
		}
	}, Dn.prototype = {
		constructor: Dn,
		type: "displayable",
		__dirty: !0,
		invisible: !1,
		z: 0,
		z2: 0,
		zlevel: 0,
		draggable: !1,
		dragging: !1,
		silent: !1,
		culling: !1,
		cursor: "pointer",
		rectHover: !1,
		progressive: !1,
		incremental: !1,
		globalScaleRatio: 1,
		beforeBrush: function() {},
		afterBrush: function() {},
		brush: function() {},
		getBoundingRect: function() {},
		contain: function(t, e) {
			return this.rectContain(t, e)
		},
		traverse: function(t, e) {
			t.call(e, this)
		},
		rectContain: function(t, e) {
			var i = this.transformCoordToLocal(t, e),
				n = this.getBoundingRect();
			return n.contain(i[0], i[1])
		},
		dirty: function() {
			this.__dirty = this.__dirtyText = !0, this._rect = null, this.__zr && this.__zr.refresh()
		},
		animateStyle: function(t) {
			return this.animate("style", t)
		},
		attrKV: function(t, e) {
			"style" !== t ? Xg.prototype.attrKV.call(this, t, e) : this.style.set(e)
		},
		setStyle: function(t, e) {
			return this.style.set(t, e), this.dirty(!1), this
		},
		useStyle: function(t) {
			return this.style = new rv(t, this), this.dirty(!1), this
		},
		calculateTextPosition: null
	}, h(Dn, Xg), c(Dn, Iv), kn.prototype = {
		constructor: kn,
		type: "image",
		brush: function(t, e) {
			var i = this.style,
				n = i.image;
			i.bind(t, this, e);
			var r = this._image = Hi(n, this._image, this, this.onload);
			if (r && Gi(r)) {
				var a = i.x || 0,
					o = i.y || 0,
					s = i.width,
					l = i.height,
					u = r.width / r.height;
				if (null == s && null != l ? s = l * u : null == l && null != s ? l = s / u : null == s && null == l && (s = r.width, l = r.height), this.setTransform(t), i.sWidth && i.sHeight) {
					var h = i.sx || 0,
						c = i.sy || 0;
					t.drawImage(r, h, c, i.sWidth, i.sHeight, a, o, s, l)
				} else if (i.sx && i.sy) {
					var h = i.sx,
						c = i.sy,
						d = s - h,
						f = l - c;
					t.drawImage(r, h, c, d, f, a, o, s, l)
				} else t.drawImage(r, a, o, s, l);
				null != i.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect()))
			}
		},
		getBoundingRect: function() {
			var t = this.style;
			return this._rect || (this._rect = new Ti(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect
		}
	}, h(kn, Dn);
	var Tv = 1e5,
		Cv = 314159,
		Dv = .01,
		kv = .001,
		Av = new Ti(0, 0, 0, 0),
		Pv = new Ti(0, 0, 0, 0),
		Lv = function(t, e, i) {
			this.type = "canvas";
			var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
			this._opts = i = o({}, i || {}), this.dpr = i.devicePixelRatio || Hg, this._singleCanvas = n, this.root = t;
			var r = t.style;
			r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = r["user-select"] = r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e;
			var a = this._zlevelList = [],
				s = this._layers = {};
			if (this._layerConfig = {}, this._needsManuallyCompositing = !1, n) {
				var l = t.width,
					u = t.height;
				null != i.width && (l = i.width), null != i.height && (u = i.height), this.dpr = i.devicePixelRatio || 1, t.width = l * this.dpr, t.height = u * this.dpr, this._width = l, this._height = u;
				var h = new uv(t, this, this.dpr);
				h.__builtin__ = !0, h.initContext(), s[Cv] = h, h.zlevel = Cv, a.push(Cv), this._domRoot = t
			} else {
				this._width = this._getSize(0), this._height = this._getSize(1);
				var c = this._domRoot = zn(this._width, this._height);
				t.appendChild(c)
			}
			this._hoverlayer = null, this._hoverElements = []
		};
	Lv.prototype = {
		constructor: Lv,
		getType: function() {
			return "canvas"
		},
		isSingleCanvas: function() {
			return this._singleCanvas
		},
		getViewportRoot: function() {
			return this._domRoot
		},
		getViewportRootOffset: function() {
			var t = this.getViewportRoot();
			return t ? {
				offsetLeft: t.offsetLeft || 0,
				offsetTop: t.offsetTop || 0
			} : void 0
		},
		refresh: function(t) {
			var e = this.storage.getDisplayList(!0),
				i = this._zlevelList;
			this._redrawId = Math.random(), this._paintList(e, t, this._redrawId);
			for (var n = 0; n < i.length; n++) {
				var r = i[n],
					a = this._layers[r];
				if (!a.__builtin__ && a.refresh) {
					var o = 0 === n ? this._backgroundColor : null;
					a.refresh(o)
				}
			}
			return this.refreshHover(), this
		},
		addHover: function(t, e) {
			if (!t.__hoverMir) {
				var i = new t.constructor({
					style: t.style,
					shape: t.shape,
					z: t.z,
					z2: t.z2,
					silent: t.silent
				});
				return i.__from = t, t.__hoverMir = i, e && i.setStyle(e), this._hoverElements.push(i), i
			}
		},
		removeHover: function(t) {
			var e = t.__hoverMir,
				i = this._hoverElements,
				n = u(i, e);
			n >= 0 && i.splice(n, 1), t.__hoverMir = null
		},
		clearHover: function() {
			for (var t = this._hoverElements, e = 0; e < t.length; e++) {
				var i = t[e].__from;
				i && (i.__hoverMir = null)
			}
			t.length = 0
		},
		refreshHover: function() {
			var t = this._hoverElements,
				e = t.length,
				i = this._hoverlayer;
			if (i && i.clear(), e) {
				Ei(t, this.storage.displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(Tv));
				var n = {};
				i.ctx.save();
				for (var r = 0; e > r;) {
					var a = t[r],
						o = a.__from;
					o && o.__zr ? (r++, o.invisible || (a.transform = o.transform, a.invTransform = o.invTransform, a.__clipPaths = o.__clipPaths, this._doPaintEl(a, i, !0, n))) : (t.splice(r, 1), o.__hoverMir = null, e--)
				}
				i.ctx.restore()
			}
		},
		getHoverLayer: function() {
			return this.getLayer(Tv)
		},
		_paintList: function(t, e, i) {
			if (this._redrawId === i) {
				e = e || !1, this._updateLayerStatus(t);
				var n = this._doPaintList(t, e);
				if (this._needsManuallyCompositing && this._compositeManually(), !n) {
					var r = this;
					hv(function() {
						r._paintList(t, e, i)
					})
				}
			}
		},
		_compositeManually: function() {
			var t = this.getLayer(Cv).ctx,
				e = this._domRoot.width,
				i = this._domRoot.height;
			t.clearRect(0, 0, e, i), this.eachBuiltinLayer(function(n) {
				n.virtual && t.drawImage(n.dom, 0, 0, e, i)
			})
		},
		_doPaintList: function(t, e) {
			for (var i = [], n = 0; n < this._zlevelList.length; n++) {
				var r = this._zlevelList[n],
					a = this._layers[r];
				a.__builtin__ && a !== this._hoverlayer && (a.__dirty || e) && i.push(a)
			}
			for (var o = !0, s = 0; s < i.length; s++) {
				var a = i[s],
					l = a.ctx,
					u = {};
				l.save();
				var h = e ? a.__startIndex : a.__drawIndex,
					c = !e && a.incremental && Date.now,
					d = c && Date.now(),
					p = a.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
				if (a.__startIndex === a.__endIndex) a.clear(!1, p);
				else if (h === a.__startIndex) {
					var g = t[h];
					g.incremental && g.notClear && !e || a.clear(!1, p)
				} - 1 === h && (console.error("For some unknown reason. drawIndex is -1"), h = a.__startIndex);
				for (var v = h; v < a.__endIndex; v++) {
					var m = t[v];
					if (this._doPaintEl(m, a, e, u), m.__dirty = m.__dirtyText = !1, c) {
						var y = Date.now() - d;
						if (y > 15) break
					}
				}
				a.__drawIndex = v, a.__drawIndex < a.__endIndex && (o = !1), u.prevElClipPaths && l.restore(), l.restore()
			}
			return zp.wxa && f(this._layers, function(t) {
				t && t.ctx && t.ctx.draw && t.ctx.draw()
			}), o
		},
		_doPaintEl: function(t, e, i, n) {
			var r = e.ctx,
				a = t.transform;
			if (!(!e.__dirty && !i || t.invisible || 0 === t.style.opacity || a && !a[0] && !a[3] || t.culling && Ln(t, this._width, this._height))) {
				var o = t.__clipPaths,
					s = n.prevElClipPaths;
				(!s || On(o, s)) && (s && (r.restore(), n.prevElClipPaths = null, n.prevEl = null), o && (r.save(), En(o, r), n.prevElClipPaths = o)), t.beforeBrush && t.beforeBrush(r), t.brush(r, n.prevEl || null), n.prevEl = t, t.afterBrush && t.afterBrush(r)
			}
		},
		getLayer: function(t, e) {
			this._singleCanvas && !this._needsManuallyCompositing && (t = Cv);
			var i = this._layers[t];
			return i || (i = new uv("zr_" + t, this, this.dpr), i.zlevel = t, i.__builtin__ = !0, this._layerConfig[t] ? r(i, this._layerConfig[t], !0) : this._layerConfig[t - Dv] && r(i, this._layerConfig[t - Dv], !0), e && (i.virtual = e), this.insertLayer(t, i), i.initContext()), i
		},
		insertLayer: function(t, e) {
			var i = this._layers,
				n = this._zlevelList,
				r = n.length,
				a = null,
				o = -1,
				s = this._domRoot;
			if (i[t]) return void Gg("ZLevel " + t + " has been used already");
			if (!Pn(e)) return void Gg("Layer of zlevel " + t + " is not valid");
			if (r > 0 && t > n[0]) {
				for (o = 0; r - 1 > o && !(n[o] < t && n[o + 1] > t); o++);
				a = i[n[o]]
			}
			if (n.splice(o + 1, 0, t), i[t] = e, !e.virtual)
				if (a) {
					var l = a.dom;
					l.nextSibling ? s.insertBefore(e.dom, l.nextSibling) : s.appendChild(e.dom)
				} else s.firstChild ? s.insertBefore(e.dom, s.firstChild) : s.appendChild(e.dom)
		},
		eachLayer: function(t, e) {
			var i, n, r = this._zlevelList;
			for (n = 0; n < r.length; n++) i = r[n], t.call(e, this._layers[i], i)
		},
		eachBuiltinLayer: function(t, e) {
			var i, n, r, a = this._zlevelList;
			for (r = 0; r < a.length; r++) n = a[r], i = this._layers[n], i.__builtin__ && t.call(e, i, n)
		},
		eachOtherLayer: function(t, e) {
			var i, n, r, a = this._zlevelList;
			for (r = 0; r < a.length; r++) n = a[r], i = this._layers[n], i.__builtin__ || t.call(e, i, n)
		},
		getLayers: function() {
			return this._layers
		},
		_updateLayerStatus: function(t) {
			function e(t) {
				a && (a.__endIndex !== t && (a.__dirty = !0), a.__endIndex = t)
			}
			if (this.eachBuiltinLayer(function(t) {
					t.__dirty = t.__used = !1
				}), this._singleCanvas)
				for (var i = 1; i < t.length; i++) {
					var n = t[i];
					if (n.zlevel !== t[i - 1].zlevel || n.incremental) {
						this._needsManuallyCompositing = !0;
						break
					}
				}
			for (var r, a = null, o = 0, i = 0; i < t.length; i++) {
				var s, n = t[i],
					l = n.zlevel;
				r !== l && (r = l, o = 0), n.incremental ? (s = this.getLayer(l + kv, this._needsManuallyCompositing), s.incremental = !0, o = 1) : s = this.getLayer(l + (o > 0 ? Dv : 0), this._needsManuallyCompositing), s.__builtin__ || Gg("ZLevel " + l + " has been used by unkown layer " + s.id), s !== a && (s.__used = !0, s.__startIndex !== i && (s.__dirty = !0), s.__startIndex = i, s.__drawIndex = s.incremental ? -1 : i, e(i), a = s), n.__dirty && (s.__dirty = !0, s.incremental && s.__drawIndex < 0 && (s.__drawIndex = i))
			}
			e(i), this.eachBuiltinLayer(function(t) {
				!t.__used && t.getElementCount() > 0 && (t.__dirty = !0, t.__startIndex = t.__endIndex = t.__drawIndex = 0), t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex)
			})
		},
		clear: function() {
			return this.eachBuiltinLayer(this._clearLayer), this
		},
		_clearLayer: function(t) {
			t.clear()
		},
		setBackgroundColor: function(t) {
			this._backgroundColor = t
		},
		configLayer: function(t, e) {
			if (e) {
				var i = this._layerConfig;
				i[t] ? r(i[t], e, !0) : i[t] = e;
				for (var n = 0; n < this._zlevelList.length; n++) {
					var a = this._zlevelList[n];
					if (a === t || a === t + Dv) {
						var o = this._layers[a];
						r(o, i[t], !0)
					}
				}
			}
		},
		delLayer: function(t) {
			var e = this._layers,
				i = this._zlevelList,
				n = e[t];
			n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i.splice(u(i, t), 1))
		},
		resize: function(t, e) {
			if (this._domRoot.style) {
				var i = this._domRoot;
				i.style.display = "none";
				var n = this._opts;
				if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width !== t || e !== this._height) {
					i.style.width = t + "px", i.style.height = e + "px";
					for (var r in this._layers) this._layers.hasOwnProperty(r) && this._layers[r].resize(t, e);
					f(this._progressiveLayers, function(i) {
						i.resize(t, e)
					}), this.refresh(!0)
				}
				this._width = t, this._height = e
			} else {
				if (null == t || null == e) return;
				this._width = t, this._height = e, this.getLayer(Cv).resize(t, e)
			}
			return this
		},
		clearLayer: function(t) {
			var e = this._layers[t];
			e && e.clear()
		},
		dispose: function() {
			this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
		},
		getRenderedCanvas: function(t) {
			if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[Cv].dom;
			var e = new uv("image", this, t.pixelRatio || this.dpr);
			if (e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor), t.pixelRatio <= this.dpr) {
				this.refresh();
				var i = e.dom.width,
					n = e.dom.height,
					r = e.ctx;
				this.eachLayer(function(t) {
					t.__builtin__ ? r.drawImage(t.dom, 0, 0, i, n) : t.renderToCanvas && (e.ctx.save(), t.renderToCanvas(e.ctx), e.ctx.restore())
				})
			} else
				for (var a = {}, o = this.storage.getDisplayList(!0), s = 0; s < o.length; s++) {
					var l = o[s];
					this._doPaintEl(l, e, !0, a)
				}
			return e.dom
		},
		getWidth: function() {
			return this._width
		},
		getHeight: function() {
			return this._height
		},
		_getSize: function(t) {
			var e = this._opts,
				i = ["width", "height"][t],
				n = ["clientWidth", "clientHeight"][t],
				r = ["paddingLeft", "paddingTop"][t],
				a = ["paddingRight", "paddingBottom"][t];
			if (null != e[i] && "auto" !== e[i]) return parseFloat(e[i]);
			var o = this.root,
				s = document.defaultView.getComputedStyle(o);
			return (o[n] || An(s[i]) || An(o.style[i])) - (An(s[r]) || 0) - (An(s[a]) || 0) | 0
		},
		pathToImage: function(t, e) {
			e = e || this.dpr;
			var i = document.createElement("canvas"),
				n = i.getContext("2d"),
				r = t.getBoundingRect(),
				a = t.style,
				o = a.shadowBlur * e,
				s = a.shadowOffsetX * e,
				l = a.shadowOffsetY * e,
				u = a.hasStroke() ? a.lineWidth : 0,
				h = Math.max(u / 2, -s + o),
				c = Math.max(u / 2, s + o),
				d = Math.max(u / 2, -l + o),
				f = Math.max(u / 2, l + o),
				p = r.width + h + c,
				g = r.height + d + f;
			i.width = p * e, i.height = g * e, n.scale(e, e), n.clearRect(0, 0, p, g), n.dpr = e;
			var v = {
				position: t.position,
				rotation: t.rotation,
				scale: t.scale
			};
			t.position = [h - r.x, d - r.y], t.rotation = 0, t.scale = [1, 1], t.updateTransform(), t && t.brush(n);
			var m = kn,
				y = new m({
					style: {
						x: 0,
						y: 0,
						image: i
					}
				});
			return null != v.position && (y.position = t.position = v.position), null != v.rotation && (y.rotation = t.rotation = v.rotation), null != v.scale && (y.scale = t.scale = v.scale), y
		}
	};
	var Ov = function(t) {
		t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function() {}, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, ng.call(this)
	};
	Ov.prototype = {
		constructor: Ov,
		addClip: function(t) {
			this._clips.push(t)
		},
		addAnimator: function(t) {
			t.animation = this;
			for (var e = t.getClips(), i = 0; i < e.length; i++) this.addClip(e[i])
		},
		removeClip: function(t) {
			var e = u(this._clips, t);
			e >= 0 && this._clips.splice(e, 1)
		},
		removeAnimator: function(t) {
			for (var e = t.getClips(), i = 0; i < e.length; i++) this.removeClip(e[i]);
			t.animation = null
		},
		_update: function() {
			for (var t = (new Date).getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, r = [], a = [], o = 0; n > o; o++) {
				var s = i[o],
					l = s.step(t, e);
				l && (r.push(l), a.push(s))
			}
			for (var o = 0; n > o;) i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++;
			n = r.length;
			for (var o = 0; n > o; o++) a[o].fire(r[o]);
			this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update()
		},
		_startLoop: function() {
			function t() {
				e._running && (hv(t), !e._paused && e._update())
			}
			var e = this;
			this._running = !0, hv(t)
		},
		start: function() {
			this._time = (new Date).getTime(), this._pausedTime = 0, this._startLoop()
		},
		stop: function() {
			this._running = !1
		},
		pause: function() {
			this._paused || (this._pauseStart = (new Date).getTime(), this._paused = !0)
		},
		resume: function() {
			this._paused && (this._pausedTime += (new Date).getTime() - this._pauseStart, this._paused = !1)
		},
		clear: function() {
			this._clips = []
		},
		isFinished: function() {
			return !this._clips.length
		},
		animate: function(t, e) {
			e = e || {};
			var i = new Ng(t, e.loop, e.getter, e.setter);
			return this.addAnimator(i), i
		}
	}, c(Ov, ng);
	var Ev = 300,
		zv = zp.domSupported,
		Bv = function() {
			var t = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
				e = ["touchstart", "touchend", "touchmove"],
				i = {
					pointerdown: 1,
					pointerup: 1,
					pointermove: 1,
					pointerout: 1
				},
				n = p(t, function(t) {
					var e = t.replace("mouse", "pointer");
					return i.hasOwnProperty(e) ? e : t
				});
			return {
				mouse: t,
				touch: e,
				pointer: n
			}
		}(),
		Rv = {
			mouse: ["mousemove", "mouseup"],
			pointer: ["pointermove", "pointerup"]
		},
		Nv = Wn.prototype;
	Nv.stopPropagation = Nv.stopImmediatePropagation = Nv.preventDefault = V;
	var Fv = {
		mousedown: function(t) {
			t = be(this.dom, t), this._mayPointerCapture = [t.zrX, t.zrY], this.trigger("mousedown", t)
		},
		mousemove: function(t) {
			t = be(this.dom, t);
			var e = this._mayPointerCapture;
			!e || t.zrX === e[0] && t.zrY === e[1] || Yn(this, !0), this.trigger("mousemove", t)
		},
		mouseup: function(t) {
			t = be(this.dom, t), Yn(this, !1), this.trigger("mouseup", t)
		},
		mouseout: function(t) {
			t = be(this.dom, t), this._pointerCapturing && (t.zrEventControl = "no_globalout");
			var e = t.toElement || t.relatedTarget;
			t.zrIsToLocalDOM = Hn(this, e), this.trigger("mouseout", t)
		},
		touchstart: function(t) {
			t = be(this.dom, t), Fn(t), this._lastTouchMoment = new Date, this.handler.processGesture(t, "start"), Fv.mousemove.call(this, t), Fv.mousedown.call(this, t)
		},
		touchmove: function(t) {
			t = be(this.dom, t), Fn(t), this.handler.processGesture(t, "change"), Fv.mousemove.call(this, t)
		},
		touchend: function(t) {
			t = be(this.dom, t), Fn(t), this.handler.processGesture(t, "end"), Fv.mouseup.call(this, t), +new Date - this._lastTouchMoment < Ev && Fv.click.call(this, t)
		},
		pointerdown: function(t) {
			Fv.mousedown.call(this, t)
		},
		pointermove: function(t) {
			Rn(t) || Fv.mousemove.call(this, t)
		},
		pointerup: function(t) {
			Fv.mouseup.call(this, t)
		},
		pointerout: function(t) {
			Rn(t) || Fv.mouseout.call(this, t)
		}
	};
	f(["click", "mousewheel", "dblclick", "contextmenu"], function(t) {
		Fv[t] = function(e) {
			e = be(this.dom, e), this.trigger(t, e)
		}
	});
	var Vv = {
			pointermove: function(t) {
				Rn(t) || Vv.mousemove.call(this, t)
			},
			pointerup: function(t) {
				Vv.mouseup.call(this, t)
			},
			mousemove: function(t) {
				this.trigger("mousemove", t)
			},
			mouseup: function(t) {
				var e = this._pointerCapturing;
				Yn(this, !1), this.trigger("mouseup", t), e && (t.zrEventControl = "only_globalout", this.trigger("mouseout", t))
			}
		},
		Hv = Zn.prototype;
	Hv.dispose = function() {
		jn(this._localHandlerScope), zv && jn(this._globalHandlerScope)
	}, Hv.setCursor = function(t) {
		this.dom.style && (this.dom.style.cursor = t || "default")
	}, c(Zn, ng);
	var Wv = !zp.canvasSupported,
		Gv = {
			canvas: Lv
		},
		Uv = {},
		Xv = "4.3.2",
		jv = function(t, e, i) {
			i = i || {}, this.dom = e, this.id = t;
			var n = this,
				r = new Qg,
				a = i.renderer;
			if (Wv) {
				if (!Gv.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");
				a = "vml"
			} else a && Gv[a] || (a = "canvas");
			var o = new Gv[a](e, r, i, t);
			this.storage = r, this.painter = o;
			var s = zp.node || zp.worker ? null : new Zn(o.getViewportRoot(), o.root);
			this.handler = new gg(r, o, s, o.root), this.animation = new Ov({
				stage: {
					update: y(this.flush, this)
				}
			}), this.animation.start(), this._needsRefresh;
			var l = r.delFromStorage,
				u = r.addToStorage;
			r.delFromStorage = function(t) {
				l.call(r, t), t && t.removeSelfFromZr(n)
			}, r.addToStorage = function(t) {
				u.call(r, t), t.addSelfToZr(n)
			}
		};
	jv.prototype = {
		constructor: jv,
		getId: function() {
			return this.id
		},
		add: function(t) {
			this.storage.addRoot(t), this._needsRefresh = !0
		},
		remove: function(t) {
			this.storage.delRoot(t), this._needsRefresh = !0
		},
		configLayer: function(t, e) {
			this.painter.configLayer && this.painter.configLayer(t, e), this._needsRefresh = !0
		},
		setBackgroundColor: function(t) {
			this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this._needsRefresh = !0
		},
		refreshImmediately: function() {
			this._needsRefresh = this._needsRefreshHover = !1, this.painter.refresh(), this._needsRefresh = this._needsRefreshHover = !1
		},
		refresh: function() {
			this._needsRefresh = !0
		},
		flush: function() {
			var t;
			this._needsRefresh && (t = !0, this.refreshImmediately()), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately()), t && this.trigger("rendered")
		},
		addHover: function(t, e) {
			if (this.painter.addHover) {
				var i = this.painter.addHover(t, e);
				return this.refreshHover(), i
			}
		},
		removeHover: function(t) {
			this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover())
		},
		clearHover: function() {
			this.painter.clearHover && (this.painter.clearHover(), this.refreshHover())
		},
		refreshHover: function() {
			this._needsRefreshHover = !0
		},
		refreshHoverImmediately: function() {
			this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover()
		},
		resize: function(t) {
			t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize()
		},
		clearAnimation: function() {
			this.animation.clear()
		},
		getWidth: function() {
			return this.painter.getWidth()
		},
		getHeight: function() {
			return this.painter.getHeight()
		},
		pathToImage: function(t, e) {
			return this.painter.pathToImage(t, e)
		},
		setCursorStyle: function(t) {
			this.handler.setCursorStyle(t)
		},
		findHover: function(t, e) {
			return this.handler.findHover(t, e)
		},
		on: function(t, e, i) {
			this.handler.on(t, e, i)
		},
		off: function(t, e) {
			this.handler.off(t, e)
		},
		trigger: function(t, e) {
			this.handler.trigger(t, e)
		},
		clear: function() {
			this.storage.delRoot(), this.painter.clear()
		},
		dispose: function() {
			this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, tr(this.id)
		}
	};
	var Yv = (Object.freeze || Object)({
			version: Xv,
			init: Kn,
			dispose: $n,
			getInstance: Qn,
			registerPainter: Jn
		}),
		qv = f,
		Zv = S,
		Kv = x,
		$v = "series\x00",
		Qv = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"],
		Jv = 0,
		tm = ".",
		em = "___EC__COMPONENT__CONTAINER___",
		im = 0,
		nm = function(t) {
			for (var e = 0; e < t.length; e++) t[e][1] || (t[e][1] = t[e][0]);
			return function(e, i, n) {
				for (var r = {}, a = 0; a < t.length; a++) {
					var o = t[a][1];
					if (!(i && u(i, o) >= 0 || n && u(n, o) < 0)) {
						var s = e.getShallow(o);
						null != s && (r[t[a][0]] = s)
					}
				}
				return r
			}
		},
		rm = nm([
			["lineWidth", "width"],
			["stroke", "color"],
			["opacity"],
			["shadowBlur"],
			["shadowOffsetX"],
			["shadowOffsetY"],
			["shadowColor"]
		]),
		am = {
			getLineStyle: function(t) {
				var e = rm(this, t);
				return e.lineDash = this.getLineDash(e.lineWidth), e
			},
			getLineDash: function(t) {
				null == t && (t = 1);
				var e = this.get("type"),
					i = Math.max(t, 2),
					n = 4 * t;
				return "solid" === e || null == e ? !1 : "dashed" === e ? [n, n] : [i, i]
			}
		},
		om = nm([
			["fill", "color"],
			["shadowBlur"],
			["shadowOffsetX"],
			["shadowOffsetY"],
			["opacity"],
			["shadowColor"]
		]),
		sm = {
			getAreaStyle: function(t, e) {
				return om(this, t, e)
			}
		},
		lm = Math.pow,
		um = Math.sqrt,
		hm = 1e-8,
		cm = 1e-4,
		dm = um(3),
		fm = 1 / 3,
		pm = H(),
		gm = H(),
		vm = H(),
		mm = Math.min,
		ym = Math.max,
		_m = Math.sin,
		xm = Math.cos,
		wm = 2 * Math.PI,
		bm = H(),
		Sm = H(),
		Mm = H(),
		Im = [],
		Tm = [],
		Cm = {
			M: 1,
			L: 2,
			C: 3,
			Q: 4,
			A: 5,
			Z: 6,
			R: 7
		},
		Dm = [],
		km = [],
		Am = [],
		Pm = [],
		Lm = Math.min,
		Om = Math.max,
		Em = Math.cos,
		zm = Math.sin,
		Bm = Math.sqrt,
		Rm = Math.abs,
		Nm = "undefined" != typeof Float32Array,
		Fm = function(t) {
			this._saveData = !t, this._saveData && (this.data = []), this._ctx = null
		};
	Fm.prototype = {
		constructor: Fm,
		_xi: 0,
		_yi: 0,
		_x0: 0,
		_y0: 0,
		_ux: 0,
		_uy: 0,
		_len: 0,
		_lineDash: null,
		_dashOffset: 0,
		_dashIdx: 0,
		_dashSum: 0,
		setScale: function(t, e, i) {
			i = i || 0, this._ux = Rm(i / Hg / t) || 0, this._uy = Rm(i / Hg / e) || 0
		},
		getContext: function() {
			return this._ctx
		},
		beginPath: function(t) {
			return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), this._lineDash && (this._lineDash = null, this._dashOffset = 0), this
		},
		moveTo: function(t, e) {
			return this.addData(Cm.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this
		},
		lineTo: function(t, e) {
			var i = Rm(t - this._xi) > this._ux || Rm(e - this._yi) > this._uy || this._len < 5;
			return this.addData(Cm.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this
		},
		bezierCurveTo: function(t, e, i, n, r, a) {
			return this.addData(Cm.C, t, e, i, n, r, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, r, a) : this._ctx.bezierCurveTo(t, e, i, n, r, a)), this._xi = r, this._yi = a, this
		},
		quadraticCurveTo: function(t, e, i, n) {
			return this.addData(Cm.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this
		},
		arc: function(t, e, i, n, r, a) {
			return this.addData(Cm.A, t, e, i, i, n, r - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, r, a), this._xi = Em(r) * i + t, this._yi = zm(r) * i + e, this
		},
		arcTo: function(t, e, i, n, r) {
			return this._ctx && this._ctx.arcTo(t, e, i, n, r), this
		},
		rect: function(t, e, i, n) {
			return this._ctx && this._ctx.rect(t, e, i, n), this.addData(Cm.R, t, e, i, n), this
		},
		closePath: function() {
			this.addData(Cm.Z);
			var t = this._ctx,
				e = this._x0,
				i = this._y0;
			return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this
		},
		fill: function(t) {
			t && t.fill(), this.toStatic()
		},
		stroke: function(t) {
			t && t.stroke(), this.toStatic()
		},
		setLineDash: function(t) {
			if (t instanceof Array) {
				this._lineDash = t, this._dashIdx = 0;
				for (var e = 0, i = 0; i < t.length; i++) e += t[i];
				this._dashSum = e
			}
			return this
		},
		setLineDashOffset: function(t) {
			return this._dashOffset = t, this
		},
		len: function() {
			return this._len
		},
		setData: function(t) {
			var e = t.length;
			this.data && this.data.length === e || !Nm || (this.data = new Float32Array(e));
			for (var i = 0; e > i; i++) this.data[i] = t[i];
			this._len = e
		},
		appendPath: function(t) {
			t instanceof Array || (t = [t]);
			for (var e = t.length, i = 0, n = this._len, r = 0; e > r; r++) i += t[r].len();
			Nm && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
			for (var r = 0; e > r; r++)
				for (var a = t[r].data, o = 0; o < a.length; o++) this.data[n++] = a[o];
			this._len = n
		},
		addData: function(t) {
			if (this._saveData) {
				var e = this.data;
				this._len + arguments.length > e.length && (this._expandData(), e = this.data);
				for (var i = 0; i < arguments.length; i++) e[this._len++] = arguments[i];
				this._prevCmd = t
			}
		},
		_expandData: function() {
			if (!(this.data instanceof Array)) {
				for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
				this.data = t
			}
		},
		_needsDash: function() {
			return this._lineDash
		},
		_dashedLineTo: function(t, e) {
			var i, n, r = this._dashSum,
				a = this._dashOffset,
				o = this._lineDash,
				s = this._ctx,
				l = this._xi,
				u = this._yi,
				h = t - l,
				c = e - u,
				d = Bm(h * h + c * c),
				f = l,
				p = u,
				g = o.length;
			for (h /= d, c /= d, 0 > a && (a = r + a), a %= r, f -= a * h, p -= a * c; h > 0 && t >= f || 0 > h && f >= t || 0 === h && (c > 0 && e >= p || 0 > c && p >= e);) n = this._dashIdx, i = o[n], f += h * i, p += c * i, this._dashIdx = (n + 1) % g, h > 0 && l > f || 0 > h && f > l || c > 0 && u > p || 0 > c && p > u || s[n % 2 ? "moveTo" : "lineTo"](h >= 0 ? Lm(f, t) : Om(f, t), c >= 0 ? Lm(p, e) : Om(p, e));
			h = f - t, c = p - e, this._dashOffset = -Bm(h * h + c * c)
		},
		_dashedBezierTo: function(t, e, i, n, r, a) {
			var o, s, l, u, h, c = this._dashSum,
				d = this._dashOffset,
				f = this._lineDash,
				p = this._ctx,
				g = this._xi,
				v = this._yi,
				m = Ir,
				y = 0,
				_ = this._dashIdx,
				x = f.length,
				w = 0;
			for (0 > d && (d = c + d), d %= c, o = 0; 1 > o; o += .1) s = m(g, t, i, r, o + .1) - m(g, t, i, r, o), l = m(v, e, n, a, o + .1) - m(v, e, n, a, o), y += Bm(s * s + l * l);
			for (; x > _ && (w += f[_], !(w > d)); _++);
			for (o = (w - d) / y; 1 >= o;) u = m(g, t, i, r, o), h = m(v, e, n, a, o), _ % 2 ? p.moveTo(u, h) : p.lineTo(u, h), o += f[_] / y, _ = (_ + 1) % x;
			_ % 2 !== 0 && p.lineTo(r, a), s = r - u, l = a - h, this._dashOffset = -Bm(s * s + l * l)
		},
		_dashedQuadraticTo: function(t, e, i, n) {
			var r = i,
				a = n;
			i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, r, a)
		},
		toStatic: function() {
			var t = this.data;
			t instanceof Array && (t.length = this._len, Nm && (this.data = new Float32Array(t)))
		},
		getBoundingRect: function() {
			Dm[0] = Dm[1] = Am[0] = Am[1] = Number.MAX_VALUE, km[0] = km[1] = Pm[0] = Pm[1] = -Number.MAX_VALUE;
			for (var t = this.data, e = 0, i = 0, n = 0, r = 0, a = 0; a < t.length;) {
				var o = t[a++];
				switch (1 === a && (e = t[a], i = t[a + 1], n = e, r = i), o) {
					case Cm.M:
						n = t[a++], r = t[a++], e = n, i = r, Am[0] = n, Am[1] = r, Pm[0] = n, Pm[1] = r;
						break;
					case Cm.L:
						Nr(e, i, t[a], t[a + 1], Am, Pm), e = t[a++], i = t[a++];
						break;
					case Cm.C:
						Fr(e, i, t[a++], t[a++], t[a++], t[a++], t[a], t[a + 1], Am, Pm), e = t[a++], i = t[a++];
						break;
					case Cm.Q:
						Vr(e, i, t[a++], t[a++], t[a], t[a + 1], Am, Pm), e = t[a++], i = t[a++];
						break;
					case Cm.A:
						var s = t[a++],
							l = t[a++],
							u = t[a++],
							h = t[a++],
							c = t[a++],
							d = t[a++] + c;
						a += 1;
						var f = 1 - t[a++];
						1 === a && (n = Em(c) * u + s, r = zm(c) * h + l), Hr(s, l, u, h, c, d, f, Am, Pm), e = Em(d) * u + s, i = zm(d) * h + l;
						break;
					case Cm.R:
						n = e = t[a++], r = i = t[a++];
						var p = t[a++],
							g = t[a++];
						Nr(n, r, n + p, r + g, Am, Pm);
						break;
					case Cm.Z:
						e = n, i = r
				}
				oe(Dm, Dm, Am), se(km, km, Pm)
			}
			return 0 === a && (Dm[0] = Dm[1] = km[0] = km[1] = 0), new Ti(Dm[0], Dm[1], km[0] - Dm[0], km[1] - Dm[1])
		},
		rebuildPath: function(t) {
			for (var e, i, n, r, a, o, s = this.data, l = this._ux, u = this._uy, h = this._len, c = 0; h > c;) {
				var d = s[c++];
				switch (1 === c && (n = s[c], r = s[c + 1], e = n, i = r), d) {
					case Cm.M:
						e = n = s[c++], i = r = s[c++], t.moveTo(n, r);
						break;
					case Cm.L:
						a = s[c++], o = s[c++], (Rm(a - n) > l || Rm(o - r) > u || c === h - 1) && (t.lineTo(a, o), n = a, r = o);
						break;
					case Cm.C:
						t.bezierCurveTo(s[c++], s[c++], s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], r = s[c - 1];
						break;
					case Cm.Q:
						t.quadraticCurveTo(s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], r = s[c - 1];
						break;
					case Cm.A:
						var f = s[c++],
							p = s[c++],
							g = s[c++],
							v = s[c++],
							m = s[c++],
							y = s[c++],
							_ = s[c++],
							x = s[c++],
							w = g > v ? g : v,
							b = g > v ? 1 : g / v,
							S = g > v ? v / g : 1,
							M = Math.abs(g - v) > .001,
							I = m + y;
						M ? (t.translate(f, p), t.rotate(_), t.scale(b, S), t.arc(0, 0, w, m, I, 1 - x), t.scale(1 / b, 1 / S), t.rotate(-_), t.translate(-f, -p)) : t.arc(f, p, w, m, I, 1 - x), 1 === c && (e = Em(m) * g + f, i = zm(m) * v + p), n = Em(I) * g + f, r = zm(I) * v + p;
						break;
					case Cm.R:
						e = n = s[c], i = r = s[c + 1], t.rect(s[c++], s[c++], s[c++], s[c++]);
						break;
					case Cm.Z:
						t.closePath(), n = e, r = i
				}
			}
		}
	}, Fm.CMD = Cm;
	var Vm = 2 * Math.PI,
		Hm = 2 * Math.PI,
		Wm = Fm.CMD,
		Gm = 2 * Math.PI,
		Um = 1e-4,
		Xm = [-1, -1, -1],
		jm = [-1, -1],
		Ym = lv.prototype.getCanvasPattern,
		qm = Math.abs,
		Zm = new Fm(!0);
	ia.prototype = {
		constructor: ia,
		type: "path",
		__dirtyPath: !0,
		strokeContainThreshold: 5,
		segmentIgnoreThreshold: 0,
		subPixelOptimize: !1,
		brush: function(t, e) {
			var i = this.style,
				n = this.path || Zm,
				r = i.hasStroke(),
				a = i.hasFill(),
				o = i.fill,
				s = i.stroke,
				l = a && !!o.colorStops,
				u = r && !!s.colorStops,
				h = a && !!o.image,
				c = r && !!s.image;
			if (i.bind(t, this, e), this.setTransform(t), this.__dirty) {
				var d;
				l && (d = d || this.getBoundingRect(), this._fillGradient = i.getGradient(t, o, d)), u && (d = d || this.getBoundingRect(), this._strokeGradient = i.getGradient(t, s, d))
			}
			l ? t.fillStyle = this._fillGradient : h && (t.fillStyle = Ym.call(o, t)), u ? t.strokeStyle = this._strokeGradient : c && (t.strokeStyle = Ym.call(s, t));
			var f = i.lineDash,
				p = i.lineDashOffset,
				g = !!t.setLineDash,
				v = this.getGlobalScale();
			if (n.setScale(v[0], v[1], this.segmentIgnoreThreshold), this.__dirtyPath || f && !g && r ? (n.beginPath(t), f && !g && (n.setLineDash(f), n.setLineDashOffset(p)), this.buildPath(n, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), this.path.rebuildPath(t)), a)
				if (null != i.fillOpacity) {
					var m = t.globalAlpha;
					t.globalAlpha = i.fillOpacity * i.opacity, n.fill(t), t.globalAlpha = m
				} else n.fill(t);
			if (f && g && (t.setLineDash(f), t.lineDashOffset = p), r)
				if (null != i.strokeOpacity) {
					var m = t.globalAlpha;
					t.globalAlpha = i.strokeOpacity * i.opacity, n.stroke(t), t.globalAlpha = m
				} else n.stroke(t);
			f && g && t.setLineDash([]), null != i.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect()))
		},
		buildPath: function() {},
		createPathProxy: function() {
			this.path = new Fm
		},
		getBoundingRect: function() {
			var t = this._rect,
				e = this.style,
				i = !t;
			if (i) {
				var n = this.path;
				n || (n = this.path = new Fm), this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n.getBoundingRect()
			}
			if (this._rect = t, e.hasStroke()) {
				var r = this._rectWithStroke || (this._rectWithStroke = t.clone());
				if (this.__dirty || i) {
					r.copy(t);
					var a = e.lineWidth,
						o = e.strokeNoScale ? this.getLineScale() : 1;
					e.hasFill() || (a = Math.max(a, this.strokeContainThreshold || 4)), o > 1e-10 && (r.width += a / o, r.height += a / o, r.x -= a / o / 2, r.y -= a / o / 2)
				}
				return r
			}
			return t
		},
		contain: function(t, e) {
			var i = this.transformCoordToLocal(t, e),
				n = this.getBoundingRect(),
				r = this.style;
			if (t = i[0], e = i[1], n.contain(t, e)) {
				var a = this.path.data;
				if (r.hasStroke()) {
					var o = r.lineWidth,
						s = r.strokeNoScale ? this.getLineScale() : 1;
					if (s > 1e-10 && (r.hasFill() || (o = Math.max(o, this.strokeContainThreshold)), ea(a, o / s, t, e))) return !0
				}
				if (r.hasFill()) return ta(a, t, e)
			}
			return !1
		},
		dirty: function(t) {
			null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = this.__dirtyText = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty()
		},
		animateShape: function(t) {
			return this.animate("shape", t)
		},
		attrKV: function(t, e) {
			"shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : Dn.prototype.attrKV.call(this, t, e)
		},
		setShape: function(t, e) {
			var i = this.shape;
			if (i) {
				if (S(t))
					for (var n in t) t.hasOwnProperty(n) && (i[n] = t[n]);
				else i[t] = e;
				this.dirty(!0)
			}
			return this
		},
		getLineScale: function() {
			var t = this.transform;
			return t && qm(t[0] - 1) > 1e-10 && qm(t[3] - 1) > 1e-10 ? Math.sqrt(qm(t[0] * t[3] - t[2] * t[1])) : 1
		}
	}, ia.extend = function(t) {
		var e = function(e) {
			ia.call(this, e), t.style && this.style.extendFrom(t.style, !1);
			var i = t.shape;
			if (i) {
				this.shape = this.shape || {};
				var n = this.shape;
				for (var r in i) !n.hasOwnProperty(r) && i.hasOwnProperty(r) && (n[r] = i[r])
			}
			t.init && t.init.call(this, e)
		};
		h(e, ia);
		for (var i in t) "style" !== i && "shape" !== i && (e.prototype[i] = t[i]);
		return e
	}, h(ia, Dn);
	var Km = Fm.CMD,
		$m = [
			[],
			[],
			[]
		],
		Qm = Math.sqrt,
		Jm = Math.atan2,
		ty = function(t, e) {
			var i, n, r, a, o, s, l = t.data,
				u = Km.M,
				h = Km.C,
				c = Km.L,
				d = Km.R,
				f = Km.A,
				p = Km.Q;
			for (r = 0, a = 0; r < l.length;) {
				switch (i = l[r++], a = r, n = 0, i) {
					case u:
						n = 1;
						break;
					case c:
						n = 1;
						break;
					case h:
						n = 3;
						break;
					case p:
						n = 2;
						break;
					case f:
						var g = e[4],
							v = e[5],
							m = Qm(e[0] * e[0] + e[1] * e[1]),
							y = Qm(e[2] * e[2] + e[3] * e[3]),
							_ = Jm(-e[1] / y, e[0] / m);
						l[r] *= m, l[r++] += g, l[r] *= y, l[r++] += v, l[r++] *= m, l[r++] *= y, l[r++] += _, l[r++] += _, r += 2, a = r;
						break;
					case d:
						s[0] = l[r++], s[1] = l[r++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1], s[0] += l[r++], s[1] += l[r++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1]
				}
				for (o = 0; n > o; o++) {
					var s = $m[o];
					s[0] = l[r++], s[1] = l[r++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1]
				}
			}
		},
		ey = Math.sqrt,
		iy = Math.sin,
		ny = Math.cos,
		ry = Math.PI,
		ay = function(t) {
			return Math.sqrt(t[0] * t[0] + t[1] * t[1])
		},
		oy = function(t, e) {
			return (t[0] * e[0] + t[1] * e[1]) / (ay(t) * ay(e))
		},
		sy = function(t, e) {
			return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(oy(t, e))
		},
		ly = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi,
		uy = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g,
		hy = function(t) {
			Dn.call(this, t)
		};
	hy.prototype = {
		constructor: hy,
		type: "text",
		brush: function(t, e) {
			var i = this.style;
			this.__dirty && hn(i, !0), i.fill = i.stroke = i.shadowBlur = i.shadowColor = i.shadowOffsetX = i.shadowOffsetY = null;
			var n = i.text;
			return null != n && (n += ""), Cn(n, i) ? (this.setTransform(t), dn(this, t, n, i, null, e), void this.restoreTransform(t)) : void(t.__attrCachedBy = ev.NONE)
		},
		getBoundingRect: function() {
			var t = this.style;
			if (this.__dirty && hn(t, !0), !this._rect) {
				var e = t.text;
				null != e ? e += "" : e = "";
				var i = ji(t.text + "", t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich);
				if (i.x += t.x || 0, i.y += t.y || 0, Sn(t.textStroke, t.textStrokeWidth)) {
					var n = t.textStrokeWidth;
					i.x -= n / 2, i.y -= n / 2, i.width += n, i.height += n
				}
				this._rect = i
			}
			return this._rect
		}
	}, h(hy, Dn);
	var cy = ia.extend({
			type: "circle",
			shape: {
				cx: 0,
				cy: 0,
				r: 0
			},
			buildPath: function(t, e, i) {
				i && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
			}
		}),
		dy = [
			["shadowBlur", 0],
			["shadowColor", "#000"],
			["shadowOffsetX", 0],
			["shadowOffsetY", 0]
		],
		fy = function(t) {
			return zp.browser.ie && zp.browser.version >= 11 ? function() {
				var e, i = this.__clipPaths,
					n = this.style;
				if (i)
					for (var r = 0; r < i.length; r++) {
						var a = i[r],
							o = a && a.shape,
							s = a && a.type;
						if (o && ("sector" === s && o.startAngle === o.endAngle || "rect" === s && (!o.width || !o.height))) {
							for (var l = 0; l < dy.length; l++) dy[l][2] = n[dy[l][0]], n[dy[l][0]] = dy[l][1];
							e = !0;
							break
						}
					}
				if (t.apply(this, arguments), e)
					for (var l = 0; l < dy.length; l++) n[dy[l][0]] = dy[l][2]
			} : t
		},
		py = ia.extend({
			type: "sector",
			shape: {
				cx: 0,
				cy: 0,
				r0: 0,
				r: 0,
				startAngle: 0,
				endAngle: 2 * Math.PI,
				clockwise: !0
			},
			brush: fy(ia.prototype.brush),
			buildPath: function(t, e) {
				var i = e.cx,
					n = e.cy,
					r = Math.max(e.r0 || 0, 0),
					a = Math.max(e.r, 0),
					o = e.startAngle,
					s = e.endAngle,
					l = e.clockwise,
					u = Math.cos(o),
					h = Math.sin(o);
				t.moveTo(u * r + i, h * r + n), t.lineTo(u * a + i, h * a + n), t.arc(i, n, a, o, s, !l), t.lineTo(Math.cos(s) * r + i, Math.sin(s) * r + n), 0 !== r && t.arc(i, n, r, s, o, l), t.closePath()
			}
		}),
		gy = ia.extend({
			type: "ring",
			shape: {
				cx: 0,
				cy: 0,
				r: 0,
				r0: 0
			},
			buildPath: function(t, e) {
				var i = e.cx,
					n = e.cy,
					r = 2 * Math.PI;
				t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, r, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, r, !0)
			}
		}),
		vy = function(t, e) {
			for (var i = t.length, n = [], r = 0, a = 1; i > a; a++) r += ee(t[a - 1], t[a]);
			var o = r / 2;
			o = i > o ? i : o;
			for (var a = 0; o > a; a++) {
				var s, l, u, h = a / (o - 1) * (e ? i : i - 1),
					c = Math.floor(h),
					d = h - c,
					f = t[c % i];
				e ? (s = t[(c - 1 + i) % i], l = t[(c + 1) % i], u = t[(c + 2) % i]) : (s = t[0 === c ? c : c - 1], l = t[c > i - 2 ? i - 1 : c + 1], u = t[c > i - 3 ? i - 1 : c + 2]);
				var p = d * d,
					g = d * p;
				n.push([ua(s[0], f[0], l[0], u[0], d, p, g), ua(s[1], f[1], l[1], u[1], d, p, g)])
			}
			return n
		},
		my = function(t, e, i, n) {
			var r, a, o, s, l = [],
				u = [],
				h = [],
				c = [];
			if (n) {
				o = [1 / 0, 1 / 0], s = [-1 / 0, -1 / 0];
				for (var d = 0, f = t.length; f > d; d++) oe(o, o, t[d]), se(s, s, t[d]);
				oe(o, o, n[0]), se(s, s, n[1])
			}
			for (var d = 0, f = t.length; f > d; d++) {
				var p = t[d];
				if (i) r = t[d ? d - 1 : f - 1], a = t[(d + 1) % f];
				else {
					if (0 === d || d === f - 1) {
						l.push(G(t[d]));
						continue
					}
					r = t[d - 1], a = t[d + 1]
				}
				Y(u, a, r), J(u, u, e);
				var g = ee(p, r),
					v = ee(p, a),
					m = g + v;
				0 !== m && (g /= m, v /= m), J(h, u, -g), J(c, u, v);
				var y = X([], p, h),
					_ = X([], p, c);
				n && (se(y, y, o), oe(y, y, s), se(_, _, o), oe(_, _, s)), l.push(y), l.push(_)
			}
			return i && l.push(l.shift()), l
		},
		yy = ia.extend({
			type: "polygon",
			shape: {
				points: null,
				smooth: !1,
				smoothConstraint: null
			},
			buildPath: function(t, e) {
				ha(t, e, !0)
			}
		}),
		_y = ia.extend({
			type: "polyline",
			shape: {
				points: null,
				smooth: !1,
				smoothConstraint: null
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				ha(t, e, !1)
			}
		}),
		xy = Math.round,
		wy = {},
		by = ia.extend({
			type: "rect",
			shape: {
				r: 0,
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var i, n, r, a;
				this.subPixelOptimize ? (da(wy, e, this.style), i = wy.x, n = wy.y, r = wy.width, a = wy.height, wy.r = e.r, e = wy) : (i = e.x, n = e.y, r = e.width, a = e.height), e.r ? un(t, e) : t.rect(i, n, r, a), t.closePath()
			}
		}),
		Sy = {},
		My = ia.extend({
			type: "line",
			shape: {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				percent: 1
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				var i, n, r, a;
				this.subPixelOptimize ? (ca(Sy, e, this.style), i = Sy.x1, n = Sy.y1, r = Sy.x2, a = Sy.y2) : (i = e.x1, n = e.y1, r = e.x2, a = e.y2);
				var o = e.percent;
				0 !== o && (t.moveTo(i, n), 1 > o && (r = i * (1 - o) + r * o, a = n * (1 - o) + a * o), t.lineTo(r, a))
			},
			pointAt: function(t) {
				var e = this.shape;
				return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
			}
		}),
		Iy = [],
		Ty = ia.extend({
			type: "bezier-curve",
			shape: {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				cpx1: 0,
				cpy1: 0,
				percent: 1
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				var i = e.x1,
					n = e.y1,
					r = e.x2,
					a = e.y2,
					o = e.cpx1,
					s = e.cpy1,
					l = e.cpx2,
					u = e.cpy2,
					h = e.percent;
				0 !== h && (t.moveTo(i, n), null == l || null == u ? (1 > h && (zr(i, o, r, h, Iy), o = Iy[1], r = Iy[2], zr(n, s, a, h, Iy), s = Iy[1], a = Iy[2]), t.quadraticCurveTo(o, s, r, a)) : (1 > h && (kr(i, o, l, r, h, Iy), o = Iy[1], l = Iy[2], r = Iy[3], kr(n, s, u, a, h, Iy), s = Iy[1], u = Iy[2], a = Iy[3]), t.bezierCurveTo(o, s, l, u, r, a)))
			},
			pointAt: function(t) {
				return pa(this.shape, t, !1)
			},
			tangentAt: function(t) {
				var e = pa(this.shape, t, !0);
				return te(e, e)
			}
		}),
		Cy = ia.extend({
			type: "arc",
			shape: {
				cx: 0,
				cy: 0,
				r: 0,
				startAngle: 0,
				endAngle: 2 * Math.PI,
				clockwise: !0
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				var i = e.cx,
					n = e.cy,
					r = Math.max(e.r, 0),
					a = e.startAngle,
					o = e.endAngle,
					s = e.clockwise,
					l = Math.cos(a),
					u = Math.sin(a);
				t.moveTo(l * r + i, u * r + n), t.arc(i, n, r, a, o, !s)
			}
		}),
		Dy = ia.extend({
			type: "compound",
			shape: {
				paths: null
			},
			_updatePathDirty: function() {
				for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e.length; i++) t = t || e[i].__dirtyPath;
				this.__dirtyPath = t, this.__dirty = this.__dirty || t
			},
			beforeBrush: function() {
				this._updatePathDirty();
				for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t.length; i++) t[i].path || t[i].createPathProxy(), t[i].path.setScale(e[0], e[1], t[i].segmentIgnoreThreshold)
			},
			buildPath: function(t, e) {
				for (var i = e.paths || [], n = 0; n < i.length; n++) i[n].buildPath(t, i[n].shape, !0)
			},
			afterBrush: function() {
				for (var t = this.shape.paths || [], e = 0; e < t.length; e++) t[e].__dirtyPath = !1
			},
			getBoundingRect: function() {
				return this._updatePathDirty(), ia.prototype.getBoundingRect.call(this)
			}
		}),
		ky = function(t) {
			this.colorStops = t || []
		};
	ky.prototype = {
		constructor: ky,
		addColorStop: function(t, e) {
			this.colorStops.push({
				offset: t,
				color: e
			})
		}
	};
	var Ay = function(t, e, i, n, r, a) {
		this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == i ? 1 : i, this.y2 = null == n ? 0 : n, this.type = "linear", this.global = a || !1, ky.call(this, r)
	};
	Ay.prototype = {
		constructor: Ay
	}, h(Ay, ky);
	var Py = function(t, e, i, n, r) {
		this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == i ? .5 : i, this.type = "radial", this.global = r || !1, ky.call(this, n)
	};
	Py.prototype = {
		constructor: Py
	}, h(Py, ky), ga.prototype.incremental = !0, ga.prototype.clearDisplaybles = function() {
		this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.dirty(), this.notClear = !1
	}, ga.prototype.addDisplayable = function(t, e) {
		e ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.dirty()
	}, ga.prototype.addDisplayables = function(t, e) {
		e = e || !1;
		for (var i = 0; i < t.length; i++) this.addDisplayable(t[i], e)
	}, ga.prototype.eachPendingDisplayable = function(t) {
		for (var e = this._cursor; e < this._displayables.length; e++) t && t(this._displayables[e]);
		for (var e = 0; e < this._temporaryDisplayables.length; e++) t && t(this._temporaryDisplayables[e])
	}, ga.prototype.update = function() {
		this.updateTransform();
		for (var t = this._cursor; t < this._displayables.length; t++) {
			var e = this._displayables[t];
			e.parent = this, e.update(), e.parent = null
		}
		for (var t = 0; t < this._temporaryDisplayables.length; t++) {
			var e = this._temporaryDisplayables[t];
			e.parent = this, e.update(), e.parent = null
		}
	}, ga.prototype.brush = function(t) {
		for (var e = this._cursor; e < this._displayables.length; e++) {
			var i = this._displayables[e];
			i.beforeBrush && i.beforeBrush(t), i.brush(t, e === this._cursor ? null : this._displayables[e - 1]), i.afterBrush && i.afterBrush(t)
		}
		this._cursor = e;
		for (var e = 0; e < this._temporaryDisplayables.length; e++) {
			var i = this._temporaryDisplayables[e];
			i.beforeBrush && i.beforeBrush(t), i.brush(t, 0 === e ? null : this._temporaryDisplayables[e - 1]), i.afterBrush && i.afterBrush(t)
		}
		this._temporaryDisplayables = [], this.notClear = !0
	};
	var Ly = [];
	ga.prototype.getBoundingRect = function() {
		if (!this._rect) {
			for (var t = new Ti(1 / 0, 1 / 0, -1 / 0, -1 / 0), e = 0; e < this._displayables.length; e++) {
				var i = this._displayables[e],
					n = i.getBoundingRect().clone();
				i.needLocalTransform() && n.applyTransform(i.getLocalTransform(Ly)), t.union(n)
			}
			this._rect = t
		}
		return this._rect
	}, ga.prototype.contain = function(t, e) {
		var i = this.transformCoordToLocal(t, e),
			n = this.getBoundingRect();
		if (n.contain(i[0], i[1]))
			for (var r = 0; r < this._displayables.length; r++) {
				var a = this._displayables[r];
				if (a.contain(t, e)) return !0
			}
		return !1
	}, h(ga, Dn);
	var Oy = Math.max,
		Ey = Math.min,
		zy = {},
		By = 1,
		Ry = {
			color: "textFill",
			textBorderColor: "textStroke",
			textBorderWidth: "textStrokeWidth"
		},
		Ny = "emphasis",
		Fy = "normal",
		Vy = 1,
		Hy = {},
		Wy = {},
		Gy = la,
		Uy = fa,
		Xy = N(),
		jy = 0;
	ya("circle", cy), ya("sector", py), ya("ring", gy), ya("polygon", yy), ya("polyline", _y), ya("rect", by), ya("line", My), ya("bezierCurve", Ty), ya("arc", Cy);
	var Yy = (Object.freeze || Object)({
			Z2_EMPHASIS_LIFT: By,
			CACHED_LABEL_STYLE_PROPERTIES: Ry,
			extendShape: va,
			extendPath: ma,
			registerShape: ya,
			getShapeClass: _a,
			makePath: xa,
			makeImage: wa,
			mergePath: Gy,
			resizePath: Sa,
			subPixelOptimizeLine: Ma,
			subPixelOptimizeRect: Ia,
			subPixelOptimize: Uy,
			setElementHoverStyle: Oa,
			setHoverStyle: Fa,
			setAsHighDownDispatcher: Va,
			isHighDownDispatcher: Ha,
			getHighlightDigit: Wa,
			setLabelStyle: Ga,
			modifyLabelStyle: Ua,
			setTextStyle: Xa,
			setText: ja,
			getFont: Ja,
			updateProps: eo,
			initProps: io,
			getTransform: no,
			applyTransform: ro,
			transformDirection: ao,
			groupTransition: oo,
			clipPointsByRect: so,
			clipRectByRect: lo,
			createIcon: uo,
			linePolygonIntersect: ho,
			lineLineIntersect: co,
			Group: Zg,
			Image: kn,
			Text: hy,
			Circle: cy,
			Sector: py,
			Ring: gy,
			Polygon: yy,
			Polyline: _y,
			Rect: by,
			Line: My,
			BezierCurve: Ty,
			Arc: Cy,
			IncrementalDisplayable: ga,
			CompoundPath: Dy,
			LinearGradient: Ay,
			RadialGradient: Py,
			BoundingRect: Ti
		}),
		qy = ["textStyle", "color"],
		Zy = {
			getTextColor: function(t) {
				var e = this.ecModel;
				return this.getShallow("color") || (!t && e ? e.get(qy) : null)
			},
			getFont: function() {
				return Ja({
					fontStyle: this.getShallow("fontStyle"),
					fontWeight: this.getShallow("fontWeight"),
					fontSize: this.getShallow("fontSize"),
					fontFamily: this.getShallow("fontFamily")
				}, this.ecModel)
			},
			getTextRect: function(t) {
				return ji(t, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("lineHeight"), this.getShallow("rich"), this.getShallow("truncateText"))
			}
		},
		Ky = nm([
			["fill", "color"],
			["stroke", "borderColor"],
			["lineWidth", "borderWidth"],
			["opacity"],
			["shadowBlur"],
			["shadowOffsetX"],
			["shadowOffsetY"],
			["shadowColor"],
			["textPosition"],
			["textAlign"]
		]),
		$y = {
			getItemStyle: function(t, e) {
				var i = Ky(this, t, e),
					n = this.getBorderLineDash();
				return n && (i.lineDash = n), i
			},
			getBorderLineDash: function() {
				var t = this.get("borderType");
				return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
			}
		},
		Qy = c,
		Jy = hr();
	go.prototype = {
		constructor: go,
		init: null,
		mergeOption: function(t) {
			r(this.option, t, !0)
		},
		get: function(t, e) {
			return null == t ? this.option : vo(this.option, this.parsePath(t), !e && mo(this, t))
		},
		getShallow: function(t, e) {
			var i = this.option,
				n = null == i ? i : i[t],
				r = !e && mo(this, t);
			return null == n && r && (n = r.getShallow(t)), n
		},
		getModel: function(t, e) {
			var i, n = null == t ? this.option : vo(this.option, t = this.parsePath(t));
			return e = e || (i = mo(this, t)) && i.getModel(t), new go(n, e, this.ecModel)
		},
		isEmpty: function() {
			return null == this.option
		},
		restoreData: function() {},
		clone: function() {
			var t = this.constructor;
			return new t(n(this.option))
		},
		setReadOnly: function() {},
		parsePath: function(t) {
			return "string" == typeof t && (t = t.split(".")), t
		},
		customizeGetParent: function(t) {
			Jy(this).getParent = t
		},
		isAnimationEnabled: function() {
			if (!zp.node) {
				if (null != this.option.animation) return !!this.option.animation;
				if (this.parentModel) return this.parentModel.isAnimationEnabled()
			}
		}
	}, yr(go), _r(go), Qy(go, am), Qy(go, sm), Qy(go, Zy), Qy(go, $y);
	var t_ = 0,
		e_ = 1e-4,
		i_ = 9007199254740991,
		n_ = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/,
		r_ = (Object.freeze || Object)({
			linearMap: bo,
			parsePercent: So,
			round: Mo,
			asc: Io,
			getPrecision: To,
			getPrecisionSafe: Co,
			getPixelPrecision: Do,
			getPercentWithPrecision: ko,
			MAX_SAFE_INTEGER: i_,
			remRadian: Ao,
			isRadianAroundZero: Po,
			parseDate: Lo,
			quantity: Oo,
			quantityExponent: Eo,
			nice: zo,
			quantile: Bo,
			reformIntervals: Ro,
			isNumeric: No
		}),
		a_ = L,
		o_ = /([&<>"'])/g,
		s_ = {
			"&": "&amp;",
			"<": "&lt;",
			">": "&gt;",
			'"': "&quot;",
			"'": "&#39;"
		},
		l_ = ["a", "b", "c", "d", "e", "f", "g"],
		u_ = function(t, e) {
			return "{" + t + (null == e ? "" : e) + "}"
		},
		h_ = Qi,
		c_ = (Object.freeze || Object)({
			addCommas: Fo,
			toCamelCase: Vo,
			normalizeCssArray: a_,
			encodeHTML: Ho,
			formatTpl: Wo,
			formatTplSimple: Go,
			getTooltipMarker: Uo,
			formatTime: jo,
			capitalFirst: Yo,
			truncateText: h_,
			getTextBoundingRect: qo,
			getTextRect: Zo,
			windowOpen: Ko
		}),
		d_ = f,
		f_ = ["left", "right", "top", "bottom", "width", "height"],
		p_ = [
			["width", "left", "right"],
			["height", "top", "bottom"]
		],
		g_ = $o,
		v_ = (_($o, "vertical"), _($o, "horizontal"), {
			getBoxLayoutParams: function() {
				return {
					left: this.get("left"),
					top: this.get("top"),
					right: this.get("right"),
					bottom: this.get("bottom"),
					width: this.get("width"),
					height: this.get("height")
				}
			}
		}),
		m_ = hr(),
		y_ = go.extend({
			type: "component",
			id: "",
			name: "",
			mainType: "",
			subType: "",
			componentIndex: 0,
			defaultOption: null,
			ecModel: null,
			dependentModels: [],
			uid: null,
			layoutMode: null,
			$constructor: function(t, e, i, n) {
				go.call(this, t, e, i, n), this.uid = yo("ec_cpt_model")
			},
			init: function(t, e, i) {
				this.mergeDefaultAndTheme(t, i)
			},
			mergeDefaultAndTheme: function(t, e) {
				var i = this.layoutMode,
					n = i ? ts(t) : {},
					a = e.getTheme();
				r(t, a.get(this.mainType)), r(t, this.getDefaultOption()), i && Jo(t, n, i)
			},
			mergeOption: function(t) {
				r(this.option, t, !0);
				var e = this.layoutMode;
				e && Jo(this.option, t, e)
			},
			optionUpdated: function() {},
			getDefaultOption: function() {
				var t = m_(this);
				if (!t.defaultOption) {
					for (var e = [], i = this.constructor; i;) {
						var n = i.prototype.defaultOption;
						n && e.push(n), i = i.superClass
					}
					for (var a = {}, o = e.length - 1; o >= 0; o--) a = r(a, e[o], !0);
					t.defaultOption = a
				}
				return t.defaultOption
			},
			getReferringComponents: function(t) {
				return this.ecModel.queryComponents({
					mainType: t,
					index: this.get(t + "Index", !0),
					id: this.get(t + "Id", !0)
				})
			}
		});
	br(y_, {
		registerWhenExtend: !0
	}), _o(y_), xo(y_, is), c(y_, v_);
	var __ = "";
	"undefined" != typeof navigator && (__ = navigator.platform || "");
	var x_ = {
			color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
			gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
			textStyle: {
				fontFamily: __.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
				fontSize: 12,
				fontStyle: "normal",
				fontWeight: "normal"
			},
			blendMode: null,
			animation: "auto",
			animationDuration: 1e3,
			animationDurationUpdate: 300,
			animationEasing: "exponentialOut",
			animationEasingUpdate: "cubicOut",
			animationThreshold: 2e3,
			progressiveThreshold: 3e3,
			progressive: 400,
			hoverLayerThreshold: 3e3,
			useUTC: !1
		},
		w_ = hr(),
		b_ = {
			clearColorPalette: function() {
				w_(this).colorIdx = 0, w_(this).colorNameMap = {}
			},
			getColorFromPalette: function(t, e, i) {
				e = e || this;
				var n = w_(e),
					r = n.colorIdx || 0,
					a = n.colorNameMap = n.colorNameMap || {};
				if (a.hasOwnProperty(t)) return a[t];
				var o = er(this.get("color", !0)),
					s = this.get("colorLayer", !0),
					l = null != i && s ? ns(s, i) : o;
				if (l = l || o, l && l.length) {
					var u = l[r];
					return t && (a[t] = u), n.colorIdx = (r + 1) % l.length, u
				}
			}
		},
		S_ = "original",
		M_ = "arrayRows",
		I_ = "objectRows",
		T_ = "keyedColumns",
		C_ = "unknown",
		D_ = "typedArray",
		k_ = "column",
		A_ = "row";
	rs.seriesDataToSource = function(t) {
		return new rs({
			data: t,
			sourceFormat: I(t) ? D_ : S_,
			fromDataset: !1
		})
	}, _r(rs);
	var P_ = {
			Must: 1,
			Might: 2,
			Not: 3
		},
		L_ = hr(),
		O_ = "\x00_ec_inner",
		E_ = go.extend({
			init: function(t, e, i, n) {
				i = i || {}, this.option = null, this._theme = new go(i), this._optionManager = n
			},
			setOption: function(t, e) {
				O(!(O_ in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption(null)
			},
			resetOption: function(t) {
				var e = !1,
					i = this._optionManager;
				if (!t || "recreate" === t) {
					var n = i.mountOption("recreate" === t);
					this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(n)) : _s.call(this, n), e = !0
				}
				if (("timeline" === t || "media" === t) && this.restoreData(), !t || "recreate" === t || "timeline" === t) {
					var r = i.getTimelineOption(this);
					r && (this.mergeOption(r), e = !0)
				}
				if (!t || "recreate" === t || "media" === t) {
					var a = i.getMediaOption(this, this._api);
					a.length && f(a, function(t) {
						this.mergeOption(t, e = !0)
					}, this)
				}
				return e
			},
			mergeOption: function(t) {
				function e(e, n) {
					var r = er(t[e]),
						s = ar(a.get(e), r);
					or(s), f(s, function(t) {
						var i = t.option;
						S(i) && (t.keyInfo.mainType = e, t.keyInfo.subType = ws(e, i, t.exist))
					});
					var l = xs(a, n);
					i[e] = [], a.set(e, []), f(s, function(t, n) {
						var r = t.exist,
							s = t.option;
						if (O(S(s) || r, "Empty component definition"), s) {
							var u = y_.getClass(e, t.keyInfo.subType, !0);
							if (r && r.constructor === u) r.name = t.keyInfo.name, r.mergeOption(s, this), r.optionUpdated(s, !1);
							else {
								var h = o({
									dependentModels: l,
									componentIndex: n
								}, t.keyInfo);
								r = new u(s, this, this, h), o(r, h), r.init(s, this, this, h), r.optionUpdated(null, !0)
							}
						} else r.mergeOption({}, this), r.optionUpdated({}, !1);
						a.get(e)[n] = r, i[e][n] = r.option
					}, this), "series" === e && bs(this, a.get("series"))
				}
				var i = this.option,
					a = this._componentsMap,
					s = [];
				ss(this), f(t, function(t, e) {
					null != t && (y_.hasClass(e) ? e && s.push(e) : i[e] = null == i[e] ? n(t) : r(i[e], t, !0))
				}), y_.topologicalTravel(s, y_.getAllClassMainTypes(), e, this), this._seriesIndicesMap = N(this._seriesIndices = this._seriesIndices || [])
			},
			getOption: function() {
				var t = n(this.option);
				return f(t, function(e, i) {
					if (y_.hasClass(i)) {
						for (var e = er(e), n = e.length - 1; n >= 0; n--) lr(e[n]) && e.splice(n, 1);
						t[i] = e
					}
				}), delete t[O_], t
			},
			getTheme: function() {
				return this._theme
			},
			getComponent: function(t, e) {
				var i = this._componentsMap.get(t);
				return i ? i[e || 0] : void 0
			},
			queryComponents: function(t) {
				var e = t.mainType;
				if (!e) return [];
				var i = t.index,
					n = t.id,
					r = t.name,
					a = this._componentsMap.get(e);
				if (!a || !a.length) return [];
				var o;
				if (null != i) x(i) || (i = [i]), o = v(p(i, function(t) {
					return a[t]
				}), function(t) {
					return !!t
				});
				else if (null != n) {
					var s = x(n);
					o = v(a, function(t) {
						return s && u(n, t.id) >= 0 || !s && t.id === n
					})
				} else if (null != r) {
					var l = x(r);
					o = v(a, function(t) {
						return l && u(r, t.name) >= 0 || !l && t.name === r
					})
				} else o = a.slice();
				return Ss(o, t)
			},
			findComponents: function(t) {
				function e(t) {
					var e = r + "Index",
						i = r + "Id",
						n = r + "Name";
					return !t || null == t[e] && null == t[i] && null == t[n] ? null : {
						mainType: r,
						index: t[e],
						id: t[i],
						name: t[n]
					}
				}

				function i(e) {
					return t.filter ? v(e, t.filter) : e
				}
				var n = t.query,
					r = t.mainType,
					a = e(n),
					o = a ? this.queryComponents(a) : this._componentsMap.get(r);
				return i(Ss(o, t))
			},
			eachComponent: function(t, e, i) {
				var n = this._componentsMap;
				if ("function" == typeof t) i = e, e = t, n.each(function(t, n) {
					f(t, function(t, r) {
						e.call(i, n, t, r)
					})
				});
				else if (b(t)) f(n.get(t), e, i);
				else if (S(t)) {
					var r = this.findComponents(t);
					f(r, e, i)
				}
			},
			getSeriesByName: function(t) {
				var e = this._componentsMap.get("series");
				return v(e, function(e) {
					return e.name === t
				})
			},
			getSeriesByIndex: function(t) {
				return this._componentsMap.get("series")[t]
			},
			getSeriesByType: function(t) {
				var e = this._componentsMap.get("series");
				return v(e, function(e) {
					return e.subType === t
				})
			},
			getSeries: function() {
				return this._componentsMap.get("series").slice()
			},
			getSeriesCount: function() {
				return this._componentsMap.get("series").length
			},
			eachSeries: function(t, e) {
				f(this._seriesIndices, function(i) {
					var n = this._componentsMap.get("series")[i];
					t.call(e, n, i)
				}, this)
			},
			eachRawSeries: function(t, e) {
				f(this._componentsMap.get("series"), t, e)
			},
			eachSeriesByType: function(t, e, i) {
				f(this._seriesIndices, function(n) {
					var r = this._componentsMap.get("series")[n];
					r.subType === t && e.call(i, r, n)
				}, this)
			},
			eachRawSeriesByType: function(t, e, i) {
				return f(this.getSeriesByType(t), e, i)
			},
			isSeriesFiltered: function(t) {
				return null == this._seriesIndicesMap.get(t.componentIndex)
			},
			getCurrentSeriesIndices: function() {
				return (this._seriesIndices || []).slice()
			},
			filterSeries: function(t, e) {
				var i = v(this._componentsMap.get("series"), t, e);
				bs(this, i)
			},
			restoreData: function(t) {
				var e = this._componentsMap;
				bs(this, e.get("series"));
				var i = [];
				e.each(function(t, e) {
					i.push(e)
				}), y_.topologicalTravel(i, y_.getAllClassMainTypes(), function(i) {
					f(e.get(i), function(e) {
						("series" !== i || !ms(e, t)) && e.restoreData()
					})
				})
			}
		});
	c(E_, b_);
	var z_ = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"],
		B_ = {};
	Is.prototype = {
		constructor: Is,
		create: function(t, e) {
			var i = [];
			f(B_, function(n) {
				var r = n.create(t, e);
				i = i.concat(r || [])
			}), this._coordinateSystems = i
		},
		update: function(t, e) {
			f(this._coordinateSystems, function(i) {
				i.update && i.update(t, e)
			})
		},
		getCoordinateSystems: function() {
			return this._coordinateSystems.slice()
		}
	}, Is.register = function(t, e) {
		B_[t] = e
	}, Is.get = function(t) {
		return B_[t]
	};
	var R_ = f,
		N_ = n,
		F_ = p,
		V_ = r,
		H_ = /^(min|max)?(.+)$/;
	Ts.prototype = {
		constructor: Ts,
		setOption: function(t, e) {
			t && f(er(t.series), function(t) {
				t && t.data && I(t.data) && z(t.data)
			}), t = N_(t);
			var i = this._optionBackup,
				n = Cs.call(this, t, e, !i);
			this._newBaseOption = n.baseOption, i ? (Ps(i.baseOption, n.baseOption), n.timelineOptions.length && (i.timelineOptions = n.timelineOptions), n.mediaList.length && (i.mediaList = n.mediaList), n.mediaDefault && (i.mediaDefault = n.mediaDefault)) : this._optionBackup = n
		},
		mountOption: function(t) {
			var e = this._optionBackup;
			return this._timelineOptions = F_(e.timelineOptions, N_), this._mediaList = F_(e.mediaList, N_), this._mediaDefault = N_(e.mediaDefault), this._currentMediaIndices = [], N_(t ? e.baseOption : this._newBaseOption)
		},
		getTimelineOption: function(t) {
			var e, i = this._timelineOptions;
			if (i.length) {
				var n = t.getComponent("timeline");
				n && (e = N_(i[n.getCurrentIndex()], !0))
			}
			return e
		},
		getMediaOption: function() {
			var t = this._api.getWidth(),
				e = this._api.getHeight(),
				i = this._mediaList,
				n = this._mediaDefault,
				r = [],
				a = [];
			if (!i.length && !n) return a;
			for (var o = 0, s = i.length; s > o; o++) Ds(i[o].query, t, e) && r.push(o);
			return !r.length && n && (r = [-1]), r.length && !As(r, this._currentMediaIndices) && (a = F_(r, function(t) {
				return N_(-1 === t ? n.option : i[t].option)
			})), this._currentMediaIndices = r, a
		}
	};
	var W_ = f,
		G_ = S,
		U_ = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"],
		X_ = function(t, e) {
			W_(Ns(t.series), function(t) {
				G_(t) && Rs(t)
			});
			var i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
			e && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), W_(i, function(e) {
				W_(Ns(t[e]), function(t) {
					t && (zs(t, "axisLabel"), zs(t.axisPointer, "label"))
				})
			}), W_(Ns(t.parallel), function(t) {
				var e = t && t.parallelAxisDefault;
				zs(e, "axisLabel"), zs(e && e.axisPointer, "label")
			}), W_(Ns(t.calendar), function(t) {
				Os(t, "itemStyle"), zs(t, "dayLabel"), zs(t, "monthLabel"), zs(t, "yearLabel")
			}), W_(Ns(t.radar), function(t) {
				zs(t, "name")
			}), W_(Ns(t.geo), function(t) {
				G_(t) && (Bs(t), W_(Ns(t.regions), function(t) {
					Bs(t)
				}))
			}), W_(Ns(t.timeline), function(t) {
				Bs(t), Os(t, "label"), Os(t, "itemStyle"), Os(t, "controlStyle", !0);
				var e = t.data;
				x(e) && f(e, function(t) {
					S(t) && (Os(t, "label"), Os(t, "itemStyle"))
				})
			}), W_(Ns(t.toolbox), function(t) {
				Os(t, "iconStyle"), W_(t.feature, function(t) {
					Os(t, "iconStyle")
				})
			}), zs(Fs(t.axisPointer), "label"), zs(Fs(t.tooltip).axisPointer, "label")
		},
		j_ = [
			["x", "left"],
			["y", "top"],
			["x2", "right"],
			["y2", "bottom"]
		],
		Y_ = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
		q_ = function(t, e) {
			X_(t, e), t.series = er(t.series), f(t.series, function(t) {
				if (S(t)) {
					var e = t.type;
					if ("line" === e) null != t.clipOverflow && (t.clip = t.clipOverflow);
					else if ("pie" === e || "gauge" === e) null != t.clockWise && (t.clockwise = t.clockWise);
					else if ("gauge" === e) {
						var i = Vs(t, "pointer.color");
						null != i && Hs(t, "itemStyle.color", i)
					}
					Ws(t)
				}
			}), t.dataRange && (t.visualMap = t.dataRange), f(Y_, function(e) {
				var i = t[e];
				i && (x(i) || (i = [i]), f(i, function(t) {
					Ws(t)
				}))
			})
		},
		Z_ = function(t) {
			var e = N();
			t.eachSeries(function(t) {
				var i = t.get("stack");
				if (i) {
					var n = e.get(i) || e.set(i, []),
						r = t.getData(),
						a = {
							stackResultDimension: r.getCalculationInfo("stackResultDimension"),
							stackedOverDimension: r.getCalculationInfo("stackedOverDimension"),
							stackedDimension: r.getCalculationInfo("stackedDimension"),
							stackedByDimension: r.getCalculationInfo("stackedByDimension"),
							isStackedByIndex: r.getCalculationInfo("isStackedByIndex"),
							data: r,
							seriesModel: t
						};
					if (!a.stackedDimension || !a.isStackedByIndex && !a.stackedByDimension) return;
					n.length && r.setCalculationInfo("stackedOnSeries", n[n.length - 1].seriesModel), n.push(a)
				}
			}), e.each(Gs)
		},
		K_ = Us.prototype;
	K_.pure = !1, K_.persistent = !0, K_.getSource = function() {
		return this._source
	};
	var $_ = {
			arrayRows_column: {
				pure: !0,
				count: function() {
					return Math.max(0, this._data.length - this._source.startIndex)
				},
				getItem: function(t) {
					return this._data[t + this._source.startIndex]
				},
				appendData: Ys
			},
			arrayRows_row: {
				pure: !0,
				count: function() {
					var t = this._data[0];
					return t ? Math.max(0, t.length - this._source.startIndex) : 0
				},
				getItem: function(t) {
					t += this._source.startIndex;
					for (var e = [], i = this._data, n = 0; n < i.length; n++) {
						var r = i[n];
						e.push(r ? r[t] : null)
					}
					return e
				},
				appendData: function() {
					throw new Error('Do not support appendData when set seriesLayoutBy: "row".')
				}
			},
			objectRows: {
				pure: !0,
				count: Xs,
				getItem: js,
				appendData: Ys
			},
			keyedColumns: {
				pure: !0,
				count: function() {
					var t = this._source.dimensionsDefine[0].name,
						e = this._data[t];
					return e ? e.length : 0
				},
				getItem: function(t) {
					for (var e = [], i = this._source.dimensionsDefine, n = 0; n < i.length; n++) {
						var r = this._data[i[n].name];
						e.push(r ? r[t] : null)
					}
					return e
				},
				appendData: function(t) {
					var e = this._data;
					f(t, function(t, i) {
						for (var n = e[i] || (e[i] = []), r = 0; r < (t || []).length; r++) n.push(t[r])
					})
				}
			},
			original: {
				count: Xs,
				getItem: js,
				appendData: Ys
			},
			typedArray: {
				persistent: !1,
				pure: !0,
				count: function() {
					return this._data ? this._data.length / this._dimSize : 0
				},
				getItem: function(t, e) {
					t -= this._offset, e = e || [];
					for (var i = this._dimSize * t, n = 0; n < this._dimSize; n++) e[n] = this._data[i + n];
					return e
				},
				appendData: function(t) {
					this._data = t
				},
				clean: function() {
					this._offset += this.count(), this._data = null
				}
			}
		},
		Q_ = {
			arrayRows: qs,
			objectRows: function(t, e, i, n) {
				return null != i ? t[n] : t
			},
			keyedColumns: qs,
			original: function(t, e, i) {
				var n = nr(t);
				return null != i && n instanceof Array ? n[i] : n
			},
			typedArray: qs
		},
		J_ = {
			arrayRows: Zs,
			objectRows: function(t, e) {
				return Ks(t[e], this._dimensionInfos[e])
			},
			keyedColumns: Zs,
			original: function(t, e, i, n) {
				var r = t && (null == t.value ? t : t.value);
				return !this._rawData.pure && rr(t) && (this.hasItemOption = !0), Ks(r instanceof Array ? r[n] : r, this._dimensionInfos[e])
			},
			typedArray: function(t, e, i, n) {
				return t[n]
			}
		},
		tx = /\{@(.+?)\}/g,
		ex = {
			getDataParams: function(t, e) {
				var i = this.getData(e),
					n = this.getRawValue(t, e),
					r = i.getRawIndex(t),
					a = i.getName(t),
					o = i.getRawDataItem(t),
					s = i.getItemVisual(t, "color"),
					l = i.getItemVisual(t, "borderColor"),
					u = this.ecModel.getComponent("tooltip"),
					h = u && u.get("renderMode"),
					c = gr(h),
					d = this.mainType,
					f = "series" === d,
					p = i.userOutput;
				return {
					componentType: d,
					componentSubType: this.subType,
					componentIndex: this.componentIndex,
					seriesType: f ? this.subType : null,
					seriesIndex: this.seriesIndex,
					seriesId: f ? this.id : null,
					seriesName: f ? this.name : null,
					name: a,
					dataIndex: r,
					data: o,
					dataType: e,
					value: n,
					color: s,
					borderColor: l,
					dimensionNames: p ? p.dimensionNames : null,
					encode: p ? p.encode : null,
					marker: Uo({
						color: s,
						renderMode: c
					}),
					$vars: ["seriesName", "name", "value"]
				}
			},
			getFormattedLabel: function(t, e, i, n, r) {
				e = e || "normal";
				var a = this.getData(i),
					o = a.getItemModel(t),
					s = this.getDataParams(t, i);
				null != n && s.value instanceof Array && (s.value = s.value[n]);
				var l = o.get("normal" === e ? [r || "label", "formatter"] : [e, r || "label", "formatter"]);
				if ("function" == typeof l) return s.status = e, s.dimensionIndex = n, l(s);
				if ("string" == typeof l) {
					var u = Wo(l, s);
					return u.replace(tx, function(e, i) {
						var n = i.length;
						return "[" === i.charAt(0) && "]" === i.charAt(n - 1) && (i = +i.slice(1, n - 1)), $s(a, t, i)
					})
				}
			},
			getRawValue: function(t, e) {
				return $s(this.getData(e), t)
			},
			formatTooltip: function() {}
		},
		ix = Js.prototype;
	ix.perform = function(t) {
		function e(t) {
			return !(t >= 1) && (t = 1), t
		}
		var i = this._upstream,
			n = t && t.skip;
		if (this._dirty && i) {
			var r = this.context;
			r.data = r.outputData = i.context.outputData
		}
		this.__pipeline && (this.__pipeline.currentTask = this);
		var a;
		this._plan && !n && (a = this._plan(this.context));
		var o = e(this._modBy),
			s = this._modDataCount || 0,
			l = e(t && t.modBy),
			u = t && t.modDataCount || 0;
		(o !== l || s !== u) && (a = "reset");
		var h;
		(this._dirty || "reset" === a) && (this._dirty = !1, h = el(this, n)), this._modBy = l, this._modDataCount = u;
		var c = t && t.step;
		if (this._dueEnd = i ? i._outputDueEnd : this._count ? this._count(this.context) : 1 / 0, this._progress) {
			var d = this._dueIndex,
				f = Math.min(null != c ? this._dueIndex + c : 1 / 0, this._dueEnd);
			if (!n && (h || f > d)) {
				var p = this._progress;
				if (x(p))
					for (var g = 0; g < p.length; g++) tl(this, p[g], d, f, l, u);
				else tl(this, p, d, f, l, u)
			}
			this._dueIndex = f;
			var v = null != this._settedOutputEnd ? this._settedOutputEnd : f;
			this._outputDueEnd = v
		} else this._dueIndex = this._outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd : this._dueEnd;
		return this.unfinished()
	};
	var nx = function() {
		function t() {
			return i > n ? n++ : null
		}

		function e() {
			var t = n % o * r + Math.ceil(n / o),
				e = n >= i ? null : a > t ? t : n;
			return n++, e
		}
		var i, n, r, a, o, s = {
			reset: function(l, u, h, c) {
				n = l, i = u, r = h, a = c, o = Math.ceil(a / r), s.next = r > 1 && a > 0 ? e : t
			}
		};
		return s
	}();
	ix.dirty = function() {
		this._dirty = !0, this._onDirty && this._onDirty(this.context)
	}, ix.unfinished = function() {
		return this._progress && this._dueIndex < this._dueEnd
	}, ix.pipe = function(t) {
		(this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty())
	}, ix.dispose = function() {
		this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0)
	}, ix.getUpstream = function() {
		return this._upstream
	}, ix.getDownstream = function() {
		return this._downstream
	}, ix.setOutputEnd = function(t) {
		this._outputDueEnd = this._settedOutputEnd = t
	};
	var rx = hr(),
		ax = y_.extend({
			type: "series.__base__",
			seriesIndex: 0,
			coordinateSystem: null,
			defaultOption: null,
			legendVisualProvider: null,
			visualColorAccessPath: "itemStyle.color",
			visualBorderColorAccessPath: "itemStyle.borderColor",
			layoutMode: null,
			init: function(t, e, i) {
				this.seriesIndex = this.componentIndex, this.dataTask = Qs({
					count: rl,
					reset: al
				}), this.dataTask.context = {
					model: this
				}, this.mergeDefaultAndTheme(t, i), ls(this);
				var n = this.getInitialData(t, i);
				sl(n, this), this.dataTask.context.data = n, rx(this).dataBeforeProcessed = n, il(this)
			},
			mergeDefaultAndTheme: function(t, e) {
				var i = this.layoutMode,
					n = i ? ts(t) : {},
					a = this.subType;
				y_.hasClass(a) && (a += "Series"), r(t, e.getTheme().get(this.subType)), r(t, this.getDefaultOption()), ir(t, "label", ["show"]), this.fillDataTextStyle(t.data), i && Jo(t, n, i)
			},
			mergeOption: function(t, e) {
				t = r(this.option, t, !0), this.fillDataTextStyle(t.data);
				var i = this.layoutMode;
				i && Jo(this.option, t, i), ls(this);
				var n = this.getInitialData(t, e);
				sl(n, this), this.dataTask.dirty(), this.dataTask.context.data = n, rx(this).dataBeforeProcessed = n, il(this)
			},
			fillDataTextStyle: function(t) {
				if (t && !I(t))
					for (var e = ["show"], i = 0; i < t.length; i++) t[i] && t[i].label && ir(t[i], "label", e)
			},
			getInitialData: function() {},
			appendData: function(t) {
				var e = this.getRawData();
				e.appendData(t.data)
			},
			getData: function(t) {
				var e = ul(this);
				if (e) {
					var i = e.context.data;
					return null == t ? i : i.getLinkedData(t)
				}
				return rx(this).data
			},
			setData: function(t) {
				var e = ul(this);
				if (e) {
					var i = e.context;
					i.data !== t && e.modifyOutputEnd && e.setOutputEnd(t.count()), i.outputData = t, e !== this.dataTask && (i.data = t)
				}
				rx(this).data = t
			},
			getSource: function() {
				return os(this)
			},
			getRawData: function() {
				return rx(this).dataBeforeProcessed
			},
			getBaseAxis: function() {
				var t = this.coordinateSystem;
				return t && t.getBaseAxis && t.getBaseAxis()
			},
			formatTooltip: function(t, e, i, n) {
				function r(i) {
					function r(t, i) {
						var r = c.getDimensionInfo(i);
						if (r && r.otherDims.tooltip !== !1) {
							var d = r.type,
								f = "sub" + o.seriesIndex + "at" + h,
								p = Uo({
									color: y,
									type: "subItem",
									renderMode: n,
									markerId: f
								}),
								g = "string" == typeof p ? p : p.content,
								v = (a ? g + Ho(r.displayName || "-") + ": " : "") + Ho("ordinal" === d ? t + "" : "time" === d ? e ? "" : jo("yyyy/MM/dd hh:mm:ss", t) : Fo(t));
							v && s.push(v), l && (u[f] = y, ++h)
						}
					}
					var a = g(i, function(t, e, i) {
							var n = c.getDimensionInfo(i);
							return t |= n && n.tooltip !== !1 && null != n.displayName
						}, 0),
						s = [];
					d.length ? f(d, function(e) {
						r($s(c, t, e), e)
					}) : f(i, r);
					var p = a ? l ? "\n" : "<br/>" : "",
						v = p + s.join(p || ", ");
					return {
						renderMode: n,
						content: v,
						style: u
					}
				}

				function a(t) {
					return {
						renderMode: n,
						content: Ho(Fo(t)),
						style: u
					}
				}
				var o = this;
				n = n || "html";
				var s = "html" === n ? "<br/>" : "\n",
					l = "richText" === n,
					u = {},
					h = 0,
					c = this.getData(),
					d = c.mapDimension("defaultedTooltip", !0),
					p = d.length,
					v = this.getRawValue(t),
					m = x(v),
					y = c.getItemVisual(t, "color");
				S(y) && y.colorStops && (y = (y.colorStops[0] || {}).color), y = y || "transparent";
				var _ = p > 1 || m && !p ? r(v) : a(p ? $s(c, t, d[0]) : m ? v[0] : v),
					w = _.content,
					b = o.seriesIndex + "at" + h,
					M = Uo({
						color: y,
						type: "item",
						renderMode: n,
						markerId: b
					});
				u[b] = y, ++h;
				var I = c.getName(t),
					T = this.name;
				sr(this) || (T = ""), T = T ? Ho(T) + (e ? ": " : s) : "";
				var C = "string" == typeof M ? M : M.content,
					D = e ? C + T + w : T + C + (I ? Ho(I) + ": " + w : w);
				return {
					html: D,
					markers: u
				}
			},
			isAnimationEnabled: function() {
				if (zp.node) return !1;
				var t = this.getShallow("animation");
				return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1), t
			},
			restoreData: function() {
				this.dataTask.dirty()
			},
			getColorFromPalette: function(t, e, i) {
				var n = this.ecModel,
					r = b_.getColorFromPalette.call(this, t, e, i);
				return r || (r = n.getColorFromPalette(t, e, i)), r
			},
			coordDimToDataDim: function(t) {
				return this.getRawData().mapDimension(t, !0)
			},
			getProgressive: function() {
				return this.get("progressive")
			},
			getProgressiveThreshold: function() {
				return this.get("progressiveThreshold")
			},
			getAxisTooltipData: null,
			getTooltipPosition: null,
			pipeTask: null,
			preventIncremental: null,
			pipelineContext: null
		});
	c(ax, ex), c(ax, b_);
	var ox = function() {
		this.group = new Zg, this.uid = yo("viewComponent")
	};
	ox.prototype = {
		constructor: ox,
		init: function() {},
		render: function() {},
		dispose: function() {},
		filterForExposedEvent: null
	};
	var sx = ox.prototype;
	sx.updateView = sx.updateLayout = sx.updateVisual = function() {}, yr(ox), br(ox, {
		registerWhenExtend: !0
	});
	var lx = function() {
			var t = hr();
			return function(e) {
				var i = t(e),
					n = e.pipelineContext,
					r = i.large,
					a = i.progressiveRender,
					o = i.large = n && n.large,
					s = i.progressiveRender = n && n.progressiveRender;
				return !!(r ^ o || a ^ s) && "reset"
			}
		},
		ux = hr(),
		hx = lx();
	hl.prototype = {
		type: "chart",
		init: function() {},
		render: function() {},
		highlight: function(t, e, i, n) {
			dl(t.getData(), n, "emphasis")
		},
		downplay: function(t, e, i, n) {
			dl(t.getData(), n, "normal")
		},
		remove: function() {
			this.group.removeAll()
		},
		dispose: function() {},
		incrementalPrepareRender: null,
		incrementalRender: null,
		updateTransform: null,
		filterForExposedEvent: null
	};
	var cx = hl.prototype;
	cx.updateView = cx.updateLayout = cx.updateVisual = function(t, e, i, n) {
		this.render(t, e, i, n)
	}, yr(hl, ["dispose"]), br(hl, {
		registerWhenExtend: !0
	}), hl.markUpdateMethod = function(t, e) {
		ux(t).updateMethod = e
	};
	var dx = {
			incrementalPrepareRender: {
				progress: function(t, e) {
					e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload)
				}
			},
			render: {
				forceFirstProgress: !0,
				progress: function(t, e) {
					e.view.render(e.model, e.ecModel, e.api, e.payload)
				}
			}
		},
		fx = "\x00__throttleOriginMethod",
		px = "\x00__throttleRate",
		gx = "\x00__throttleType",
		vx = {
			createOnAllSeries: !0,
			performRawSeries: !0,
			reset: function(t, e) {
				var i = t.getData(),
					n = (t.visualColorAccessPath || "itemStyle.color").split("."),
					r = t.get(n),
					a = !w(r) || r instanceof ky ? null : r;
				(!r || a) && (r = t.getColorFromPalette(t.name, null, e.getSeriesCount())), i.setVisual("color", r);
				var o = (t.visualBorderColorAccessPath || "itemStyle.borderColor").split("."),
					s = t.get(o);
				if (i.setVisual("borderColor", s), !e.isSeriesFiltered(t)) {
					a && i.each(function(e) {
						i.setItemVisual(e, "color", a(t.getDataParams(e)))
					});
					var l = function(t, e) {
						var i = t.getItemModel(e),
							r = i.get(n, !0),
							a = i.get(o, !0);
						null != r && t.setItemVisual(e, "color", r), null != a && t.setItemVisual(e, "borderColor", a)
					};
					return {
						dataEach: i.hasItemOption ? l : null
					}
				}
			}
		},
		mx = {
			legend: {
				selector: {
					all: "全选",
					inverse: "反选"
				}
			},
			toolbox: {
				brush: {
					title: {
						rect: "矩形选择",
						polygon: "圈选",
						lineX: "横向选择",
						lineY: "纵向选择",
						keep: "保持选择",
						clear: "清除选择"
					}
				},
				dataView: {
					title: "数据视图",
					lang: ["数据视图", "关闭", "刷新"]
				},
				dataZoom: {
					title: {
						zoom: "区域缩放",
						back: "区域缩放还原"
					}
				},
				magicType: {
					title: {
						line: "切换为折线图",
						bar: "切换为柱状图",
						stack: "切换为堆叠",
						tiled: "切换为平铺"
					}
				},
				restore: {
					title: "还原"
				},
				saveAsImage: {
					title: "保存为图片",
					lang: ["右键另存为图片"]
				}
			},
			series: {
				typeNames: {
					pie: "饼图",
					bar: "柱状图",
					line: "折线图",
					scatter: "散点图",
					effectScatter: "涟漪散点图",
					radar: "雷达图",
					tree: "树图",
					treemap: "矩形树图",
					boxplot: "箱型图",
					candlestick: "K线图",
					k: "K线图",
					heatmap: "热力图",
					map: "地图",
					parallel: "平行坐标图",
					lines: "线图",
					graph: "关系图",
					sankey: "桑基图",
					funnel: "漏斗图",
					gauge: "仪表盘图",
					pictorialBar: "象形柱图",
					themeRiver: "主题河流图",
					sunburst: "旭日图"
				}
			},
			aria: {
				general: {
					withTitle: "这是一个关于“{title}”的图表。",
					withoutTitle: "这是一个图表，"
				},
				series: {
					single: {
						prefix: "",
						withName: "图表类型是{seriesType}，表示{seriesName}。",
						withoutName: "图表类型是{seriesType}。"
					},
					multiple: {
						prefix: "它由{seriesCount}个图表系列组成。",
						withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
						withoutName: "第{seriesId}个系列是一个{seriesType}，",
						separator: {
							middle: "；",
							end: "。"
						}
					}
				},
				data: {
					allData: "其数据是——",
					partialData: "其中，前{displayCnt}项是——",
					withName: "{name}的数据是{value}",
					withoutName: "{value}",
					separator: {
						middle: "，",
						end: ""
					}
				}
			}
		},
		yx = function(t, e) {
			function i(t, e) {
				if ("string" != typeof t) return t;
				var i = t;
				return f(e, function(t, e) {
					i = i.replace(new RegExp("\\{\\s*" + e + "\\s*\\}", "g"), t)
				}), i
			}

			function n(t) {
				var e = o.get(t);
				if (null == e) {
					for (var i = t.split("."), n = mx.aria, r = 0; r < i.length; ++r) n = n[i[r]];
					return n
				}
				return e
			}

			function r() {
				var t = e.getModel("title").option;
				return t && t.length && (t = t[0]), t && t.text
			}

			function a(t) {
				return mx.series.typeNames[t] || "自定义图"
			}
			var o = e.getModel("aria");
			if (o.get("show")) {
				if (o.get("description")) return void t.setAttribute("aria-label", o.get("description"));
				var s = 0;
				e.eachSeries(function() {
					++s
				}, this);
				var l, u = o.get("data.maxCount") || 10,
					h = o.get("series.maxCount") || 10,
					c = Math.min(s, h);
				if (!(1 > s)) {
					var d = r();
					l = d ? i(n("general.withTitle"), {
						title: d
					}) : n("general.withoutTitle");
					var p = [],
						g = s > 1 ? "series.multiple.prefix" : "series.single.prefix";
					l += i(n(g), {
						seriesCount: s
					}), e.eachSeries(function(t, e) {
						if (c > e) {
							var r, o = t.get("name"),
								l = "series." + (s > 1 ? "multiple" : "single") + ".";
							r = n(o ? l + "withName" : l + "withoutName"), r = i(r, {
								seriesId: t.seriesIndex,
								seriesName: t.get("name"),
								seriesType: a(t.subType)
							});
							var h = t.getData();
							window.data = h, r += h.count() > u ? i(n("data.partialData"), {
								displayCnt: u
							}) : n("data.allData");
							for (var d = [], f = 0; f < h.count(); f++)
								if (u > f) {
									var g = h.getName(f),
										v = $s(h, f);
									d.push(i(n(g ? "data.withName" : "data.withoutName"), {
										name: g,
										value: v
									}))
								}
							r += d.join(n("data.separator.middle")) + n("data.separator.end"), p.push(r)
						}
					}), l += p.join(n("series.multiple.separator.middle")) + n("series.multiple.separator.end"), t.setAttribute("aria-label", l)
				}
			}
		},
		_x = Math.PI,
		xx = function(t, e) {
			e = e || {}, s(e, {
				text: "loading",
				textColor: "#000",
				fontSize: "12px",
				maskColor: "rgba(255, 255, 255, 0.8)",
				showSpinner: !0,
				color: "#c23531",
				spinnerRadius: 10,
				lineWidth: 5,
				zlevel: 0
			});
			var i = new Zg,
				n = new by({
					style: {
						fill: e.maskColor
					},
					zlevel: e.zlevel,
					z: 1e4
				});
			i.add(n);
			var r = e.fontSize + " sans-serif",
				a = new by({
					style: {
						fill: "none",
						text: e.text,
						font: r,
						textPosition: "right",
						textDistance: 10,
						textFill: e.textColor
					},
					zlevel: e.zlevel,
					z: 10001
				});
			if (i.add(a), e.showSpinner) {
				var o = new Cy({
					shape: {
						startAngle: -_x / 2,
						endAngle: -_x / 2 + .1,
						r: e.spinnerRadius
					},
					style: {
						stroke: e.color,
						lineCap: "round",
						lineWidth: e.lineWidth
					},
					zlevel: e.zlevel,
					z: 10001
				});
				o.animateShape(!0).when(1e3, {
					endAngle: 3 * _x / 2
				}).start("circularInOut"), o.animateShape(!0).when(1e3, {
					startAngle: 3 * _x / 2
				}).delay(300).start("circularInOut"), i.add(o)
			}
			return i.resize = function() {
				var i = Xi(e.text, r),
					s = e.showSpinner ? e.spinnerRadius : 0,
					l = (t.getWidth() - 2 * s - (e.showSpinner && i ? 10 : 0) - i) / 2 - (e.showSpinner ? 0 : i / 2),
					u = t.getHeight() / 2;
				e.showSpinner && o.setShape({
					cx: l,
					cy: u
				}), a.setShape({
					x: l - s,
					y: u - s,
					width: 2 * s,
					height: 2 * s
				}), n.setShape({
					x: 0,
					y: 0,
					width: t.getWidth(),
					height: t.getHeight()
				})
			}, i.resize(), i
		},
		bx = ml.prototype;
	bx.restoreData = function(t, e) {
		t.restoreData(e), this._stageTaskMap.each(function(t) {
			var e = t.overallTask;
			e && e.dirty()
		})
	}, bx.getPerformArgs = function(t, e) {
		if (t.__pipeline) {
			var i = this._pipelineMap.get(t.__pipeline.id),
				n = i.context,
				r = !e && i.progressiveEnabled && (!n || n.progressiveRender) && t.__idxInPipeline > i.blockIndex,
				a = r ? i.step : null,
				o = n && n.modDataCount,
				s = null != o ? Math.ceil(o / a) : null;
			return {
				step: a,
				modBy: s,
				modDataCount: o
			}
		}
	}, bx.getPipeline = function(t) {
		return this._pipelineMap.get(t)
	}, bx.updateStreamModes = function(t, e) {
		var i = this._pipelineMap.get(t.uid),
			n = t.getData(),
			r = n.count(),
			a = i.progressiveEnabled && e.incrementalPrepareRender && r >= i.threshold,
			o = t.get("large") && r >= t.get("largeThreshold"),
			s = "mod" === t.get("progressiveChunkMode") ? r : null;
		t.pipelineContext = i.context = {
			progressiveRender: a,
			modDataCount: s,
			large: o
		}
	}, bx.restorePipelines = function(t) {
		var e = this,
			i = e._pipelineMap = N();
		t.eachSeries(function(t) {
			var n = t.getProgressive(),
				r = t.uid;
			i.set(r, {
				id: r,
				head: null,
				tail: null,
				threshold: t.getProgressiveThreshold(),
				progressiveEnabled: n && !(t.preventIncremental && t.preventIncremental()),
				blockIndex: -1,
				step: Math.round(n || 700),
				count: 0
			}), kl(e, t, t.dataTask)
		})
	}, bx.prepareStageTasks = function() {
		var t = this._stageTaskMap,
			e = this.ecInstance.getModel(),
			i = this.api;
		f(this._allHandlers, function(n) {
			var r = t.get(n.uid) || t.set(n.uid, []);
			n.reset && _l(this, n, r, e, i), n.overallReset && xl(this, n, r, e, i)
		}, this)
	}, bx.prepareView = function(t, e, i, n) {
		var r = t.renderTask,
			a = r.context;
		a.model = e, a.ecModel = i, a.api = n, r.__block = !t.incrementalPrepareRender, kl(this, e, r)
	}, bx.performDataProcessorTasks = function(t, e) {
		yl(this, this._dataProcessorHandlers, t, e, {
			block: !0
		})
	}, bx.performVisualTasks = function(t, e, i) {
		yl(this, this._visualHandlers, t, e, i)
	}, bx.performSeriesTasks = function(t) {
		var e;
		t.eachSeries(function(t) {
			e |= t.dataTask.perform()
		}), this.unfinished |= e
	}, bx.plan = function() {
		this._pipelineMap.each(function(t) {
			var e = t.tail;
			do {
				if (e.__block) {
					t.blockIndex = e.__idxInPipeline;
					break
				}
				e = e.getUpstream()
			} while (e)
		})
	};
	var Sx = bx.updatePayload = function(t, e) {
			"remain" !== e && (t.context.payload = e)
		},
		Mx = Cl(0);
	ml.wrapStageHandler = function(t, e) {
		return w(t) && (t = {
			overallReset: t,
			seriesType: Al(t)
		}), t.uid = yo("stageHandler"), e && (t.visualType = e), t
	};
	var Ix, Tx = {},
		Cx = {};
	Pl(Tx, E_), Pl(Cx, Ms), Tx.eachSeriesByType = Tx.eachRawSeriesByType = function(t) {
		Ix = t
	}, Tx.eachComponent = function(t) {
		"series" === t.mainType && t.subType && (Ix = t.subType)
	};
	var Dx = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"],
		kx = {
			color: Dx,
			colorLayer: [
				["#37A2DA", "#ffd85c", "#fd7b5f"],
				["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"],
				["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], Dx
			]
		},
		Ax = "#eee",
		Px = function() {
			return {
				axisLine: {
					lineStyle: {
						color: Ax
					}
				},
				axisTick: {
					lineStyle: {
						color: Ax
					}
				},
				axisLabel: {
					textStyle: {
						color: Ax
					}
				},
				splitLine: {
					lineStyle: {
						type: "dashed",
						color: "#aaa"
					}
				},
				splitArea: {
					areaStyle: {
						color: Ax
					}
				}
			}
		},
		Lx = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"],
		Ox = {
			color: Lx,
			backgroundColor: "#333",
			tooltip: {
				axisPointer: {
					lineStyle: {
						color: Ax
					},
					crossStyle: {
						color: Ax
					},
					label: {
						color: "#000"
					}
				}
			},
			legend: {
				textStyle: {
					color: Ax
				}
			},
			textStyle: {
				color: Ax
			},
			title: {
				textStyle: {
					color: Ax
				}
			},
			toolbox: {
				iconStyle: {
					normal: {
						borderColor: Ax
					}
				}
			},
			dataZoom: {
				textStyle: {
					color: Ax
				}
			},
			visualMap: {
				textStyle: {
					color: Ax
				}
			},
			timeline: {
				lineStyle: {
					color: Ax
				},
				itemStyle: {
					normal: {
						color: Lx[1]
					}
				},
				label: {
					normal: {
						textStyle: {
							color: Ax
						}
					}
				},
				controlStyle: {
					normal: {
						color: Ax,
						borderColor: Ax
					}
				}
			},
			timeAxis: Px(),
			logAxis: Px(),
			valueAxis: Px(),
			categoryAxis: Px(),
			line: {
				symbol: "circle"
			},
			graph: {
				color: Lx
			},
			gauge: {
				title: {
					textStyle: {
						color: Ax
					}
				}
			},
			candlestick: {
				itemStyle: {
					normal: {
						color: "#FD1050",
						color0: "#0CF49B",
						borderColor: "#FD1050",
						borderColor0: "#0CF49B"
					}
				}
			}
		};
	Ox.categoryAxis.splitLine.show = !1, y_.extend({
		type: "dataset",
		defaultOption: {
			seriesLayoutBy: k_,
			sourceHeader: null,
			dimensions: null,
			source: null
		},
		optionUpdated: function() {
			as(this)
		}
	}), ox.extend({
		type: "dataset"
	});
	var Ex = ia.extend({
			type: "ellipse",
			shape: {
				cx: 0,
				cy: 0,
				rx: 0,
				ry: 0
			},
			buildPath: function(t, e) {
				var i = .5522848,
					n = e.cx,
					r = e.cy,
					a = e.rx,
					o = e.ry,
					s = a * i,
					l = o * i;
				t.moveTo(n - a, r), t.bezierCurveTo(n - a, r - l, n - s, r - o, n, r - o), t.bezierCurveTo(n + s, r - o, n + a, r - l, n + a, r), t.bezierCurveTo(n + a, r + l, n + s, r + o, n, r + o), t.bezierCurveTo(n - s, r + o, n - a, r + l, n - a, r), t.closePath()
			}
		}),
		zx = /[\s,]+/;
	Ol.prototype.parse = function(t, e) {
		e = e || {};
		var i = Ll(t);
		if (!i) throw new Error("Illegal svg");
		var n = new Zg;
		this._root = n;
		var r = i.getAttribute("viewBox") || "",
			a = parseFloat(i.getAttribute("width") || e.width),
			o = parseFloat(i.getAttribute("height") || e.height);
		isNaN(a) && (a = null), isNaN(o) && (o = null), Rl(i, n, null, !0);
		for (var s = i.firstChild; s;) this._parseNode(s, n), s = s.nextSibling;
		var l, u;
		if (r) {
			var h = E(r).split(zx);
			h.length >= 4 && (l = {
				x: parseFloat(h[0] || 0),
				y: parseFloat(h[1] || 0),
				width: parseFloat(h[2]),
				height: parseFloat(h[3])
			})
		}
		if (l && null != a && null != o && (u = Hl(l, a, o), !e.ignoreViewBox)) {
			var c = n;
			n = new Zg, n.add(c), c.scale = u.scale.slice(), c.position = u.position.slice()
		}
		return e.ignoreRootClip || null == a || null == o || n.setClipPath(new by({
			shape: {
				x: 0,
				y: 0,
				width: a,
				height: o
			}
		})), {
			root: n,
			width: a,
			height: o,
			viewBoxRect: l,
			viewBoxTransform: u
		}
	}, Ol.prototype._parseNode = function(t, e) {
		var i = t.nodeName.toLowerCase();
		"defs" === i ? this._isDefine = !0 : "text" === i && (this._isText = !0);
		var n;
		if (this._isDefine) {
			var r = Rx[i];
			if (r) {
				var a = r.call(this, t),
					o = t.getAttribute("id");
				o && (this._defs[o] = a)
			}
		} else {
			var r = Bx[i];
			r && (n = r.call(this, t, e), e.add(n))
		}
		for (var s = t.firstChild; s;) 1 === s.nodeType && this._parseNode(s, n), 3 === s.nodeType && this._isText && this._parseText(s, n), s = s.nextSibling;
		"defs" === i ? this._isDefine = !1 : "text" === i && (this._isText = !1)
	}, Ol.prototype._parseText = function(t, e) {
		if (1 === t.nodeType) {
			var i = t.getAttribute("dx") || 0,
				n = t.getAttribute("dy") || 0;
			this._textX += parseFloat(i), this._textY += parseFloat(n)
		}
		var r = new hy({
			style: {
				text: t.textContent,
				transformText: !0
			},
			position: [this._textX || 0, this._textY || 0]
		});
		zl(e, r), Rl(t, r, this._defs);
		var a = r.style.fontSize;
		a && 9 > a && (r.style.fontSize = 9, r.scale = r.scale || [1, 1], r.scale[0] *= a / 9, r.scale[1] *= a / 9);
		var o = r.getBoundingRect();
		return this._textX += o.width, e.add(r), r
	};
	var Bx = {
			g: function(t, e) {
				var i = new Zg;
				return zl(e, i), Rl(t, i, this._defs), i
			},
			rect: function(t, e) {
				var i = new by;
				return zl(e, i), Rl(t, i, this._defs), i.setShape({
					x: parseFloat(t.getAttribute("x") || 0),
					y: parseFloat(t.getAttribute("y") || 0),
					width: parseFloat(t.getAttribute("width") || 0),
					height: parseFloat(t.getAttribute("height") || 0)
				}), i
			},
			circle: function(t, e) {
				var i = new cy;
				return zl(e, i), Rl(t, i, this._defs), i.setShape({
					cx: parseFloat(t.getAttribute("cx") || 0),
					cy: parseFloat(t.getAttribute("cy") || 0),
					r: parseFloat(t.getAttribute("r") || 0)
				}), i
			},
			line: function(t, e) {
				var i = new My;
				return zl(e, i), Rl(t, i, this._defs), i.setShape({
					x1: parseFloat(t.getAttribute("x1") || 0),
					y1: parseFloat(t.getAttribute("y1") || 0),
					x2: parseFloat(t.getAttribute("x2") || 0),
					y2: parseFloat(t.getAttribute("y2") || 0)
				}), i
			},
			ellipse: function(t, e) {
				var i = new Ex;
				return zl(e, i), Rl(t, i, this._defs), i.setShape({
					cx: parseFloat(t.getAttribute("cx") || 0),
					cy: parseFloat(t.getAttribute("cy") || 0),
					rx: parseFloat(t.getAttribute("rx") || 0),
					ry: parseFloat(t.getAttribute("ry") || 0)
				}), i
			},
			polygon: function(t, e) {
				var i = t.getAttribute("points");
				i && (i = Bl(i));
				var n = new yy({
					shape: {
						points: i || []
					}
				});
				return zl(e, n), Rl(t, n, this._defs), n
			},
			polyline: function(t, e) {
				var i = new ia;
				zl(e, i), Rl(t, i, this._defs);
				var n = t.getAttribute("points");
				n && (n = Bl(n));
				var r = new _y({
					shape: {
						points: n || []
					}
				});
				return r
			},
			image: function(t, e) {
				var i = new kn;
				return zl(e, i), Rl(t, i, this._defs), i.setStyle({
					image: t.getAttribute("xlink:href"),
					x: t.getAttribute("x"),
					y: t.getAttribute("y"),
					width: t.getAttribute("width"),
					height: t.getAttribute("height")
				}), i
			},
			text: function(t, e) {
				var i = t.getAttribute("x") || 0,
					n = t.getAttribute("y") || 0,
					r = t.getAttribute("dx") || 0,
					a = t.getAttribute("dy") || 0;
				this._textX = parseFloat(i) + parseFloat(r), this._textY = parseFloat(n) + parseFloat(a);
				var o = new Zg;
				return zl(e, o), Rl(t, o, this._defs), o
			},
			tspan: function(t, e) {
				var i = t.getAttribute("x"),
					n = t.getAttribute("y");
				null != i && (this._textX = parseFloat(i)), null != n && (this._textY = parseFloat(n));
				var r = t.getAttribute("dx") || 0,
					a = t.getAttribute("dy") || 0,
					o = new Zg;
				return zl(e, o), Rl(t, o, this._defs), this._textX += r, this._textY += a, o
			},
			path: function(t, e) {
				var i = t.getAttribute("d") || "",
					n = oa(i);
				return zl(e, n), Rl(t, n, this._defs), n
			}
		},
		Rx = {
			lineargradient: function(t) {
				var e = parseInt(t.getAttribute("x1") || 0, 10),
					i = parseInt(t.getAttribute("y1") || 0, 10),
					n = parseInt(t.getAttribute("x2") || 10, 10),
					r = parseInt(t.getAttribute("y2") || 0, 10),
					a = new Ay(e, i, n, r);
				return El(t, a), a
			},
			radialgradient: function() {}
		},
		Nx = {
			fill: "fill",
			stroke: "stroke",
			"stroke-width": "lineWidth",
			opacity: "opacity",
			"fill-opacity": "fillOpacity",
			"stroke-opacity": "strokeOpacity",
			"stroke-dasharray": "lineDash",
			"stroke-dashoffset": "lineDashOffset",
			"stroke-linecap": "lineCap",
			"stroke-linejoin": "lineJoin",
			"stroke-miterlimit": "miterLimit",
			"font-family": "fontFamily",
			"font-size": "fontSize",
			"font-style": "fontStyle",
			"font-weight": "fontWeight",
			"text-align": "textAlign",
			"alignment-baseline": "textBaseline"
		},
		Fx = /url\(\s*#(.*?)\)/,
		Vx = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g,
		Hx = /([^\s:;]+)\s*:\s*([^:;]+)/g,
		Wx = N(),
		Gx = {
			registerMap: function(t, e, i) {
				var n;
				return x(e) ? n = e : e.svg ? n = [{
					type: "svg",
					source: e.svg,
					specialAreas: e.specialAreas
				}] : (e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), n = [{
					type: "geoJSON",
					source: e,
					specialAreas: i
				}]), f(n, function(t) {
					var e = t.type;
					"geoJson" === e && (e = t.type = "geoJSON");
					var i = Ux[e];
					i(t)
				}), Wx.set(t, n)
			},
			retrieveMap: function(t) {
				return Wx.get(t)
			}
		},
		Ux = {
			geoJSON: function(t) {
				var e = t.source;
				t.geoJSON = b(e) ? "undefined" != typeof JSON && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")() : e
			},
			svg: function(t) {
				t.svgXML = Ll(t.source)
			}
		},
		Xx = O,
		jx = f,
		Yx = w,
		qx = S,
		Zx = y_.parseClassType,
		Kx = "4.9.0",
		$x = {
			zrender: "4.3.2"
		},
		Qx = 1,
		Jx = 1e3,
		tw = 800,
		ew = 900,
		iw = 5e3,
		nw = 1e3,
		rw = 1100,
		aw = 2e3,
		ow = 3e3,
		sw = 3500,
		lw = 4e3,
		uw = 5e3,
		hw = {
			PROCESSOR: {
				FILTER: Jx,
				SERIES_FILTER: tw,
				STATISTIC: iw
			},
			VISUAL: {
				LAYOUT: nw,
				PROGRESSIVE_LAYOUT: rw,
				GLOBAL: aw,
				CHART: ow,
				POST_CHART_LAYOUT: sw,
				COMPONENT: lw,
				BRUSH: uw
			}
		},
		cw = "__flagInMainProcess",
		dw = "__optionUpdated",
		fw = /^[a-zA-Z0-9_]+$/;
	Gl.prototype.on = Wl("on", !0), Gl.prototype.off = Wl("off", !0), Gl.prototype.one = Wl("one", !0), c(Gl, ng);
	var pw = Ul.prototype;
	pw._onframe = function() {
		if (!this._disposed) {
			var t = this._scheduler;
			if (this[dw]) {
				var e = this[dw].silent;
				this[cw] = !0, jl(this), gw.update.call(this), this[cw] = !1, this[dw] = !1, Kl.call(this, e), $l.call(this, e)
			} else if (t.unfinished) {
				var i = Qx,
					n = this._model,
					r = this._api;
				t.unfinished = !1;
				do {
					var a = +new Date;
					t.performSeriesTasks(n), t.performDataProcessorTasks(n), ql(this, n), t.performVisualTasks(n), nu(this, this._model, r, "remain"), i -= +new Date - a
				} while (i > 0 && t.unfinished);
				t.unfinished || this._zr.flush()
			}
		}
	}, pw.getDom = function() {
		return this._dom
	}, pw.getZr = function() {
		return this._zr
	}, pw.setOption = function(t, e, i) {
		if (!this._disposed) {
			var n;
			if (qx(e) && (i = e.lazyUpdate, n = e.silent, e = e.notMerge), this[cw] = !0, !this._model || e) {
				var r = new Ts(this._api),
					a = this._theme,
					o = this._model = new E_;
				o.scheduler = this._scheduler, o.init(null, null, a, r)
			}
			this._model.setOption(t, xw), i ? (this[dw] = {
				silent: n
			}, this[cw] = !1) : (jl(this), gw.update.call(this), this._zr.flush(), this[dw] = !1, this[cw] = !1, Kl.call(this, n), $l.call(this, n))
		}
	}, pw.setTheme = function() {
		console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
	}, pw.getModel = function() {
		return this._model
	}, pw.getOption = function() {
		return this._model && this._model.getOption()
	}, pw.getWidth = function() {
		return this._zr.getWidth()
	}, pw.getHeight = function() {
		return this._zr.getHeight()
	}, pw.getDevicePixelRatio = function() {
		return this._zr.painter.dpr || window.devicePixelRatio || 1
	}, pw.getRenderedCanvas = function(t) {
		if (zp.canvasSupported) {
			t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");
			var e = this._zr;
			return e.painter.getRenderedCanvas(t)
		}
	}, pw.getSvgDataURL = function() {
		if (zp.svgSupported) {
			var t = this._zr,
				e = t.storage.getDisplayList();
			return f(e, function(t) {
				t.stopAnimation(!0)
			}), t.painter.toDataURL()
		}
	}, pw.getDataURL = function(t) {
		if (!this._disposed) {
			t = t || {};
			var e = t.excludeComponents,
				i = this._model,
				n = [],
				r = this;
			jx(e, function(t) {
				i.eachComponent({
					mainType: t
				}, function(t) {
					var e = r._componentsMap[t.__viewId];
					e.group.ignore || (n.push(e), e.group.ignore = !0)
				})
			});
			var a = "svg" === this._zr.painter.getType() ? this.getSvgDataURL() : this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
			return jx(n, function(t) {
				t.group.ignore = !1
			}), a
		}
	}, pw.getConnectedDataURL = function(t) {
		if (!this._disposed && zp.canvasSupported) {
			var e = "svg" === t.type,
				i = this.group,
				r = Math.min,
				a = Math.max,
				o = 1 / 0;
			if (Tw[i]) {
				var s = o,
					l = o,
					u = -o,
					h = -o,
					c = [],
					d = t && t.pixelRatio || 1;
				f(Iw, function(o) {
					if (o.group === i) {
						var d = e ? o.getZr().painter.getSvgDom().innerHTML : o.getRenderedCanvas(n(t)),
							f = o.getDom().getBoundingClientRect();
						s = r(f.left, s), l = r(f.top, l), u = a(f.right, u), h = a(f.bottom, h), c.push({
							dom: d,
							left: f.left,
							top: f.top
						})
					}
				}), s *= d, l *= d, u *= d, h *= d;
				var p = u - s,
					g = h - l,
					v = jp(),
					m = Kn(v, {
						renderer: e ? "svg" : "canvas"
					});
				if (m.resize({
						width: p,
						height: g
					}), e) {
					var y = "";
					return jx(c, function(t) {
						var e = t.left - s,
							i = t.top - l;
						y += '<g transform="translate(' + e + "," + i + ')">' + t.dom + "</g>"
					}), m.painter.getSvgRoot().innerHTML = y, t.connectedBackgroundColor && m.painter.setBackgroundColor(t.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL()
				}
				return t.connectedBackgroundColor && m.add(new by({
					shape: {
						x: 0,
						y: 0,
						width: p,
						height: g
					},
					style: {
						fill: t.connectedBackgroundColor
					}
				})), jx(c, function(t) {
					var e = new kn({
						style: {
							x: t.left * d - s,
							y: t.top * d - l,
							image: t.dom
						}
					});
					m.add(e)
				}), m.refreshImmediately(), v.toDataURL("image/" + (t && t.type || "png"))
			}
			return this.getDataURL(t)
		}
	}, pw.convertToPixel = _(Xl, "convertToPixel"), pw.convertFromPixel = _(Xl, "convertFromPixel"), pw.containPixel = function(t, e) {
		if (!this._disposed) {
			var i, n = this._model;
			return t = cr(n, t), f(t, function(t, n) {
				n.indexOf("Models") >= 0 && f(t, function(t) {
					var r = t.coordinateSystem;
					if (r && r.containPoint) i |= !!r.containPoint(e);
					else if ("seriesModels" === n) {
						var a = this._chartsMap[t.__viewId];
						a && a.containPoint && (i |= a.containPoint(e, t))
					}
				}, this)
			}, this), !!i
		}
	}, pw.getVisual = function(t, e) {
		var i = this._model;
		t = cr(i, t, {
			defaultMainType: "series"
		});
		var n = t.seriesModel,
			r = n.getData(),
			a = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? r.indexOfRawIndex(t.dataIndex) : null;
		return null != a ? r.getItemVisual(a, e) : r.getVisual(e)
	}, pw.getViewOfComponentModel = function(t) {
		return this._componentsMap[t.__viewId]
	}, pw.getViewOfSeriesModel = function(t) {
		return this._chartsMap[t.__viewId]
	};
	var gw = {
		prepareAndUpdate: function(t) {
			jl(this), gw.update.call(this, t)
		},
		update: function(t) {
			var e = this._model,
				i = this._api,
				n = this._zr,
				r = this._coordSysMgr,
				a = this._scheduler;
			if (e) {
				a.restoreData(e, t), a.performSeriesTasks(e), r.create(e, i), a.performDataProcessorTasks(e, t), ql(this, e), r.update(e, i), tu(e), a.performVisualTasks(e, t), eu(this, e, i, t);
				var o = e.get("backgroundColor") || "transparent";
				if (zp.canvasSupported) n.setBackgroundColor(o);
				else {
					var s = ti(o);
					o = ui(s, "rgb"), 0 === s[3] && (o = "transparent")
				}
				ru(e, i)
			}
		},
		updateTransform: function(t) {
			var e = this._model,
				i = this,
				n = this._api;
			if (e) {
				var r = [];
				e.eachComponent(function(a, o) {
					var s = i.getViewOfComponentModel(o);
					if (s && s.__alive)
						if (s.updateTransform) {
							var l = s.updateTransform(o, e, n, t);
							l && l.update && r.push(s)
						} else r.push(s)
				});
				var a = N();
				e.eachSeries(function(r) {
					var o = i._chartsMap[r.__viewId];
					if (o.updateTransform) {
						var s = o.updateTransform(r, e, n, t);
						s && s.update && a.set(r.uid, 1)
					} else a.set(r.uid, 1)
				}), tu(e), this._scheduler.performVisualTasks(e, t, {
					setDirty: !0,
					dirtyMap: a
				}), nu(i, e, n, t, a), ru(e, this._api)
			}
		},
		updateView: function(t) {
			var e = this._model;
			e && (hl.markUpdateMethod(t, "updateView"), tu(e), this._scheduler.performVisualTasks(e, t, {
				setDirty: !0
			}), eu(this, this._model, this._api, t), ru(e, this._api))
		},
		updateVisual: function(t) {
			gw.update.call(this, t)
		},
		updateLayout: function(t) {
			gw.update.call(this, t)
		}
	};
	pw.resize = function(t) {
		if (!this._disposed) {
			this._zr.resize(t);
			var e = this._model;
			if (this._loadingFX && this._loadingFX.resize(), e) {
				var i = e.resetOption("media"),
					n = t && t.silent;
				this[cw] = !0, i && jl(this), gw.update.call(this), this[cw] = !1, Kl.call(this, n), $l.call(this, n)
			}
		}
	}, pw.showLoading = function(t, e) {
		if (!this._disposed && (qx(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), Mw[t])) {
			var i = Mw[t](this._api, e),
				n = this._zr;
			this._loadingFX = i, n.add(i)
		}
	}, pw.hideLoading = function() {
		this._disposed || (this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null)
	}, pw.makeActionFromEvent = function(t) {
		var e = o({}, t);
		return e.type = yw[t.type], e
	}, pw.dispatchAction = function(t, e) {
		if (!this._disposed && (qx(e) || (e = {
				silent: !!e
			}), mw[t.type] && this._model)) {
			if (this[cw]) return void this._pendingActions.push(t);
			Zl.call(this, t, e.silent), e.flush ? this._zr.flush(!0) : e.flush !== !1 && zp.browser.weChat && this._throttledZrFlush(), Kl.call(this, e.silent), $l.call(this, e.silent)
		}
	}, pw.appendData = function(t) {
		if (!this._disposed) {
			var e = t.seriesIndex,
				i = this.getModel(),
				n = i.getSeriesByIndex(e);
			n.appendData(t), this._scheduler.unfinished = !0
		}
	}, pw.on = Wl("on", !1), pw.off = Wl("off", !1), pw.one = Wl("one", !1);
	var vw = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
	pw._initEvents = function() {
		jx(vw, function(t) {
			var e = function(e) {
				var i, n = this.getModel(),
					r = e.target,
					a = "globalout" === t;
				if (a) i = {};
				else if (r && null != r.dataIndex) {
					var s = r.dataModel || n.getSeriesByIndex(r.seriesIndex);
					i = s && s.getDataParams(r.dataIndex, r.dataType, r) || {}
				} else r && r.eventData && (i = o({}, r.eventData));
				if (i) {
					var l = i.componentType,
						u = i.componentIndex;
					("markLine" === l || "markPoint" === l || "markArea" === l) && (l = "series", u = i.seriesIndex);
					var h = l && null != u && n.getComponent(l, u),
						c = h && this["series" === h.mainType ? "_chartsMap" : "_componentsMap"][h.__viewId];
					i.event = e, i.type = t, this._ecEventProcessor.eventInfo = {
						targetEl: r,
						packedEvent: i,
						model: h,
						view: c
					}, this.trigger(t, i)
				}
			};
			e.zrEventfulCallAtLast = !0, this._zr.on(t, e, this)
		}, this), jx(yw, function(t, e) {
			this._messageCenter.on(e, function(t) {
				this.trigger(e, t)
			}, this)
		}, this)
	}, pw.isDisposed = function() {
		return this._disposed
	}, pw.clear = function() {
		this._disposed || this.setOption({
			series: []
		}, !0)
	}, pw.dispose = function() {
		if (!this._disposed) {
			this._disposed = !0, fr(this.getDom(), kw, "");
			var t = this._api,
				e = this._model;
			jx(this._componentsViews, function(i) {
				i.dispose(e, t)
			}), jx(this._chartsViews, function(i) {
				i.dispose(e, t)
			}), this._zr.dispose(), delete Iw[this.id]
		}
	}, c(Ul, ng), uu.prototype = {
		constructor: uu,
		normalizeQuery: function(t) {
			var e = {},
				i = {},
				n = {};
			if (b(t)) {
				var r = Zx(t);
				e.mainType = r.main || null, e.subType = r.sub || null
			} else {
				var a = ["Index", "Name", "Id"],
					o = {
						name: 1,
						dataIndex: 1,
						dataType: 1
					};
				f(t, function(t, r) {
					for (var s = !1, l = 0; l < a.length; l++) {
						var u = a[l],
							h = r.lastIndexOf(u);
						if (h > 0 && h === r.length - u.length) {
							var c = r.slice(0, h);
							"data" !== c && (e.mainType = c, e[u.toLowerCase()] = t, s = !0)
						}
					}
					o.hasOwnProperty(r) && (i[r] = t, s = !0), s || (n[r] = t)
				})
			}
			return {
				cptQuery: e,
				dataQuery: i,
				otherQuery: n
			}
		},
		filter: function(t, e) {
			function i(t, e, i, n) {
				return null == t[i] || e[n || i] === t[i]
			}
			var n = this.eventInfo;
			if (!n) return !0;
			var r = n.targetEl,
				a = n.packedEvent,
				o = n.model,
				s = n.view;
			if (!o || !s) return !0;
			var l = e.cptQuery,
				u = e.dataQuery;
			return i(l, o, "mainType") && i(l, o, "subType") && i(l, o, "index", "componentIndex") && i(l, o, "name") && i(l, o, "id") && i(u, a, "name") && i(u, a, "dataIndex") && i(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, r, a))
		},
		afterTrigger: function() {
			this.eventInfo = null
		}
	};
	var mw = {},
		yw = {},
		_w = [],
		xw = [],
		ww = [],
		bw = [],
		Sw = {},
		Mw = {},
		Iw = {},
		Tw = {},
		Cw = new Date - 0,
		Dw = new Date - 0,
		kw = "_echarts_instance_",
		Aw = fu;
	Iu(aw, vx), yu(q_), _u(ew, Z_), Cu("default", xx), wu({
		type: "highlight",
		event: "highlight",
		update: "highlight"
	}, V), wu({
		type: "downplay",
		event: "downplay",
		update: "downplay"
	}, V), mu("light", kx), mu("dark", Ox);
	var Pw = {};
	Bu.prototype = {
		constructor: Bu,
		add: function(t) {
			return this._add = t, this
		},
		update: function(t) {
			return this._update = t, this
		},
		remove: function(t) {
			return this._remove = t, this
		},
		execute: function() {
			var t, e = this._old,
				i = this._new,
				n = {},
				r = {},
				a = [],
				o = [];
			for (Ru(e, n, a, "_oldKeyGetter", this), Ru(i, r, o, "_newKeyGetter", this), t = 0; t < e.length; t++) {
				var s = a[t],
					l = r[s];
				if (null != l) {
					var u = l.length;
					u ? (1 === u && (r[s] = null), l = l.shift()) : r[s] = null, this._update && this._update(l, t)
				} else this._remove && this._remove(t)
			}
			for (var t = 0; t < o.length; t++) {
				var s = o[t];
				if (r.hasOwnProperty(s)) {
					var l = r[s];
					if (null == l) continue;
					if (l.length)
						for (var h = 0, u = l.length; u > h; h++) this._add && this._add(l[h]);
					else this._add && this._add(l)
				}
			}
		}
	};
	var Lw = N(["tooltip", "label", "itemName", "itemId", "seriesName"]),
		Ow = S,
		Ew = "undefined",
		zw = -1,
		Bw = "e\x00\x00",
		Rw = {
			"float": typeof Float64Array === Ew ? Array : Float64Array,
			"int": typeof Int32Array === Ew ? Array : Int32Array,
			ordinal: Array,
			number: Array,
			time: Array
		},
		Nw = typeof Uint32Array === Ew ? Array : Uint32Array,
		Fw = typeof Int32Array === Ew ? Array : Int32Array,
		Vw = typeof Uint16Array === Ew ? Array : Uint16Array,
		Hw = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"],
		Ww = ["_extent", "_approximateExtent", "_rawExtent"],
		Gw = function(t, e) {
			t = t || ["x", "y"];
			for (var i = {}, n = [], r = {}, a = 0; a < t.length; a++) {
				var o = t[a];
				b(o) ? o = new Wu({
					name: o
				}) : o instanceof Wu || (o = new Wu(o));
				var s = o.name;
				o.type = o.type || "float", o.coordDim || (o.coordDim = s, o.coordDimIndex = 0), o.otherDims = o.otherDims || {}, n.push(s), i[s] = o, o.index = a, o.createInvertedIndices && (r[s] = [])
			}
			this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this._indices = null, this._count = 0, this._rawCount = 0, this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this.hasItemVisual = {}, this._itemLayouts = [], this._graphicEls = [], this._chunkSize = 1e5, this._chunkCount = 0, this._rawData, this._rawExtent = {}, this._extent = {}, this._approximateExtent = {}, this._dimensionsSummary = Nu(this), this._invertedIndicesMap = r, this._calculationInfo = {}, this.userOutput = this._dimensionsSummary.userOutput
		},
		Uw = Gw.prototype;
	Uw.type = "list", Uw.hasItemOption = !0, Uw.getDimension = function(t) {
		return ("number" == typeof t || !isNaN(t) && !this._dimensionInfos.hasOwnProperty(t)) && (t = this.dimensions[t]), t
	}, Uw.getDimensionInfo = function(t) {
		return this._dimensionInfos[this.getDimension(t)]
	}, Uw.getDimensionsOnCoord = function() {
		return this._dimensionsSummary.dataDimsOnCoord.slice()
	}, Uw.mapDimension = function(t, e) {
		var i = this._dimensionsSummary;
		if (null == e) return i.encodeFirstDimNotExtra[t];
		var n = i.encode[t];
		return e === !0 ? (n || []).slice() : n && n[e]
	}, Uw.initData = function(t, e, i) {
		var n = rs.isInstance(t) || d(t);
		n && (t = new Us(t, this.dimensions.length)), this._rawData = t, this._storage = {}, this._indices = null, this._nameList = e || [], this._idList = [], this._nameRepeatCount = {}, i || (this.hasItemOption = !1), this.defaultDimValueGetter = J_[this._rawData.getSource().sourceFormat], this._dimValueGetter = i = i || this.defaultDimValueGetter, this._dimValueGetterArrayRows = J_.arrayRows, this._rawExtent = {}, this._initDataFromProvider(0, t.count()), t.pure && (this.hasItemOption = !1)
	}, Uw.getProvider = function() {
		return this._rawData
	}, Uw.appendData = function(t) {
		var e = this._rawData,
			i = this.count();
		e.appendData(t);
		var n = e.count();
		e.persistent || (n += i), this._initDataFromProvider(i, n)
	}, Uw.appendValues = function(t, e) {
		for (var i = this._chunkSize, n = this._storage, r = this.dimensions, a = r.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e ? e.length : 0), u = this._chunkCount, h = 0; a > h; h++) {
			var c = r[h];
			o[c] || (o[c] = eh()), n[c] || (n[c] = []), ju(n, this._dimensionInfos[c], i, u, l), this._chunkCount = n[c].length
		}
		for (var d = new Array(a), f = s; l > f; f++) {
			for (var p = f - s, g = Math.floor(f / i), v = f % i, m = 0; a > m; m++) {
				var c = r[m],
					y = this._dimValueGetterArrayRows(t[p] || d, c, p, m);
				n[c][g][v] = y;
				var _ = o[c];
				y < _[0] && (_[0] = y), y > _[1] && (_[1] = y)
			}
			e && (this._nameList[f] = e[p])
		}
		this._rawCount = this._count = l, this._extent = {}, Yu(this)
	}, Uw._initDataFromProvider = function(t, e) {
		if (!(t >= e)) {
			for (var i, n = this._chunkSize, r = this._rawData, a = this._storage, o = this.dimensions, s = o.length, l = this._dimensionInfos, u = this._nameList, h = this._idList, c = this._rawExtent, d = this._nameRepeatCount = {}, f = this._chunkCount, p = 0; s > p; p++) {
				var g = o[p];
				c[g] || (c[g] = eh());
				var v = l[g];
				0 === v.otherDims.itemName && (i = this._nameDimIdx = p), 0 === v.otherDims.itemId && (this._idDimIdx = p), a[g] || (a[g] = []), ju(a, v, n, f, e), this._chunkCount = a[g].length
			}
			for (var m = new Array(s), y = t; e > y; y++) {
				m = r.getItem(y, m);
				for (var _ = Math.floor(y / n), x = y % n, w = 0; s > w; w++) {
					var g = o[w],
						b = a[g][_],
						S = this._dimValueGetter(m, g, y, w);
					b[x] = S;
					var M = c[g];
					S < M[0] && (M[0] = S), S > M[1] && (M[1] = S)
				}
				if (!r.pure) {
					var I = u[y];
					if (m && null == I)
						if (null != m.name) u[y] = I = m.name;
						else if (null != i) {
						var T = o[i],
							C = a[T][_];
						if (C) {
							I = C[x];
							var D = l[T].ordinalMeta;
							D && D.categories.length && (I = D.categories[I])
						}
					}
					var k = null == m ? null : m.id;
					null == k && null != I && (d[I] = d[I] || 0, k = I, d[I] > 0 && (k += "__ec__" + d[I]), d[I]++), null != k && (h[y] = k)
				}
			}!r.persistent && r.clean && r.clean(), this._rawCount = this._count = e, this._extent = {}, Yu(this)
		}
	}, Uw.count = function() {
		return this._count
	}, Uw.getIndices = function() {
		var t, e = this._indices;
		if (e) {
			var i = e.constructor,
				n = this._count;
			if (i === Array) {
				t = new i(n);
				for (var r = 0; n > r; r++) t[r] = e[r]
			} else t = new i(e.buffer, 0, n)
		} else
			for (var i = Gu(this), t = new i(this.count()), r = 0; r < t.length; r++) t[r] = r;
		return t
	}, Uw.get = function(t, e) {
		if (!(e >= 0 && e < this._count)) return 0 / 0;
		var i = this._storage;
		if (!i[t]) return 0 / 0;
		e = this.getRawIndex(e);
		var n = Math.floor(e / this._chunkSize),
			r = e % this._chunkSize,
			a = i[t][n],
			o = a[r];
		return o
	}, Uw.getByRawIndex = function(t, e) {
		if (!(e >= 0 && e < this._rawCount)) return 0 / 0;
		var i = this._storage[t];
		if (!i) return 0 / 0;
		var n = Math.floor(e / this._chunkSize),
			r = e % this._chunkSize,
			a = i[n];
		return a[r]
	}, Uw._getFast = function(t, e) {
		var i = Math.floor(e / this._chunkSize),
			n = e % this._chunkSize,
			r = this._storage[t][i];
		return r[n]
	}, Uw.getValues = function(t, e) {
		var i = [];
		x(t) || (e = t, t = this.dimensions);
		for (var n = 0, r = t.length; r > n; n++) i.push(this.get(t[n], e));
		return i
	}, Uw.hasValue = function(t) {
		for (var e = this._dimensionsSummary.dataDimsOnCoord, i = 0, n = e.length; n > i; i++)
			if (isNaN(this.get(e[i], t))) return !1;
		return !0
	}, Uw.getDataExtent = function(t) {
		t = this.getDimension(t);
		var e = this._storage[t],
			i = eh();
		if (!e) return i;
		var n, r = this.count(),
			a = !this._indices;
		if (a) return this._rawExtent[t].slice();
		if (n = this._extent[t]) return n.slice();
		n = i;
		for (var o = n[0], s = n[1], l = 0; r > l; l++) {
			var u = this._getFast(t, this.getRawIndex(l));
			o > u && (o = u), u > s && (s = u)
		}
		return n = [o, s], this._extent[t] = n, n
	}, Uw.getApproximateExtent = function(t) {
		return t = this.getDimension(t), this._approximateExtent[t] || this.getDataExtent(t)
	}, Uw.setApproximateExtent = function(t, e) {
		e = this.getDimension(e), this._approximateExtent[e] = t.slice()
	}, Uw.getCalculationInfo = function(t) {
		return this._calculationInfo[t]
	}, Uw.setCalculationInfo = function(t, e) {
		Ow(t) ? o(this._calculationInfo, t) : this._calculationInfo[t] = e
	}, Uw.getSum = function(t) {
		var e = this._storage[t],
			i = 0;
		if (e)
			for (var n = 0, r = this.count(); r > n; n++) {
				var a = this.get(t, n);
				isNaN(a) || (i += a)
			}
		return i
	}, Uw.getMedian = function(t) {
		var e = [];
		this.each(t, function(t) {
			isNaN(t) || e.push(t)
		});
		var i = [].concat(e).sort(function(t, e) {
				return t - e
			}),
			n = this.count();
		return 0 === n ? 0 : n % 2 === 1 ? i[(n - 1) / 2] : (i[n / 2] + i[n / 2 - 1]) / 2
	}, Uw.rawIndexOf = function(t, e) {
		var i = t && this._invertedIndicesMap[t],
			n = i[e];
		return null == n || isNaN(n) ? zw : n
	}, Uw.indexOfName = function(t) {
		for (var e = 0, i = this.count(); i > e; e++)
			if (this.getName(e) === t) return e;
		return -1
	}, Uw.indexOfRawIndex = function(t) {
		if (t >= this._rawCount || 0 > t) return -1;
		if (!this._indices) return t;
		var e = this._indices,
			i = e[t];
		if (null != i && i < this._count && i === t) return t;
		for (var n = 0, r = this._count - 1; r >= n;) {
			var a = (n + r) / 2 | 0;
			if (e[a] < t) n = a + 1;
			else {
				if (!(e[a] > t)) return a;
				r = a - 1
			}
		}
		return -1
	}, Uw.indicesOfNearest = function(t, e, i) {
		var n = this._storage,
			r = n[t],
			a = [];
		if (!r) return a;
		null == i && (i = 1 / 0);
		for (var o = 1 / 0, s = -1, l = 0, u = 0, h = this.count(); h > u; u++) {
			var c = e - this.get(t, u),
				d = Math.abs(c);
			i >= d && ((o > d || d === o && c >= 0 && 0 > s) && (o = d, s = c, l = 0), c === s && (a[l++] = u))
		}
		return a.length = l, a
	}, Uw.getRawIndex = Zu, Uw.getRawDataItem = function(t) {
		if (this._rawData.persistent) return this._rawData.getItem(this.getRawIndex(t));
		for (var e = [], i = 0; i < this.dimensions.length; i++) {
			var n = this.dimensions[i];
			e.push(this.get(n, t))
		}
		return e
	}, Uw.getName = function(t) {
		var e = this.getRawIndex(t);
		return this._nameList[e] || qu(this, this._nameDimIdx, e) || ""
	}, Uw.getId = function(t) {
		return $u(this, this.getRawIndex(t))
	}, Uw.each = function(t, e, i, n) {
		if (this._count) {
			"function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this, t = p(Qu(t), this.getDimension, this);
			for (var r = t.length, a = 0; a < this.count(); a++) switch (r) {
				case 0:
					e.call(i, a);
					break;
				case 1:
					e.call(i, this.get(t[0], a), a);
					break;
				case 2:
					e.call(i, this.get(t[0], a), this.get(t[1], a), a);
					break;
				default:
					for (var o = 0, s = []; r > o; o++) s[o] = this.get(t[o], a);
					s[o] = a, e.apply(i, s)
			}
		}
	}, Uw.filterSelf = function(t, e, i, n) {
		if (this._count) {
			"function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this, t = p(Qu(t), this.getDimension, this);
			for (var r = this.count(), a = Gu(this), o = new a(r), s = [], l = t.length, u = 0, h = t[0], c = 0; r > c; c++) {
				var d, f = this.getRawIndex(c);
				if (0 === l) d = e.call(i, c);
				else if (1 === l) {
					var g = this._getFast(h, f);
					d = e.call(i, g, c)
				} else {
					for (var v = 0; l > v; v++) s[v] = this._getFast(h, f);
					s[v] = c, d = e.apply(i, s)
				}
				d && (o[u++] = f)
			}
			return r > u && (this._indices = o), this._count = u, this._extent = {}, this.getRawIndex = this._indices ? Ku : Zu, this
		}
	}, Uw.selectRange = function(t) {
		if (this._count) {
			var e = [];
			for (var i in t) t.hasOwnProperty(i) && e.push(i);
			var n = e.length;
			if (n) {
				var r = this.count(),
					a = Gu(this),
					o = new a(r),
					s = 0,
					l = e[0],
					u = t[l][0],
					h = t[l][1],
					c = !1;
				if (!this._indices) {
					var d = 0;
					if (1 === n) {
						for (var f = this._storage[e[0]], p = 0; p < this._chunkCount; p++)
							for (var g = f[p], v = Math.min(this._count - p * this._chunkSize, this._chunkSize), m = 0; v > m; m++) {
								var y = g[m];
								(y >= u && h >= y || isNaN(y)) && (o[s++] = d), d++
							}
						c = !0
					} else if (2 === n) {
						for (var f = this._storage[l], _ = this._storage[e[1]], x = t[e[1]][0], w = t[e[1]][1], p = 0; p < this._chunkCount; p++)
							for (var g = f[p], b = _[p], v = Math.min(this._count - p * this._chunkSize, this._chunkSize), m = 0; v > m; m++) {
								var y = g[m],
									S = b[m];
								(y >= u && h >= y || isNaN(y)) && (S >= x && w >= S || isNaN(S)) && (o[s++] = d), d++
							}
						c = !0
					}
				}
				if (!c)
					if (1 === n)
						for (var m = 0; r > m; m++) {
							var M = this.getRawIndex(m),
								y = this._getFast(l, M);
							(y >= u && h >= y || isNaN(y)) && (o[s++] = M)
						} else
							for (var m = 0; r > m; m++) {
								for (var I = !0, M = this.getRawIndex(m), p = 0; n > p; p++) {
									var T = e[p],
										y = this._getFast(i, M);
									(y < t[T][0] || y > t[T][1]) && (I = !1)
								}
								I && (o[s++] = this.getRawIndex(m))
							}
					return r > s && (this._indices = o), this._count = s, this._extent = {}, this.getRawIndex = this._indices ? Ku : Zu, this
			}
		}
	}, Uw.mapArray = function(t, e, i, n) {
		"function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this;
		var r = [];
		return this.each(t, function() {
			r.push(e && e.apply(this, arguments))
		}, i), r
	}, Uw.map = function(t, e, i, n) {
		i = i || n || this, t = p(Qu(t), this.getDimension, this);
		var r = Ju(this, t);
		r._indices = this._indices, r.getRawIndex = r._indices ? Ku : Zu;
		for (var a = r._storage, o = [], s = this._chunkSize, l = t.length, u = this.count(), h = [], c = r._rawExtent, d = 0; u > d; d++) {
			for (var f = 0; l > f; f++) h[f] = this.get(t[f], d);
			h[l] = d;
			var g = e && e.apply(i, h);
			if (null != g) {
				"object" != typeof g && (o[0] = g, g = o);
				for (var v = this.getRawIndex(d), m = Math.floor(v / s), y = v % s, _ = 0; _ < g.length; _++) {
					var x = t[_],
						w = g[_],
						b = c[x],
						S = a[x];
					S && (S[m][y] = w), w < b[0] && (b[0] = w), w > b[1] && (b[1] = w)
				}
			}
		}
		return r
	}, Uw.downSample = function(t, e, i, n) {
		for (var r = Ju(this, [t]), a = r._storage, o = [], s = Math.floor(1 / e), l = a[t], u = this.count(), h = this._chunkSize, c = r._rawExtent[t], d = new(Gu(this))(u), f = 0, p = 0; u > p; p += s) {
			s > u - p && (s = u - p, o.length = s);
			for (var g = 0; s > g; g++) {
				var v = this.getRawIndex(p + g),
					m = Math.floor(v / h),
					y = v % h;
				o[g] = l[m][y]
			}
			var _ = i(o),
				x = this.getRawIndex(Math.min(p + n(o, _) || 0, u - 1)),
				w = Math.floor(x / h),
				b = x % h;
			l[w][b] = _, _ < c[0] && (c[0] = _), _ > c[1] && (c[1] = _), d[f++] = x
		}
		return r._count = f, r._indices = d, r.getRawIndex = Ku, r
	}, Uw.getItemModel = function(t) {
		var e = this.hostModel;
		return new go(this.getRawDataItem(t), e, e && e.ecModel)
	}, Uw.diff = function(t) {
		var e = this;
		return new Bu(t ? t.getIndices() : [], this.getIndices(), function(e) {
			return $u(t, e)
		}, function(t) {
			return $u(e, t)
		})
	}, Uw.getVisual = function(t) {
		var e = this._visual;
		return e && e[t]
	}, Uw.setVisual = function(t, e) {
		if (Ow(t))
			for (var i in t) t.hasOwnProperty(i) && this.setVisual(i, t[i]);
		else this._visual = this._visual || {}, this._visual[t] = e
	}, Uw.setLayout = function(t, e) {
		if (Ow(t))
			for (var i in t) t.hasOwnProperty(i) && this.setLayout(i, t[i]);
		else this._layout[t] = e
	}, Uw.getLayout = function(t) {
		return this._layout[t]
	}, Uw.getItemLayout = function(t) {
		return this._itemLayouts[t]
	}, Uw.setItemLayout = function(t, e, i) {
		this._itemLayouts[t] = i ? o(this._itemLayouts[t] || {}, e) : e
	}, Uw.clearItemLayouts = function() {
		this._itemLayouts.length = 0
	}, Uw.getItemVisual = function(t, e, i) {
		var n = this._itemVisuals[t],
			r = n && n[e];
		return null != r || i ? r : this.getVisual(e)
	}, Uw.setItemVisual = function(t, e, i) {
		var n = this._itemVisuals[t] || {},
			r = this.hasItemVisual;
		if (this._itemVisuals[t] = n, Ow(e))
			for (var a in e) e.hasOwnProperty(a) && (n[a] = e[a], r[a] = !0);
		else n[e] = i, r[e] = !0
	}, Uw.clearAllVisual = function() {
		this._visual = {}, this._itemVisuals = [], this.hasItemVisual = {}
	};
	var Xw = function(t) {
		t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType
	};
	Uw.setItemGraphicEl = function(t, e) {
		var i = this.hostModel;
		e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = i && i.seriesIndex, "group" === e.type && e.traverse(Xw, e)), this._graphicEls[t] = e
	}, Uw.getItemGraphicEl = function(t) {
		return this._graphicEls[t]
	}, Uw.eachItemGraphicEl = function(t, e) {
		f(this._graphicEls, function(i, n) {
			i && t && t.call(e, i, n)
		})
	}, Uw.cloneShallow = function(t) {
		if (!t) {
			var e = p(this.dimensions, this.getDimensionInfo, this);
			t = new Gw(e, this.hostModel)
		}
		if (t._storage = this._storage, Xu(t, this), this._indices) {
			var i = this._indices.constructor;
			t._indices = new i(this._indices)
		} else t._indices = null;
		return t.getRawIndex = t._indices ? Ku : Zu, t
	}, Uw.wrapMethod = function(t, e) {
		var i = this[t];
		"function" == typeof i && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
			var t = i.apply(this, arguments);
			return e.apply(this, [t].concat(P(arguments)))
		})
	}, Uw.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], Uw.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
	var jw = function(t, e) {
			return e = e || {}, ih(e.coordDimensions || [], t, {
				dimsDef: e.dimensionsDefine || t.dimensionsDefine,
				encodeDef: e.encodeDefine || t.encodeDefine,
				dimCount: e.dimensionsCount,
				encodeDefaulter: e.encodeDefaulter,
				generateCoord: e.generateCoord,
				generateCoordCount: e.generateCoordCount
			})
		},
		Yw = {
			cartesian2d: function(t, e, i, n) {
				var r = t.getReferringComponents("xAxis")[0],
					a = t.getReferringComponents("yAxis")[0];
				e.coordSysDims = ["x", "y"], i.set("x", r), i.set("y", a), sh(r) && (n.set("x", r), e.firstCategoryDimIndex = 0), sh(a) && (n.set("y", a), null == e.firstCategoryDimIndex & (e.firstCategoryDimIndex = 1))
			},
			singleAxis: function(t, e, i, n) {
				var r = t.getReferringComponents("singleAxis")[0];
				e.coordSysDims = ["single"], i.set("single", r), sh(r) && (n.set("single", r), e.firstCategoryDimIndex = 0)
			},
			polar: function(t, e, i, n) {
				var r = t.getReferringComponents("polar")[0],
					a = r.findAxisModel("radiusAxis"),
					o = r.findAxisModel("angleAxis");
				e.coordSysDims = ["radius", "angle"], i.set("radius", a), i.set("angle", o), sh(a) && (n.set("radius", a), e.firstCategoryDimIndex = 0), sh(o) && (n.set("angle", o), null == e.firstCategoryDimIndex && (e.firstCategoryDimIndex = 1))
			},
			geo: function(t, e) {
				e.coordSysDims = ["lng", "lat"]
			},
			parallel: function(t, e, i, n) {
				var r = t.ecModel,
					a = r.getComponent("parallel", t.get("parallelIndex")),
					o = e.coordSysDims = a.dimensions.slice();
				f(a.parallelAxisIndex, function(t, a) {
					var s = r.getComponent("parallelAxis", t),
						l = o[a];
					i.set(l, s), sh(s) && null == e.firstCategoryDimIndex && (n.set(l, s), e.firstCategoryDimIndex = a)
				})
			}
		};
	ph.prototype.parse = function(t) {
		return t
	}, ph.prototype.getSetting = function(t) {
		return this._setting[t]
	}, ph.prototype.contain = function(t) {
		var e = this._extent;
		return t >= e[0] && t <= e[1]
	}, ph.prototype.normalize = function(t) {
		var e = this._extent;
		return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
	}, ph.prototype.scale = function(t) {
		var e = this._extent;
		return t * (e[1] - e[0]) + e[0]
	}, ph.prototype.unionExtent = function(t) {
		var e = this._extent;
		t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
	}, ph.prototype.unionExtentFromData = function(t, e) {
		this.unionExtent(t.getApproximateExtent(e))
	}, ph.prototype.getExtent = function() {
		return this._extent.slice()
	}, ph.prototype.setExtent = function(t, e) {
		var i = this._extent;
		isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e)
	}, ph.prototype.isBlank = function() {
		return this._isBlank
	}, ph.prototype.setBlank = function(t) {
		this._isBlank = t
	}, ph.prototype.getLabel = null, yr(ph), br(ph, {
		registerWhenExtend: !0
	}), gh.createByAxisModel = function(t) {
		var e = t.option,
			i = e.data,
			n = i && p(i, mh);
		return new gh({
			categories: n,
			needCollect: !n,
			deduplication: e.dedplication !== !1
		})
	};
	var qw = gh.prototype;
	qw.getOrdinal = function(t) {
		return vh(this).get(t)
	}, qw.parseAndCollect = function(t) {
		var e, i = this._needCollect;
		if ("string" != typeof t && !i) return t;
		if (i && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e;
		var n = vh(this);
		return e = n.get(t), null == e && (i ? (e = this.categories.length, this.categories[e] = t, n.set(t, e)) : e = 0 / 0), e
	};
	var Zw = ph.prototype,
		Kw = ph.extend({
			type: "ordinal",
			init: function(t, e) {
				(!t || x(t)) && (t = new gh({
					categories: t
				})), this._ordinalMeta = t, this._extent = e || [0, t.categories.length - 1]
			},
			parse: function(t) {
				return "string" == typeof t ? this._ordinalMeta.getOrdinal(t) : Math.round(t)
			},
			contain: function(t) {
				return t = this.parse(t), Zw.contain.call(this, t) && null != this._ordinalMeta.categories[t]
			},
			normalize: function(t) {
				return Zw.normalize.call(this, this.parse(t))
			},
			scale: function(t) {
				return Math.round(Zw.scale.call(this, t))
			},
			getTicks: function() {
				for (var t = [], e = this._extent, i = e[0]; i <= e[1];) t.push(i), i++;
				return t
			},
			getLabel: function(t) {
				return this.isBlank() ? void 0 : this._ordinalMeta.categories[t]
			},
			count: function() {
				return this._extent[1] - this._extent[0] + 1
			},
			unionExtentFromData: function(t, e) {
				this.unionExtent(t.getApproximateExtent(e))
			},
			getOrdinalMeta: function() {
				return this._ordinalMeta
			},
			niceTicks: V,
			niceExtent: V
		});
	Kw.create = function() {
		return new Kw
	};
	var $w = Mo,
		Qw = Mo,
		Jw = ph.extend({
			type: "interval",
			_interval: 0,
			_intervalPrecision: 2,
			setExtent: function(t, e) {
				var i = this._extent;
				isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e))
			},
			unionExtent: function(t) {
				var e = this._extent;
				t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), Jw.prototype.setExtent.call(this, e[0], e[1])
			},
			getInterval: function() {
				return this._interval
			},
			setInterval: function(t) {
				this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = _h(t)
			},
			getTicks: function(t) {
				var e = this._interval,
					i = this._extent,
					n = this._niceExtent,
					r = this._intervalPrecision,
					a = [];
				if (!e) return a;
				var o = 1e4;
				i[0] < n[0] && a.push(t ? Qw(n[0] - e, r) : i[0]);
				for (var s = n[0]; s <= n[1] && (a.push(s), s = Qw(s + e, r), s !== a[a.length - 1]);)
					if (a.length > o) return [];
				var l = a.length ? a[a.length - 1] : n[1];
				return i[1] > l && a.push(t ? Qw(l + e, r) : i[1]), a
			},
			getMinorTicks: function(t) {
				for (var e = this.getTicks(!0), i = [], n = this.getExtent(), r = 1; r < e.length; r++) {
					for (var a = e[r], o = e[r - 1], s = 0, l = [], u = a - o, h = u / t; t - 1 > s;) {
						var c = Mo(o + (s + 1) * h);
						c > n[0] && c < n[1] && l.push(c), s++
					}
					i.push(l)
				}
				return i
			},
			getLabel: function(t, e) {
				if (null == t) return "";
				var i = e && e.precision;
				return null == i ? i = Co(t) || 0 : "auto" === i && (i = this._intervalPrecision), t = Qw(t, i, !0), Fo(t)
			},
			niceTicks: function(t, e, i) {
				t = t || 5;
				var n = this._extent,
					r = n[1] - n[0];
				if (isFinite(r)) {
					0 > r && (r = -r, n.reverse());
					var a = yh(n, t, e, i);
					this._intervalPrecision = a.intervalPrecision, this._interval = a.interval, this._niceExtent = a.niceTickExtent
				}
			},
			niceExtent: function(t) {
				var e = this._extent;
				if (e[0] === e[1])
					if (0 !== e[0]) {
						var i = e[0];
						t.fixMax ? e[0] -= i / 2 : (e[1] += i / 2, e[0] -= i / 2)
					} else e[1] = 1;
				var n = e[1] - e[0];
				isFinite(n) || (e[0] = 0, e[1] = 1), this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);
				var r = this._interval;
				t.fixMin || (e[0] = Qw(Math.floor(e[0] / r) * r)), t.fixMax || (e[1] = Qw(Math.ceil(e[1] / r) * r))
			}
		});
	Jw.create = function() {
		return new Jw
	};
	var tb = "__ec_stack_",
		eb = .5,
		ib = "undefined" != typeof Float32Array ? Float32Array : Array,
		nb = ({
			seriesType: "bar",
			plan: lx(),
			reset: function(t) {
				function e(t, e) {
					for (var i, d = t.count, f = new ib(2 * d), p = new ib(2 * d), g = new ib(d), v = [], m = [], y = 0, _ = 0; null != (i = t.next());) m[h] = e.get(s, i), m[1 - h] = e.get(l, i), v = n.dataToPoint(m, null, v), p[y] = u ? r.x + r.width : v[0], f[y++] = v[0], p[y] = u ? v[1] : r.y + r.height, f[y++] = v[1], g[_++] = i;
					e.setLayout({
						largePoints: f,
						largeDataIndices: g,
						largeBackgroundPoints: p,
						barWidth: c,
						valueAxisStart: Ph(a, o, !1),
						backgroundStart: u ? r.x : r.y,
						valueAxisHorizontal: u
					})
				}
				if (kh(t) && Ah(t)) {
					var i = t.getData(),
						n = t.coordinateSystem,
						r = n.grid.getRect(),
						a = n.getBaseAxis(),
						o = n.getOtherAxis(a),
						s = i.mapDimension(o.dim),
						l = i.mapDimension(a.dim),
						u = o.isHorizontal(),
						h = u ? 0 : 1,
						c = Dh(Th([t]), a, t).width;
					return c > eb || (c = eb), {
						progress: e
					}
				}
			}
		}, Jw.prototype),
		rb = Math.ceil,
		ab = Math.floor,
		ob = 1e3,
		sb = 60 * ob,
		lb = 60 * sb,
		ub = 24 * lb,
		hb = function(t, e, i, n) {
			for (; n > i;) {
				var r = i + n >>> 1;
				t[r][1] < e ? i = r + 1 : n = r
			}
			return i
		},
		cb = Jw.extend({
			type: "time",
			getLabel: function(t) {
				var e = this._stepLvl,
					i = new Date(t);
				return jo(e[0], i, this.getSetting("useUTC"))
			},
			niceExtent: function(t) {
				var e = this._extent;
				if (e[0] === e[1] && (e[0] -= ub, e[1] += ub), e[1] === -1 / 0 && 1 / 0 === e[0]) {
					var i = new Date;
					e[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), e[0] = e[1] - ub
				}
				this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);
				var n = this._interval;
				t.fixMin || (e[0] = Mo(ab(e[0] / n) * n)), t.fixMax || (e[1] = Mo(rb(e[1] / n) * n))
			},
			niceTicks: function(t, e, i) {
				t = t || 10;
				var n = this._extent,
					r = n[1] - n[0],
					a = r / t;
				null != e && e > a && (a = e), null != i && a > i && (a = i);
				var o = db.length,
					s = hb(db, a, 0, o),
					l = db[Math.min(s, o - 1)],
					u = l[1];
				if ("year" === l[0]) {
					var h = r / u,
						c = zo(h / t, !0);
					u *= c
				}
				var d = this.getSetting("useUTC") ? 0 : 60 * new Date(+n[0] || +n[1]).getTimezoneOffset() * 1e3,
					f = [Math.round(rb((n[0] - d) / u) * u + d), Math.round(ab((n[1] - d) / u) * u + d)];
				wh(f, n), this._stepLvl = l, this._interval = u, this._niceExtent = f
			},
			parse: function(t) {
				return +Lo(t)
			}
		});
	f(["contain", "normalize"], function(t) {
		cb.prototype[t] = function(e) {
			return nb[t].call(this, this.parse(e))
		}
	});
	var db = [
		["hh:mm:ss", ob],
		["hh:mm:ss", 5 * ob],
		["hh:mm:ss", 10 * ob],
		["hh:mm:ss", 15 * ob],
		["hh:mm:ss", 30 * ob],
		["hh:mm\nMM-dd", sb],
		["hh:mm\nMM-dd", 5 * sb],
		["hh:mm\nMM-dd", 10 * sb],
		["hh:mm\nMM-dd", 15 * sb],
		["hh:mm\nMM-dd", 30 * sb],
		["hh:mm\nMM-dd", lb],
		["hh:mm\nMM-dd", 2 * lb],
		["hh:mm\nMM-dd", 6 * lb],
		["hh:mm\nMM-dd", 12 * lb],
		["MM-dd\nyyyy", ub],
		["MM-dd\nyyyy", 2 * ub],
		["MM-dd\nyyyy", 3 * ub],
		["MM-dd\nyyyy", 4 * ub],
		["MM-dd\nyyyy", 5 * ub],
		["MM-dd\nyyyy", 6 * ub],
		["week", 7 * ub],
		["MM-dd\nyyyy", 10 * ub],
		["week", 14 * ub],
		["week", 21 * ub],
		["month", 31 * ub],
		["week", 42 * ub],
		["month", 62 * ub],
		["week", 70 * ub],
		["quarter", 95 * ub],
		["month", 31 * ub * 4],
		["month", 31 * ub * 5],
		["half-year", 380 * ub / 2],
		["month", 31 * ub * 8],
		["month", 31 * ub * 10],
		["year", 380 * ub]
	];
	cb.create = function(t) {
		return new cb({
			useUTC: t.ecModel.get("useUTC")
		})
	};
	var fb = ph.prototype,
		pb = Jw.prototype,
		gb = Co,
		vb = Mo,
		mb = Math.floor,
		yb = Math.ceil,
		_b = Math.pow,
		xb = Math.log,
		wb = ph.extend({
			type: "log",
			base: 10,
			$constructor: function() {
				ph.apply(this, arguments), this._originalScale = new Jw
			},
			getTicks: function(t) {
				var e = this._originalScale,
					i = this._extent,
					n = e.getExtent();
				return p(pb.getTicks.call(this, t), function(t) {
					var r = Mo(_b(this.base, t));
					return r = t === i[0] && e.__fixMin ? Lh(r, n[0]) : r, r = t === i[1] && e.__fixMax ? Lh(r, n[1]) : r
				}, this)
			},
			getMinorTicks: pb.getMinorTicks,
			getLabel: pb.getLabel,
			scale: function(t) {
				return t = fb.scale.call(this, t), _b(this.base, t)
			},
			setExtent: function(t, e) {
				var i = this.base;
				t = xb(t) / xb(i), e = xb(e) / xb(i), pb.setExtent.call(this, t, e)
			},
			getExtent: function() {
				var t = this.base,
					e = fb.getExtent.call(this);
				e[0] = _b(t, e[0]), e[1] = _b(t, e[1]);
				var i = this._originalScale,
					n = i.getExtent();
				return i.__fixMin && (e[0] = Lh(e[0], n[0])), i.__fixMax && (e[1] = Lh(e[1], n[1])), e
			},
			unionExtent: function(t) {
				this._originalScale.unionExtent(t);
				var e = this.base;
				t[0] = xb(t[0]) / xb(e), t[1] = xb(t[1]) / xb(e), fb.unionExtent.call(this, t)
			},
			unionExtentFromData: function(t, e) {
				this.unionExtent(t.getApproximateExtent(e))
			},
			niceTicks: function(t) {
				t = t || 10;
				var e = this._extent,
					i = e[1] - e[0];
				if (!(1 / 0 === i || 0 >= i)) {
					var n = Oo(i),
						r = t / i * n;
					for (.5 >= r && (n *= 10); !isNaN(n) && Math.abs(n) < 1 && Math.abs(n) > 0;) n *= 10;
					var a = [Mo(yb(e[0] / n) * n), Mo(mb(e[1] / n) * n)];
					this._interval = n, this._niceExtent = a
				}
			},
			niceExtent: function(t) {
				pb.niceExtent.call(this, t);
				var e = this._originalScale;
				e.__fixMin = t.fixMin, e.__fixMax = t.fixMax
			}
		});
	f(["contain", "normalize"], function(t) {
		wb.prototype[t] = function(e) {
			return e = xb(e) / xb(this.base), fb[t].call(this, e)
		}
	}), wb.create = function() {
		return new wb
	};
	var bb = {
			getMin: function(t) {
				var e = this.option,
					i = t || null == e.rangeStart ? e.min : e.rangeStart;
				return this.axis && null != i && "dataMin" !== i && "function" != typeof i && !C(i) && (i = this.axis.scale.parse(i)), i
			},
			getMax: function(t) {
				var e = this.option,
					i = t || null == e.rangeEnd ? e.max : e.rangeEnd;
				return this.axis && null != i && "dataMax" !== i && "function" != typeof i && !C(i) && (i = this.axis.scale.parse(i)), i
			},
			getNeedCrossZero: function() {
				var t = this.option;
				return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale
			},
			getCoordSysModel: V,
			setRange: function(t, e) {
				this.option.rangeStart = t, this.option.rangeEnd = e
			},
			resetRange: function() {
				this.option.rangeStart = this.option.rangeEnd = null
			}
		},
		Sb = va({
			type: "triangle",
			shape: {
				cx: 0,
				cy: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var i = e.cx,
					n = e.cy,
					r = e.width / 2,
					a = e.height / 2;
				t.moveTo(i, n - a), t.lineTo(i + r, n + a), t.lineTo(i - r, n + a), t.closePath()
			}
		}),
		Mb = va({
			type: "diamond",
			shape: {
				cx: 0,
				cy: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var i = e.cx,
					n = e.cy,
					r = e.width / 2,
					a = e.height / 2;
				t.moveTo(i, n - a), t.lineTo(i + r, n), t.lineTo(i, n + a), t.lineTo(i - r, n), t.closePath()
			}
		}),
		Ib = va({
			type: "pin",
			shape: {
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var i = e.x,
					n = e.y,
					r = e.width / 5 * 3,
					a = Math.max(r, e.height),
					o = r / 2,
					s = o * o / (a - o),
					l = n - a + o + s,
					u = Math.asin(s / o),
					h = Math.cos(u) * o,
					c = Math.sin(u),
					d = Math.cos(u),
					f = .6 * o,
					p = .7 * o;
				t.moveTo(i - h, l + s), t.arc(i, l, o, Math.PI - u, 2 * Math.PI + u), t.bezierCurveTo(i + h - c * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - h + c * f, l + s + d * f, i - h, l + s), t.closePath()
			}
		}),
		Tb = va({
			type: "arrow",
			shape: {
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var i = e.height,
					n = e.width,
					r = e.x,
					a = e.y,
					o = n / 3 * 2;
				t.moveTo(r, a), t.lineTo(r + o, a + i), t.lineTo(r, a + i / 4 * 3), t.lineTo(r - o, a + i), t.lineTo(r, a), t.closePath()
			}
		}),
		Cb = {
			line: My,
			rect: by,
			roundRect: by,
			square: by,
			circle: cy,
			diamond: Mb,
			pin: Ib,
			arrow: Tb,
			triangle: Sb
		},
		Db = {
			line: function(t, e, i, n, r) {
				r.x1 = t, r.y1 = e + n / 2, r.x2 = t + i, r.y2 = e + n / 2
			},
			rect: function(t, e, i, n, r) {
				r.x = t, r.y = e, r.width = i, r.height = n
			},
			roundRect: function(t, e, i, n, r) {
				r.x = t, r.y = e, r.width = i, r.height = n, r.r = Math.min(i, n) / 4
			},
			square: function(t, e, i, n, r) {
				var a = Math.min(i, n);
				r.x = t, r.y = e, r.width = a, r.height = a
			},
			circle: function(t, e, i, n, r) {
				r.cx = t + i / 2, r.cy = e + n / 2, r.r = Math.min(i, n) / 2
			},
			diamond: function(t, e, i, n, r) {
				r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r.height = n
			},
			pin: function(t, e, i, n, r) {
				r.x = t + i / 2, r.y = e + n / 2, r.width = i, r.height = n
			},
			arrow: function(t, e, i, n, r) {
				r.x = t + i / 2, r.y = e + n / 2, r.width = i, r.height = n
			},
			triangle: function(t, e, i, n, r) {
				r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r.height = n
			}
		},
		kb = {};
	f(Cb, function(t, e) {
		kb[e] = new t
	});
	var Ab = va({
			type: "symbol",
			shape: {
				symbolType: "",
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			calculateTextPosition: function(t, e, i) {
				var n = $i(t, e, i),
					r = this.shape;
				return r && "pin" === r.symbolType && "inside" === e.textPosition && (n.y = i.y + .4 * i.height), n
			},
			buildPath: function(t, e, i) {
				var n = e.symbolType;
				if ("none" !== n) {
					var r = kb[n];
					r || (n = "rect", r = kb[n]), Db[n](e.x, e.y, e.width, e.height, r.shape), r.buildPath(t, r.shape, i)
				}
			}
		}),
		Pb = {
			isDimensionStacked: uh,
			enableDataStack: lh,
			getStackedDimension: hh
		},
		Lb = (Object.freeze || Object)({
			createList: Gh,
			getLayoutRect: Qo,
			dataStack: Pb,
			createScale: Uh,
			mixinAxisModelCommonMethods: Xh,
			completeDimensions: ih,
			createDimensions: jw,
			createSymbol: Wh
		}),
		Ob = 1e-8;
	qh.prototype = {
		constructor: qh,
		properties: null,
		getBoundingRect: function() {
			var t = this._rect;
			if (t) return t;
			for (var e = Number.MAX_VALUE, i = [e, e], n = [-e, -e], r = [], a = [], o = this.geometries, s = 0; s < o.length; s++)
				if ("polygon" === o[s].type) {
					var l = o[s].exterior;
					Rr(l, r, a), oe(i, i, r), se(n, n, a)
				}
			return 0 === s && (i[0] = i[1] = n[0] = n[1] = 0), this._rect = new Ti(i[0], i[1], n[0] - i[0], n[1] - i[1])
		},
		contain: function(t) {
			var e = this.getBoundingRect(),
				i = this.geometries;
			if (!e.contain(t[0], t[1])) return !1;
			t: for (var n = 0, r = i.length; r > n; n++)
				if ("polygon" === i[n].type) {
					var a = i[n].exterior,
						o = i[n].interiors;
					if (Yh(a, t[0], t[1])) {
						for (var s = 0; s < (o ? o.length : 0); s++)
							if (Yh(o[s])) continue t;
						return !0
					}
				}
			return !1
		},
		transformTo: function(t, e, i, n) {
			var r = this.getBoundingRect(),
				a = r.width / r.height;
			i ? n || (n = i / a) : i = a * n;
			for (var o = new Ti(t, e, i, n), s = r.calculateTransform(o), l = this.geometries, u = 0; u < l.length; u++)
				if ("polygon" === l[u].type) {
					for (var h = l[u].exterior, c = l[u].interiors, d = 0; d < h.length; d++) ae(h[d], h[d], s);
					for (var f = 0; f < (c ? c.length : 0); f++)
						for (var d = 0; d < c[f].length; d++) ae(c[f][d], c[f][d], s)
				}
			r = this._rect, r.copy(o), this.center = [r.x + r.width / 2, r.y + r.height / 2]
		},
		cloneShallow: function(t) {
			null == t && (t = this.name);
			var e = new qh(t, this.geometries, this.center);
			return e._rect = this._rect, e.transformTo = null, e
		}
	};
	var Eb = function(t, e) {
			return Zh(t), p(v(t.features, function(t) {
				return t.geometry && t.properties && t.geometry.coordinates.length > 0
			}), function(t) {
				var i = t.properties,
					n = t.geometry,
					r = n.coordinates,
					a = [];
				"Polygon" === n.type && a.push({
					type: "polygon",
					exterior: r[0],
					interiors: r.slice(1)
				}), "MultiPolygon" === n.type && f(r, function(t) {
					t[0] && a.push({
						type: "polygon",
						exterior: t[0],
						interiors: t.slice(1)
					})
				});
				var o = new qh(i[e || "name"], a, i.cp);
				return o.properties = i, o
			})
		},
		zb = hr(),
		Bb = [0, 1],
		Rb = function(t, e, i) {
			this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1
		};
	Rb.prototype = {
		constructor: Rb,
		contain: function(t) {
			var e = this._extent,
				i = Math.min(e[0], e[1]),
				n = Math.max(e[0], e[1]);
			return t >= i && n >= t
		},
		containData: function(t) {
			return this.scale.contain(t)
		},
		getExtent: function() {
			return this._extent.slice()
		},
		getPixelPrecision: function(t) {
			return Do(t || this.scale.getExtent(), this._extent)
		},
		setExtent: function(t, e) {
			var i = this._extent;
			i[0] = t, i[1] = e
		},
		dataToCoord: function(t, e) {
			var i = this._extent,
				n = this.scale;
			return t = n.normalize(t), this.onBand && "ordinal" === n.type && (i = i.slice(), cc(i, n.count())), bo(t, Bb, i, e)
		},
		coordToData: function(t, e) {
			var i = this._extent,
				n = this.scale;
			this.onBand && "ordinal" === n.type && (i = i.slice(), cc(i, n.count()));
			var r = bo(t, i, Bb, e);
			return this.scale.scale(r)
		},
		pointToData: function() {},
		getTicksCoords: function(t) {
			t = t || {};
			var e = t.tickModel || this.getTickModel(),
				i = Qh(this, e),
				n = i.ticks,
				r = p(n, function(t) {
					return {
						coord: this.dataToCoord(t),
						tickValue: t
					}
				}, this),
				a = e.get("alignWithLabel");
			return dc(this, r, a, t.clamp), r
		},
		getMinorTicksCoords: function() {
			if ("ordinal" === this.scale.type) return [];
			var t = this.model.getModel("minorTick"),
				e = t.get("splitNumber");
			e > 0 && 100 > e || (e = 5);
			var i = this.scale.getMinorTicks(e),
				n = p(i, function(t) {
					return p(t, function(t) {
						return {
							coord: this.dataToCoord(t),
							tickValue: t
						}
					}, this)
				}, this);
			return n
		},
		getViewLabels: function() {
			return $h(this).labels
		},
		getLabelModel: function() {
			return this.model.getModel("axisLabel")
		},
		getTickModel: function() {
			return this.model.getModel("axisTick")
		},
		getBandWidth: function() {
			var t = this._extent,
				e = this.scale.getExtent(),
				i = e[1] - e[0] + (this.onBand ? 1 : 0);
			0 === i && (i = 1);
			var n = Math.abs(t[1] - t[0]);
			return Math.abs(n) / i
		},
		isHorizontal: null,
		getRotate: null,
		calculateCategoryInterval: function() {
			return sc(this)
		}
	};
	var Nb = Eb,
		Fb = {};
	f(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function(t) {
		Fb[t] = Zp[t]
	});
	var Vb = {};
	f(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "registerShape", "getShapeClass", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], function(t) {
		Vb[t] = Yy[t]
	});
	var Hb = function(t) {
			this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this.data, this.edgeData
		},
		Wb = Hb.prototype;
	Wb.type = "graph", Wb.isDirected = function() {
		return this._directed
	}, Wb.addNode = function(t, e) {
		t = null == t ? "" + e : "" + t;
		var i = this._nodesMap;
		if (!i[fc(t)]) {
			var n = new pc(t, e);
			return n.hostGraph = this, this.nodes.push(n), i[fc(t)] = n, n
		}
	}, Wb.getNodeByIndex = function(t) {
		var e = this.data.getRawIndex(t);
		return this.nodes[e]
	}, Wb.getNodeById = function(t) {
		return this._nodesMap[fc(t)]
	}, Wb.addEdge = function(t, e, i) {
		var n = this._nodesMap,
			r = this._edgesMap;
		if ("number" == typeof t && (t = this.nodes[t]), "number" == typeof e && (e = this.nodes[e]), pc.isInstance(t) || (t = n[fc(t)]), pc.isInstance(e) || (e = n[fc(e)]), t && e) {
			var a = t.id + "-" + e.id,
				o = new gc(t, e, i);
			return o.hostGraph = this, this._directed && (t.outEdges.push(o), e.inEdges.push(o)), t.edges.push(o), t !== e && e.edges.push(o), this.edges.push(o), r[a] = o, o
		}
	}, Wb.getEdgeByIndex = function(t) {
		var e = this.edgeData.getRawIndex(t);
		return this.edges[e]
	}, Wb.getEdge = function(t, e) {
		pc.isInstance(t) && (t = t.id), pc.isInstance(e) && (e = e.id);
		var i = this._edgesMap;
		return this._directed ? i[t + "-" + e] : i[t + "-" + e] || i[e + "-" + t]
	}, Wb.eachNode = function(t, e) {
		for (var i = this.nodes, n = i.length, r = 0; n > r; r++) i[r].dataIndex >= 0 && t.call(e, i[r], r)
	}, Wb.eachEdge = function(t, e) {
		for (var i = this.edges, n = i.length, r = 0; n > r; r++) i[r].dataIndex >= 0 && i[r].node1.dataIndex >= 0 && i[r].node2.dataIndex >= 0 && t.call(e, i[r], r)
	}, Wb.breadthFirstTraverse = function(t, e, i, n) {
		if (pc.isInstance(e) || (e = this._nodesMap[fc(e)]), e) {
			for (var r = "out" === i ? "outEdges" : "in" === i ? "inEdges" : "edges", a = 0; a < this.nodes.length; a++) this.nodes[a].__visited = !1;
			if (!t.call(n, e, null))
				for (var o = [e]; o.length;)
					for (var s = o.shift(), l = s[r], a = 0; a < l.length; a++) {
						var u = l[a],
							h = u.node1 === s ? u.node2 : u.node1;
						if (!h.__visited) {
							if (t.call(n, h, s)) return;
							o.push(h), h.__visited = !0
						}
					}
		}
	}, Wb.update = function() {
		for (var t = this.data, e = this.edgeData, i = this.nodes, n = this.edges, r = 0, a = i.length; a > r; r++) i[r].dataIndex = -1;
		for (var r = 0, a = t.count(); a > r; r++) i[t.getRawIndex(r)].dataIndex = r;
		e.filterSelf(function(t) {
			var i = n[e.getRawIndex(t)];
			return i.node1.dataIndex >= 0 && i.node2.dataIndex >= 0
		});
		for (var r = 0, a = n.length; a > r; r++) n[r].dataIndex = -1;
		for (var r = 0, a = e.count(); a > r; r++) n[e.getRawIndex(r)].dataIndex = r
	}, Wb.clone = function() {
		for (var t = new Hb(this._directed), e = this.nodes, i = this.edges, n = 0; n < e.length; n++) t.addNode(e[n].id, e[n].dataIndex);
		for (var n = 0; n < i.length; n++) {
			var r = i[n];
			t.addEdge(r.node1.id, r.node2.id, r.dataIndex)
		}
		return t
	}, pc.prototype = {
		constructor: pc,
		degree: function() {
			return this.edges.length
		},
		inDegree: function() {
			return this.inEdges.length
		},
		outDegree: function() {
			return this.outEdges.length
		},
		getModel: function(t) {
			if (!(this.dataIndex < 0)) {
				var e = this.hostGraph,
					i = e.data.getItemModel(this.dataIndex);
				return i.getModel(t)
			}
		}
	}, gc.prototype.getModel = function(t) {
		if (!(this.dataIndex < 0)) {
			var e = this.hostGraph,
				i = e.edgeData.getItemModel(this.dataIndex);
			return i.getModel(t)
		}
	};
	var Gb = function(t, e) {
		return {
			getValue: function(i) {
				var n = this[t][e];
				return n.get(n.getDimension(i || "value"), this.dataIndex)
			},
			setVisual: function(i, n) {
				this.dataIndex >= 0 && this[t][e].setItemVisual(this.dataIndex, i, n)
			},
			getVisual: function(i, n) {
				return this[t][e].getItemVisual(this.dataIndex, i, n)
			},
			setLayout: function(i, n) {
				this.dataIndex >= 0 && this[t][e].setItemLayout(this.dataIndex, i, n)
			},
			getLayout: function() {
				return this[t][e].getItemLayout(this.dataIndex)
			},
			getGraphicEl: function() {
				return this[t][e].getItemGraphicEl(this.dataIndex)
			},
			getRawIndex: function() {
				return this[t][e].getRawIndex(this.dataIndex)
			}
		}
	};
	c(pc, Gb("hostGraph", "data")), c(gc, Gb("hostGraph", "edgeData")), Hb.Node = pc, Hb.Edge = gc, _r(pc), _r(gc);
	var Ub = f,
		Xb = "\x00__link_datas",
		jb = "\x00__link_mainData",
		Yb = function(t, e, i, n, r) {
			for (var a = new Hb(n), o = 0; o < t.length; o++) a.addNode(D(t[o].id, t[o].name, o), o);
			for (var s = [], l = [], h = 0, o = 0; o < e.length; o++) {
				var c = e[o],
					d = c.source,
					f = c.target;
				a.addEdge(d, f, h) && (l.push(c), s.push(D(c.id, d + " > " + f)), h++)
			}
			var p, g = i.get("coordinateSystem");
			if ("cartesian2d" === g || "polar" === g) p = ch(t, i);
			else {
				var v = Is.get(g),
					m = v && "view" !== v.type ? v.dimensions || [] : [];
				u(m, "value") < 0 && m.concat(["value"]);
				var y = jw(t, {
					coordDimensions: m
				});
				p = new Gw(y, i), p.initData(t)
			}
			var _ = new Gw(["value"], i);
			return _.initData(l, s), r && r(p, _), vc({
				mainData: p,
				struct: a,
				structAttr: "graph",
				datas: {
					node: p,
					edge: _
				},
				datasAttr: {
					node: "data",
					edge: "edgeData"
				}
			}), a.update(), a
		},
		qb = "-->",
		Zb = function(t) {
			return t.get("autoCurveness") || null
		},
		Kb = function(t, e) {
			var i = Zb(t),
				n = 20,
				r = [];
			if ("number" == typeof i) n = i;
			else if (x(i)) return void(t.__curvenessList = i);
			e > n && (n = e);
			var a = n % 2 ? n + 2 : n + 3;
			r = [];
			for (var o = 0; a > o; o++) r.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
			t.__curvenessList = r
		},
		$b = function(t, e, i) {
			var n = [t.id, t.dataIndex].join("."),
				r = [e.id, e.dataIndex].join(".");
			return [i.uid, n, r].join(qb)
		},
		Qb = function(t) {
			var e = t.split(qb);
			return [e[0], e[2], e[1]].join(qb)
		},
		Jb = function(t, e) {
			var i = $b(t.node1, t.node2, e);
			return e.__edgeMap[i]
		},
		tS = function(t, e) {
			var i = eS($b(t.node1, t.node2, e), e),
				n = eS($b(t.node2, t.node1, e), e);
			return i + n
		},
		eS = function(t, e) {
			var i = e.__edgeMap;
			return i[t] ? i[t].length : 0
		},
		iS = Au({
			type: "series.graph",
			init: function(t) {
				function e() {
					return i._categoriesData
				}
				iS.superApply(this, "init", arguments);
				var i = this;
				this.legendVisualProvider = new Mc(e, e), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
			},
			mergeOption: function(t) {
				iS.superApply(this, "mergeOption", arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
			},
			mergeDefaultAndTheme: function(t) {
				iS.superApply(this, "mergeDefaultAndTheme", arguments), ir(t, ["edgeLabel"], ["show"])
			},
			getInitialData: function(t, e) {
				function i(t, i) {
					function n(t) {
						return t = this.parsePath(t), t && "label" === t[0] ? o : t && "emphasis" === t[0] && "label" === t[1] ? l : this.parentModel
					}
					t.wrapMethod("getItemModel", function(t) {
						var e = a._categoriesModels,
							i = t.getShallow("category"),
							n = e[i];
						return n && (n.parentModel = t.parentModel, t.parentModel = n), t
					});
					var r = a.getModel("edgeLabel"),
						o = new go({
							label: r.option
						}, r.parentModel, e),
						s = a.getModel("emphasis.edgeLabel"),
						l = new go({
							emphasis: {
								label: s.option
							}
						}, s.parentModel, e);
					i.wrapMethod("getItemModel", function(t) {
						return t.customizeGetParent(n), t
					})
				}
				var n = t.edges || t.links || [],
					r = t.data || t.nodes || [],
					a = this;
				if (r && n) {
					Ic(this);
					var o = Yb(r, n, this, !0, i);
					return f(o.edges, function(t) {
						Tc(t.node1, t.node2, this, t.dataIndex)
					}, this), o.data
				}
			},
			getGraph: function() {
				return this.getData().graph
			},
			getEdgeData: function() {
				return this.getGraph().edgeData
			},
			getCategoriesData: function() {
				return this._categoriesData
			},
			formatTooltip: function(t, e, i) {
				if ("edge" === i) {
					var n = this.getData(),
						r = this.getDataParams(t, i),
						a = n.graph.getEdgeByIndex(t),
						o = n.getName(a.node1.dataIndex),
						s = n.getName(a.node2.dataIndex),
						l = [];
					return null != o && l.push(o), null != s && l.push(s), l = Ho(l.join(" > ")), r.value && (l += " : " + Ho(r.value)), l
				}
				return iS.superApply(this, "formatTooltip", arguments)
			},
			_updateCategoriesData: function() {
				var t = p(this.option.categories || [], function(t) {
						return null != t.value ? t : o({
							value: 0
						}, t)
					}),
					e = new Gw(["value"], this);
				e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(function(t) {
					return e.getItemModel(t, !0)
				})
			},
			setZoom: function(t) {
				this.option.zoom = t
			},
			setCenter: function(t) {
				this.option.center = t
			},
			isAnimationEnabled: function() {
				return iS.superCall(this, "isAnimationEnabled") && !("force" === this.get("layout") && this.get("force.layoutAnimation"))
			},
			defaultOption: {
				zlevel: 0,
				z: 2,
				coordinateSystem: "view",
				legendHoverLink: !0,
				hoverAnimation: !0,
				layout: null,
				focusNodeAdjacency: !1,
				circular: {
					rotateLabel: !1
				},
				force: {
					initLayout: null,
					repulsion: [0, 50],
					gravity: .1,
					friction: .6,
					edgeLength: 30,
					layoutAnimation: !0
				},
				left: "center",
				top: "center",
				symbol: "circle",
				symbolSize: 10,
				edgeSymbol: ["none", "none"],
				edgeSymbolSize: 10,
				edgeLabel: {
					position: "middle",
					distance: 5
				},
				draggable: !1,
				roam: !1,
				center: null,
				zoom: 1,
				nodeScaleRatio: .6,
				label: {
					show: !1,
					formatter: "{b}"
				},
				itemStyle: {},
				lineStyle: {
					color: "#aaa",
					width: 1,
					opacity: .5
				},
				emphasis: {
					label: {
						show: !0
					}
				}
			}
		}),
		nS = kc.prototype,
		rS = kc.getSymbolSize = function(t, e) {
			var i = t.getItemVisual(e, "symbolSize");
			return i instanceof Array ? i.slice() : [+i, +i]
		};
	nS._createSymbol = function(t, e, i, n, r) {
		this.removeAll();
		var a = e.getItemVisual(i, "color"),
			o = Wh(t, -1, -1, 2, 2, a, r);
		o.attr({
			z2: 100,
			culling: !0,
			scale: Ac(n)
		}), o.drift = Pc, this._symbolType = t, this.add(o)
	}, nS.stopSymbolAnimation = function(t) {
		this.childAt(0).stopAnimation(t)
	}, nS.getSymbolPath = function() {
		return this.childAt(0)
	}, nS.getScale = function() {
		return this.childAt(0).scale
	}, nS.highlight = function() {
		this.childAt(0).trigger("emphasis")
	}, nS.downplay = function() {
		this.childAt(0).trigger("normal")
	}, nS.setZ = function(t, e) {
		var i = this.childAt(0);
		i.zlevel = t, i.z = e
	}, nS.setDraggable = function(t) {
		var e = this.childAt(0);
		e.draggable = t, e.cursor = t ? "move" : e.cursor
	}, nS.updateData = function(t, e, i) {
		this.silent = !1;
		var n = t.getItemVisual(e, "symbol") || "circle",
			r = t.hostModel,
			a = rS(t, e),
			o = n !== this._symbolType;
		if (o) {
			var s = t.getItemVisual(e, "symbolKeepAspect");
			this._createSymbol(n, t, e, a, s)
		} else {
			var l = this.childAt(0);
			l.silent = !1, eo(l, {
				scale: Ac(a)
			}, r, e)
		}
		if (this._updateCommon(t, e, a, i), o) {
			var l = this.childAt(0),
				u = i && i.fadeIn,
				h = {
					scale: l.scale.slice()
				};
			u && (h.style = {
				opacity: l.style.opacity
			}), l.scale = [0, 0], u && (l.style.opacity = 0), io(l, h, r, e)
		}
		this._seriesModel = r
	};
	var aS = ["itemStyle"],
		oS = ["emphasis", "itemStyle"],
		sS = ["label"],
		lS = ["emphasis", "label"];
	nS._updateCommon = function(t, e, i, n) {
		function r(e) {
			return b ? t.getName(e) : Dc(t, e)
		}
		var a = this.childAt(0),
			s = t.hostModel,
			l = t.getItemVisual(e, "color");
		"image" !== a.type ? a.useStyle({
			strokeNoScale: !0
		}) : a.setStyle({
			opacity: 1,
			shadowBlur: null,
			shadowOffsetX: null,
			shadowOffsetY: null,
			shadowColor: null
		});
		var u = n && n.itemStyle,
			h = n && n.hoverItemStyle,
			c = n && n.symbolOffset,
			d = n && n.labelModel,
			f = n && n.hoverLabelModel,
			p = n && n.hoverAnimation,
			g = n && n.cursorStyle;
		if (!n || t.hasItemOption) {
			var v = n && n.itemModel ? n.itemModel : t.getItemModel(e);
			u = v.getModel(aS).getItemStyle(["color"]), h = v.getModel(oS).getItemStyle(), c = v.getShallow("symbolOffset"), d = v.getModel(sS), f = v.getModel(lS), p = v.getShallow("hoverAnimation"), g = v.getShallow("cursor")
		} else h = o({}, h);
		var m = a.style,
			y = t.getItemVisual(e, "symbolRotate");
		a.attr("rotation", (y || 0) * Math.PI / 180 || 0), c && a.attr("position", [So(c[0], i[0]), So(c[1], i[1])]), g && a.attr("cursor", g), a.setColor(l, n && n.symbolInnerColor), a.setStyle(u);
		var _ = t.getItemVisual(e, "opacity");
		null != _ && (m.opacity = _);
		var x = t.getItemVisual(e, "liftZ"),
			w = a.__z2Origin;
		null != x ? null == w && (a.__z2Origin = a.z2, a.z2 += x) : null != w && (a.z2 = w, a.__z2Origin = null);
		var b = n && n.useNameLabel;
		Ga(m, h, d, f, {
			labelFetcher: s,
			labelDataIndex: e,
			defaultText: r,
			isRectText: !0,
			autoColor: l
		}), a.__symbolOriginalScale = Ac(i), a.hoverStyle = h, a.highDownOnUpdate = p && s.isAnimationEnabled() ? Lc : null, Fa(a)
	}, nS.fadeOut = function(t, e) {
		var i = this.childAt(0);
		this.silent = i.silent = !0, !(e && e.keepLabel) && (i.style.text = null), eo(i, {
			style: {
				opacity: 0
			},
			scale: [0, 0]
		}, this._seriesModel, this.dataIndex, t)
	}, h(kc, Zg);
	var uS = Oc.prototype;
	uS.updateData = function(t, e) {
		e = zc(e);
		var i = this.group,
			n = t.hostModel,
			r = this._data,
			a = this._symbolCtor,
			o = Bc(t);
		r || i.removeAll(), t.diff(r).add(function(n) {
			var r = t.getItemLayout(n);
			if (Ec(t, r, n, e)) {
				var s = new a(t, n, o);
				s.attr("position", r), t.setItemGraphicEl(n, s), i.add(s)
			}
		}).update(function(s, l) {
			var u = r.getItemGraphicEl(l),
				h = t.getItemLayout(s);
			return Ec(t, h, s, e) ? (u ? (u.updateData(t, s, o), eo(u, {
				position: h
			}, n)) : (u = new a(t, s), u.attr("position", h)), i.add(u), void t.setItemGraphicEl(s, u)) : void i.remove(u)
		}).remove(function(t) {
			var e = r.getItemGraphicEl(t);
			e && e.fadeOut(function() {
				i.remove(e)
			})
		}).execute(), this._data = t
	}, uS.isPersistent = function() {
		return !0
	}, uS.updateLayout = function() {
		var t = this._data;
		t && t.eachItemGraphicEl(function(e, i) {
			var n = t.getItemLayout(i);
			e.attr("position", n)
		})
	}, uS.incrementalPrepareUpdate = function(t) {
		this._seriesScope = Bc(t), this._data = null, this.group.removeAll()
	}, uS.incrementalUpdate = function(t, e, i) {
		function n(t) {
			t.isGroup || (t.incremental = t.useHoverLayer = !0)
		}
		i = zc(i);
		for (var r = t.start; r < t.end; r++) {
			var a = e.getItemLayout(r);
			if (Ec(e, a, r, i)) {
				var o = new this._symbolCtor(e, r, this._seriesScope);
				o.traverse(n), o.attr("position", a), this.group.add(o), e.setItemGraphicEl(r, o)
			}
		}
	}, uS.remove = function(t) {
		var e = this.group,
			i = this._data;
		i && t ? i.eachItemGraphicEl(function(t) {
			t.fadeOut(function() {
				e.remove(t)
			})
		}) : e.removeAll()
	};
	var hS = My.prototype,
		cS = Ty.prototype,
		dS = va({
			type: "ec-line",
			style: {
				stroke: "#000",
				fill: null
			},
			shape: {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				percent: 1,
				cpx1: null,
				cpy1: null
			},
			buildPath: function(t, e) {
				this[Rc(e) ? "_buildPathLine" : "_buildPathCurve"](t, e)
			},
			_buildPathLine: hS.buildPath,
			_buildPathCurve: cS.buildPath,
			pointAt: function(t) {
				return this[Rc(this.shape) ? "_pointAtLine" : "_pointAtCurve"](t)
			},
			_pointAtLine: hS.pointAt,
			_pointAtCurve: cS.pointAt,
			tangentAt: function(t) {
				var e = this.shape,
					i = Rc(e) ? [e.x2 - e.x1, e.y2 - e.y1] : this._tangentAtCurve(t);
				return te(i, i)
			},
			_tangentAtCurve: cS.tangentAt
		}),
		fS = ["fromSymbol", "toSymbol"],
		pS = Gc.prototype;
	pS.beforeUpdate = Wc, pS._createLine = function(t, e, i) {
		var n = t.hostModel,
			r = t.getItemLayout(e),
			a = Vc(r);
		a.shape.percent = 0, io(a, {
			shape: {
				percent: 1
			}
		}, n, e), this.add(a);
		var o = new hy({
			name: "label",
			lineLabelOriginalOpacity: 1
		});
		this.add(o), f(fS, function(i) {
			var n = Fc(i, t, e);
			this.add(n), this[Nc(i)] = t.getItemVisual(e, i)
		}, this), this._updateCommonStl(t, e, i)
	}, pS.updateData = function(t, e, i) {
		var n = t.hostModel,
			r = this.childOfName("line"),
			a = t.getItemLayout(e),
			o = {
				shape: {}
			};
		Hc(o.shape, a), eo(r, o, n, e), f(fS, function(i) {
			var n = t.getItemVisual(e, i),
				r = Nc(i);
			if (this[r] !== n) {
				this.remove(this.childOfName(i));
				var a = Fc(i, t, e);
				this.add(a)
			}
			this[r] = n
		}, this), this._updateCommonStl(t, e, i)
	}, pS._updateCommonStl = function(t, e, i) {
		var n = t.hostModel,
			r = this.childOfName("line"),
			a = i && i.lineStyle,
			o = i && i.hoverLineStyle,
			l = i && i.labelModel,
			u = i && i.hoverLabelModel;
		if (!i || t.hasItemOption) {
			var h = t.getItemModel(e);
			a = h.getModel("lineStyle").getLineStyle(), o = h.getModel("emphasis.lineStyle").getLineStyle(), l = h.getModel("label"), u = h.getModel("emphasis.label")
		}
		var c = t.getItemVisual(e, "color"),
			d = A(t.getItemVisual(e, "opacity"), a.opacity, 1);
		r.useStyle(s({
			strokeNoScale: !0,
			fill: "none",
			stroke: c,
			opacity: d
		}, a)), r.hoverStyle = o, f(fS, function(t) {
			var e = this.childOfName(t);
			e && (e.setColor(c), e.setStyle({
				opacity: d
			}))
		}, this);
		var p, g, v = l.getShallow("show"),
			m = u.getShallow("show"),
			y = this.childOfName("label");
		if ((v || m) && (p = c || "#000", g = n.getFormattedLabel(e, "normal", t.dataType), null == g)) {
			var _ = n.getRawValue(e);
			g = null == _ ? t.getName(e) : isFinite(_) ? Mo(_) : _
		}
		var w = v ? g : null,
			b = m ? k(n.getFormattedLabel(e, "emphasis", t.dataType), g) : null,
			S = y.style;
		if (null != w || null != b) {
			Xa(y.style, l, {
				text: w
			}, {
				autoColor: p
			}), y.__textAlign = S.textAlign, y.__verticalAlign = S.textVerticalAlign, y.__position = l.get("position") || "middle";
			var M = l.get("distance");
			x(M) || (M = [M, M]), y.__labelDistance = M
		}
		y.hoverStyle = null != b ? {
			text: b,
			textFill: u.getTextColor(!0),
			fontStyle: u.getShallow("fontStyle"),
			fontWeight: u.getShallow("fontWeight"),
			fontSize: u.getShallow("fontSize"),
			fontFamily: u.getShallow("fontFamily")
		} : {
			text: null
		}, y.ignore = !v && !m, Fa(this)
	}, pS.highlight = function() {
		this.trigger("emphasis")
	}, pS.downplay = function() {
		this.trigger("normal")
	}, pS.updateLayout = function(t, e) {
		this.setLinePoints(t.getItemLayout(e))
	}, pS.setLinePoints = function(t) {
		var e = this.childOfName("line");
		Hc(e.shape, t), e.dirty()
	}, h(Gc, Zg);
	var gS = Uc.prototype;
	gS.isPersistent = function() {
		return !0
	}, gS.updateData = function(t) {
		var e = this,
			i = e.group,
			n = e._lineData;
		e._lineData = t, n || i.removeAll();
		var r = qc(t);
		t.diff(n).add(function(i) {
			Xc(e, t, i, r)
		}).update(function(i, a) {
			jc(e, n, t, a, i, r)
		}).remove(function(t) {
			i.remove(n.getItemGraphicEl(t))
		}).execute()
	}, gS.updateLayout = function() {
		var t = this._lineData;
		t && t.eachItemGraphicEl(function(e, i) {
			e.updateLayout(t, i)
		}, this)
	}, gS.incrementalPrepareUpdate = function(t) {
		this._seriesScope = qc(t), this._lineData = null, this.group.removeAll()
	}, gS.incrementalUpdate = function(t, e) {
		function i(t) {
			t.isGroup || Yc(t) || (t.incremental = t.useHoverLayer = !0)
		}
		for (var n = t.start; n < t.end; n++) {
			var r = e.getItemLayout(n);
			if (Kc(r)) {
				var a = new this._ctor(e, n, this._seriesScope);
				a.traverse(i), this.group.add(a), e.setItemGraphicEl(n, a)
			}
		}
	}, gS.remove = function() {
		this._clearIncremental(), this._incremental = null, this.group.removeAll()
	}, gS._clearIncremental = function() {
		var t = this._incremental;
		t && t.clearDisplaybles()
	};
	var vS = "\x00_ec_interaction_mutex";
	wu({
		type: "takeGlobalCursor",
		event: "globalCursorTaken",
		update: "update"
	}, function() {}), c(Jc, ng);
	var mS = {
			axisPointer: 1,
			tooltip: 1,
			brush: 1
		},
		yS = [],
		_S = [],
		xS = [],
		wS = Pr,
		bS = tg,
		SS = Math.abs,
		MS = function(t, e) {
			var i = [],
				n = zr,
				r = [
					[],
					[],
					[]
				],
				a = [
					[],
					[]
				],
				o = [];
			e /= 2, t.eachEdge(function(t) {
				var s = t.getLayout(),
					l = t.getVisual("fromSymbol"),
					u = t.getVisual("toSymbol");
				s.__original || (s.__original = [G(s[0]), G(s[1])], s[2] && s.__original.push(G(s[2])));
				var h = s.__original;
				if (null != s[2]) {
					if (W(r[0], h[0]), W(r[1], h[2]), W(r[2], h[1]), l && "none" !== l) {
						var c = dd(t.node1),
							d = fd(r, h[0], c * e);
						n(r[0][0], r[1][0], r[2][0], d, i), r[0][0] = i[3], r[1][0] = i[4], n(r[0][1], r[1][1], r[2][1], d, i), r[0][1] = i[3], r[1][1] = i[4]
					}
					if (u && "none" !== u) {
						var c = dd(t.node2),
							d = fd(r, h[1], c * e);
						n(r[0][0], r[1][0], r[2][0], d, i), r[1][0] = i[1], r[2][0] = i[2], n(r[0][1], r[1][1], r[2][1], d, i), r[1][1] = i[1], r[2][1] = i[2]
					}
					W(s[0], r[0]), W(s[1], r[2]), W(s[2], r[1])
				} else {
					if (W(a[0], h[0]), W(a[1], h[1]), Y(o, a[1], a[0]), te(o, o), l && "none" !== l) {
						var c = dd(t.node1);
						j(a[0], a[0], o, c * e)
					}
					if (u && "none" !== u) {
						var c = dd(t.node2);
						j(a[1], a[1], o, -c * e)
					}
					W(s[0], a[0]), W(s[1], a[1])
				}
			})
		},
		IS = "__focusNodeAdjacency",
		TS = "__unfocusNodeAdjacency",
		CS = ["itemStyle", "opacity"],
		DS = ["lineStyle", "opacity"];
	Pu({
		type: "graph",
		init: function(t, e) {
			var i = new Oc,
				n = new Uc,
				r = this.group;
			this._controller = new Jc(e.getZr()), this._controllerHost = {
				target: r
			}, r.add(i.group), r.add(n.group), this._symbolDraw = i, this._lineDraw = n, this._firstRender = !0
		},
		render: function(t, e, i) {
			var n = this,
				r = t.coordinateSystem;
			this._model = t;
			var a = this._symbolDraw,
				o = this._lineDraw,
				s = this.group;
			if ("view" === r.type) {
				var l = {
					position: r.position,
					scale: r.scale
				};
				this._firstRender ? s.attr(l) : eo(s, l, t)
			}
			MS(t.getGraph(), cd(t));
			var u = t.getData();
			a.updateData(u);
			var h = t.getEdgeData();
			o.updateData(h), this._updateNodeAndLinkScale(), this._updateController(t, e, i), clearTimeout(this._layoutTimeout);
			var c = t.forceLayout,
				d = t.get("force.layoutAnimation");
			c && this._startForceLayoutIteration(c, d), u.eachItemGraphicEl(function(e, r) {
				var a = u.getItemModel(r);
				e.off("drag").off("dragend");
				var o = a.get("draggable");
				o && e.on("drag", function() {
					c && (c.warmUp(), !this._layouting && this._startForceLayoutIteration(c, d), c.setFixed(r), u.setItemLayout(r, e.position))
				}, this).on("dragend", function() {
					c && c.setUnfixed(r)
				}, this), e.setDraggable(o && c), e[IS] && e.off("mouseover", e[IS]), e[TS] && e.off("mouseout", e[TS]), a.get("focusNodeAdjacency") && (e.on("mouseover", e[IS] = function() {
					n._clearTimer(), i.dispatchAction({
						type: "focusNodeAdjacency",
						seriesId: t.id,
						dataIndex: e.dataIndex
					})
				}), e.on("mouseout", e[TS] = function() {
					n._dispatchUnfocus(i)
				}))
			}, this), u.graph.eachEdge(function(e) {
				var r = e.getGraphicEl();
				r[IS] && r.off("mouseover", r[IS]), r[TS] && r.off("mouseout", r[TS]), e.getModel().get("focusNodeAdjacency") && (r.on("mouseover", r[IS] = function() {
					n._clearTimer(), i.dispatchAction({
						type: "focusNodeAdjacency",
						seriesId: t.id,
						edgeDataIndex: e.dataIndex
					})
				}), r.on("mouseout", r[TS] = function() {
					n._dispatchUnfocus(i)
				}))
			});
			var f = "circular" === t.get("layout") && t.get("circular.rotateLabel"),
				p = u.getLayout("cx"),
				g = u.getLayout("cy");
			u.eachItemGraphicEl(function(t, e) {
				var i = u.getItemModel(e),
					n = i.get("label.rotate") || 0,
					r = t.getSymbolPath();
				if (f) {
					var a = u.getItemLayout(e),
						o = Math.atan2(a[1] - g, a[0] - p);
					0 > o && (o = 2 * Math.PI + o);
					var s = a[0] < p;
					s && (o -= Math.PI);
					var l = s ? "left" : "right";
					Ua(r, {
						textRotation: -o,
						textPosition: l,
						textOrigin: "center"
					}, {
						textPosition: l
					})
				} else Ua(r, {
					textRotation: n *= Math.PI / 180
				})
			}), this._firstRender = !1
		},
		dispose: function() {
			this._controller && this._controller.dispose(), this._controllerHost = {}, this._clearTimer()
		},
		_dispatchUnfocus: function(t) {
			var e = this;
			this._clearTimer(), this._unfocusDelayTimer = setTimeout(function() {
				e._unfocusDelayTimer = null, t.dispatchAction({
					type: "unfocusNodeAdjacency",
					seriesId: e._model.id
				})
			}, 500)
		},
		_clearTimer: function() {
			this._unfocusDelayTimer && (clearTimeout(this._unfocusDelayTimer), this._unfocusDelayTimer = null)
		},
		focusNodeAdjacency: function(t, e, i, n) {
			var r = t.getData(),
				a = r.graph,
				o = n.dataIndex,
				s = n.edgeDataIndex,
				l = a.getNodeByIndex(o),
				u = a.getEdgeByIndex(s);
			(l || u) && (a.eachNode(function(t) {
				gd(t, CS, .1)
			}), a.eachEdge(function(t) {
				gd(t, DS, .1)
			}), l && (vd(l, CS), f(l.edges, function(t) {
				t.dataIndex < 0 || (vd(t, DS), vd(t.node1, CS), vd(t.node2, CS))
			})), u && (vd(u, DS), vd(u.node1, CS), vd(u.node2, CS)))
		},
		unfocusNodeAdjacency: function(t) {
			var e = t.getData().graph;
			e.eachNode(function(t) {
				gd(t, CS)
			}), e.eachEdge(function(t) {
				gd(t, DS)
			})
		},
		_startForceLayoutIteration: function(t, e) {
			var i = this;
			! function n() {
				t.step(function(t) {
					i.updateLayout(i._model), (i._layouting = !t) && (e ? i._layoutTimeout = setTimeout(n, 16) : n())
				})
			}()
		},
		_updateController: function(t, e, i) {
			var n = this._controller,
				r = this._controllerHost,
				a = this.group;
			return n.setPointerChecker(function(e, n, r) {
				var o = a.getBoundingRect();
				return o.applyTransform(a.transform), o.contain(n, r) && !hd(e, i, t)
			}), "view" !== t.coordinateSystem.type ? void n.disable() : (n.enable(t.get("roam")), r.zoomLimit = t.get("scaleLimit"), r.zoom = t.coordinateSystem.getZoom(), void n.off("pan").off("zoom").on("pan", function(e) {
				ld(r, e.dx, e.dy), i.dispatchAction({
					seriesId: t.id,
					type: "graphRoam",
					dx: e.dx,
					dy: e.dy
				})
			}).on("zoom", function(e) {
				ud(r, e.scale, e.originX, e.originY), i.dispatchAction({
					seriesId: t.id,
					type: "graphRoam",
					zoom: e.scale,
					originX: e.originX,
					originY: e.originY
				}), this._updateNodeAndLinkScale(), MS(t.getGraph(), cd(t)), this._lineDraw.updateLayout()
			}, this))
		},
		_updateNodeAndLinkScale: function() {
			var t = this._model,
				e = t.getData(),
				i = cd(t),
				n = [i, i];
			e.eachItemGraphicEl(function(t) {
				t.attr("scale", n)
			})
		},
		updateLayout: function(t) {
			MS(t.getGraph(), cd(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout()
		},
		remove: function() {
			this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove()
		}
	}), wu({
		type: "focusNodeAdjacency",
		event: "focusNodeAdjacency",
		update: "series:focusNodeAdjacency"
	}, function() {}), wu({
		type: "unfocusNodeAdjacency",
		event: "unfocusNodeAdjacency",
		update: "series:unfocusNodeAdjacency"
	}, function() {});
	var kS = {
		type: "graphRoam",
		event: "graphRoam",
		update: "none"
	};
	wu(kS, function(t, e) {
		e.eachComponent({
			mainType: "series",
			query: t
		}, function(e) {
			var i = e.coordinateSystem,
				n = md(i, t);
			e.setCenter && e.setCenter(n.center), e.setZoom && e.setZoom(n.zoom)
		})
	});
	var AS = function(t) {
			var e = t.findComponents({
				mainType: "legend"
			});
			e && e.length && t.eachSeriesByType("graph", function(t) {
				var i = t.getCategoriesData(),
					n = t.getGraph(),
					r = n.data,
					a = i.mapArray(i.getName);
				r.filterSelf(function(t) {
					var i = r.getItemModel(t),
						n = i.getShallow("category");
					if (null != n) {
						"number" == typeof n && (n = a[n]);
						for (var o = 0; o < e.length; o++)
							if (!e[o].isSelected(n)) return !1
					}
					return !0
				})
			}, this)
		},
		PS = function(t, e, i) {
			return {
				seriesType: t,
				performRawSeries: !0,
				reset: function(t, n) {
					function r(e, i) {
						if (f) {
							var n = t.getRawValue(i),
								r = t.getDataParams(i);
							h && e.setItemVisual(i, "symbol", o(n, r)), c && e.setItemVisual(i, "symbolSize", s(n, r)), d && e.setItemVisual(i, "symbolRotate", u(n, r))
						}
						if (e.hasItemOption) {
							var a = e.getItemModel(i),
								l = a.getShallow("symbol", !0),
								p = a.getShallow("symbolSize", !0),
								g = a.getShallow("symbolRotate", !0),
								v = a.getShallow("symbolKeepAspect", !0);
							null != l && e.setItemVisual(i, "symbol", l), null != p && e.setItemVisual(i, "symbolSize", p), null != g && e.setItemVisual(i, "symbolRotate", g), null != v && e.setItemVisual(i, "symbolKeepAspect", v)
						}
					}
					var a = t.getData(),
						o = t.get("symbol"),
						s = t.get("symbolSize"),
						l = t.get("symbolKeepAspect"),
						u = t.get("symbolRotate"),
						h = w(o),
						c = w(s),
						d = w(u),
						f = h || c || d,
						p = !h && o ? o : e,
						g = c ? null : s;
					return a.setVisual({
						legendSymbol: i || p,
						symbol: p,
						symbolSize: g,
						symbolKeepAspect: l,
						symbolRotate: u
					}), n.isSeriesFiltered(t) ? void 0 : {
						dataEach: a.hasItemOption || f ? r : null
					}
				}
			}
		},
		LS = function(t) {
			var e = {};
			t.eachSeriesByType("graph", function(t) {
				var i = t.getCategoriesData(),
					n = t.getData(),
					r = {};
				i.each(function(n) {
					var a = i.getName(n);
					r["ec-" + a] = n;
					var o = i.getItemModel(n),
						s = o.get("itemStyle.color") || t.getColorFromPalette(a, e);
					i.setItemVisual(n, "color", s);
					for (var l = ["opacity", "symbol", "symbolSize", "symbolKeepAspect"], u = 0; u < l.length; u++) {
						var h = o.getShallow(l[u], !0);
						null != h && i.setItemVisual(n, l[u], h)
					}
				}), i.count() && n.each(function(t) {
					var e = n.getItemModel(t),
						a = e.getShallow("category");
					if (null != a) {
						"string" == typeof a && (a = r["ec-" + a]);
						for (var o = ["color", "opacity", "symbol", "symbolSize", "symbolKeepAspect"], s = 0; s < o.length; s++) null == n.getItemVisual(t, o[s], !0) && n.setItemVisual(t, o[s], i.getItemVisual(a, o[s]))
					}
				})
			})
		},
		OS = function(t) {
			t.eachSeriesByType("graph", function(t) {
				var e = t.getGraph(),
					i = t.getEdgeData(),
					n = yd(t.get("edgeSymbol")),
					r = yd(t.get("edgeSymbolSize")),
					a = "lineStyle.color".split("."),
					o = "lineStyle.opacity".split(".");
				i.setVisual("fromSymbol", n && n[0]), i.setVisual("toSymbol", n && n[1]), i.setVisual("fromSymbolSize", r && r[0]), i.setVisual("toSymbolSize", r && r[1]), i.setVisual("color", t.get(a)), i.setVisual("opacity", t.get(o)), i.each(function(t) {
					var n = i.getItemModel(t),
						r = e.getEdgeByIndex(t),
						s = yd(n.getShallow("symbol", !0)),
						l = yd(n.getShallow("symbolSize", !0)),
						u = n.get(a),
						h = n.get(o);
					switch (u) {
						case "source":
							u = r.node1.getVisual("color");
							break;
						case "target":
							u = r.node2.getVisual("color")
					}
					s[0] && r.setVisual("fromSymbol", s[0]), s[1] && r.setVisual("toSymbol", s[1]), l[0] && r.setVisual("fromSymbolSize", l[0]), l[1] && r.setVisual("toSymbolSize", l[1]), r.setVisual("color", u), r.setVisual("opacity", h)
				})
			})
		},
		ES = function(t) {
			t.eachSeriesByType("graph", function(t) {
				var e = t.get("layout"),
					i = t.coordinateSystem;
				if (i && "view" !== i.type) {
					var n = t.getData(),
						r = [];
					f(i.dimensions, function(t) {
						r = r.concat(n.mapDimension(t, !0))
					});
					for (var a = 0; a < n.count(); a++) {
						for (var o = [], s = !1, l = 0; l < r.length; l++) {
							var u = n.get(r[l], a);
							isNaN(u) || (s = !0), o.push(u)
						}
						s ? n.setItemLayout(a, i.dataToPoint(o)) : n.setItemLayout(a, [0 / 0, 0 / 0])
					}
					xd(n.graph, t)
				} else e && "none" !== e || _d(t)
			})
		},
		zS = Math.PI,
		BS = [],
		RS = {
			value: function(t, e, i, n, r, a, o, s) {
				var l = 0,
					u = n.getSum("value"),
					h = 2 * Math.PI / (u || s);
				i.eachNode(function(t) {
					var e = t.getValue("value"),
						i = h * (u ? e : 1) / 2;
					l += i, t.setLayout([r * Math.cos(l) + a, r * Math.sin(l) + o]), l += i
				})
			},
			symbolSize: function(t, e, i, n, r, a, o, s) {
				var l = 0;
				BS.length = s;
				var u = cd(t);
				i.eachNode(function(t) {
					var e = dd(t);
					isNaN(e) && (e = 2), 0 > e && (e = 0), e *= u;
					var i = Math.asin(e / 2 / r);
					isNaN(i) && (i = zS / 2), BS[t.dataIndex] = i, l += 2 * i
				});
				var h = (2 * zS - l) / s / 2,
					c = 0;
				i.eachNode(function(t) {
					var e = h + BS[t.dataIndex];
					c += e, t.setLayout([r * Math.cos(c) + a, r * Math.sin(c) + o]), c += e
				})
			}
		},
		NS = function(t) {
			t.eachSeriesByType("graph", function(t) {
				"circular" === t.get("layout") && wd(t, "symbolSize")
			})
		},
		FS = j,
		VS = function(t) {
			t.eachSeriesByType("graph", function(t) {
				var e = t.coordinateSystem;
				if (!e || "view" === e.type)
					if ("force" === t.get("layout")) {
						var i = t.preservedPoints || {},
							n = t.getGraph(),
							r = n.data,
							a = n.edgeData,
							o = t.getModel("force"),
							s = o.get("initLayout");
						t.preservedPoints ? r.each(function(t) {
							var e = r.getId(t);
							r.setItemLayout(t, i[e] || [0 / 0, 0 / 0])
						}) : s && "none" !== s ? "circular" === s && wd(t, "value") : _d(t);
						var l = r.getDataExtent("value"),
							u = a.getDataExtent("value"),
							h = o.get("repulsion"),
							c = o.get("edgeLength");
						x(h) || (h = [h, h]), x(c) || (c = [c, c]), c = [c[1], c[0]];
						var d = r.mapArray("value", function(t, e) {
								var i = r.getItemLayout(e),
									n = bo(t, l, h);
								return isNaN(n) && (n = (h[0] + h[1]) / 2), {
									w: n,
									rep: n,
									fixed: r.getItemModel(e).get("fixed"),
									p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i
								}
							}),
							f = a.mapArray("value", function(e, i) {
								var r = n.getEdgeByIndex(i),
									a = bo(e, u, c);
								isNaN(a) && (a = (c[0] + c[1]) / 2);
								var o = r.getModel(),
									s = A(o.get("lineStyle.curveness"), -Cc(r, t, i, !0), 0);
								return {
									n1: d[r.node1.dataIndex],
									n2: d[r.node2.dataIndex],
									d: a,
									curveness: s,
									ignoreForceLayout: o.get("ignoreForceLayout")
								}
							}),
							e = t.coordinateSystem,
							p = e.getBoundingRect(),
							g = bd(d, f, {
								rect: p,
								gravity: o.get("gravity"),
								friction: o.get("friction")
							}),
							v = g.step;
						g.step = function(t) {
							for (var e = 0, a = d.length; a > e; e++) d[e].fixed && W(d[e].p, n.getNodeByIndex(e).getLayout());
							v(function(e, a, o) {
								for (var s = 0, l = e.length; l > s; s++) e[s].fixed || n.getNodeByIndex(s).setLayout(e[s].p), i[r.getId(s)] = e[s].p;
								for (var s = 0, l = a.length; l > s; s++) {
									var u = a[s],
										h = n.getEdgeByIndex(s),
										c = u.n1.p,
										d = u.n2.p,
										f = h.getLayout();
									f = f ? f.slice() : [], f[0] = f[0] || [], f[1] = f[1] || [], W(f[0], c), W(f[1], d), +u.curveness && (f[2] = [(c[0] + d[0]) / 2 - (c[1] - d[1]) * u.curveness, (c[1] + d[1]) / 2 - (d[0] - c[0]) * u.curveness]), h.setLayout(f)
								}
								t && t(o)
							})
						}, t.forceLayout = g, t.preservedPoints = i, g.step()
					} else t.forceLayout = null
			})
		},
		HS = ae;
	c(Sd, xg), Md.prototype = {
		constructor: Md,
		type: "view",
		dimensions: ["x", "y"],
		setBoundingRect: function(t, e, i, n) {
			return this._rect = new Ti(t, e, i, n), this._rect
		},
		getBoundingRect: function() {
			return this._rect
		},
		setViewRect: function(t, e, i, n) {
			this.transformTo(t, e, i, n), this._viewRect = new Ti(t, e, i, n)
		},
		transformTo: function(t, e, i, n) {
			var r = this.getBoundingRect(),
				a = this._rawTransformable;
			a.transform = r.calculateTransform(new Ti(t, e, i, n)), a.decomposeTransform(), this._updateTransform()
		},
		setCenter: function(t) {
			t && (this._center = t, this._updateCenterAndZoom())
		},
		setZoom: function(t) {
			t = t || 1;
			var e = this.zoomLimit;
			e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom()
		},
		getDefaultCenter: function() {
			var t = this.getBoundingRect(),
				e = t.x + t.width / 2,
				i = t.y + t.height / 2;
			return [e, i]
		},
		getCenter: function() {
			return this._center || this.getDefaultCenter()
		},
		getZoom: function() {
			return this._zoom || 1
		},
		getRoamTransform: function() {
			return this._roamTransformable.getLocalTransform()
		},
		_updateCenterAndZoom: function() {
			var t = this._rawTransformable.getLocalTransform(),
				e = this._roamTransformable,
				i = this.getDefaultCenter(),
				n = this.getCenter(),
				r = this.getZoom();
			n = ae([], n, t), i = ae([], i, t), e.origin = n, e.position = [i[0] - n[0], i[1] - n[1]], e.scale = [r, r], this._updateTransform()
		},
		_updateTransform: function() {
			var t = this._roamTransformable,
				e = this._rawTransformable;
			e.parent = t, t.updateTransform(), e.updateTransform(), ze(this.transform || (this.transform = []), e.transform || Oe()), this._rawTransform = e.getLocalTransform(), this.invTransform = this.invTransform || [], Ve(this.invTransform, this.transform), this.decomposeTransform()
		},
		getTransformInfo: function() {
			var t = this._roamTransformable.transform,
				e = this._rawTransformable;
			return {
				roamTransform: t ? P(t) : Oe(),
				rawScale: P(e.scale),
				rawPosition: P(e.position)
			}
		},
		getViewRect: function() {
			return this._viewRect
		},
		getViewRectAfterRoam: function() {
			var t = this.getBoundingRect().clone();
			return t.applyTransform(this.transform), t
		},
		dataToPoint: function(t, e, i) {
			var n = e ? this._rawTransform : this.transform;
			return i = i || [], n ? HS(i, t, n) : W(i, t)
		},
		pointToData: function(t) {
			var e = this.invTransform;
			return e ? HS([], t, e) : [t[0], t[1]]
		},
		convertToPixel: _(Id, "dataToPoint"),
		convertFromPixel: _(Id, "pointToData"),
		containPoint: function(t) {
			return this.getViewRectAfterRoam().contain(t[0], t[1])
		}
	}, c(Md, xg);
	var WS = function(t, e) {
		var i = [];
		return t.eachSeriesByType("graph", function(t) {
			var n = t.get("coordinateSystem");
			if (!n || "view" === n) {
				var r = t.getData(),
					a = r.mapArray(function(t) {
						var e = r.getItemModel(t);
						return [+e.get("x"), +e.get("y")]
					}),
					o = [],
					s = [];
				Rr(a, o, s), s[0] - o[0] === 0 && (s[0] += 1, o[0] -= 1), s[1] - o[1] === 0 && (s[1] += 1, o[1] -= 1);
				var l = (s[0] - o[0]) / (s[1] - o[1]),
					u = Td(t, e, l);
				isNaN(l) && (o = [u.x, u.y], s = [u.x + u.width, u.y + u.height]);
				var h = s[0] - o[0],
					c = s[1] - o[1],
					d = u.width,
					f = u.height,
					p = t.coordinateSystem = new Md;
				p.zoomLimit = t.get("scaleLimit"), p.setBoundingRect(o[0], o[1], h, c), p.setViewRect(u.x, u.y, d, f), p.setCenter(t.get("center")), p.setZoom(t.get("zoom")), i.push(p)
			}
		}), i
	};
	_u(AS), Iu(PS("graph", "circle", null)), Iu(LS), Iu(OS), Mu(ES), Mu(hw.VISUAL.POST_CHART_LAYOUT, NS), Mu(VS), bu("graphView", {
		create: WS
	}), Du({
		type: "title",
		layoutMode: {
			type: "box",
			ignoreSize: !0
		},
		defaultOption: {
			zlevel: 0,
			z: 6,
			show: !0,
			text: "",
			target: "blank",
			subtext: "",
			subtarget: "blank",
			left: 0,
			top: 0,
			backgroundColor: "rgba(0,0,0,0)",
			borderColor: "#ccc",
			borderWidth: 0,
			padding: 5,
			itemGap: 10,
			textStyle: {
				fontSize: 18,
				fontWeight: "bolder",
				color: "#333"
			},
			subtextStyle: {
				color: "#aaa"
			}
		}
	}), ku({
		type: "title",
		render: function(t, e, i) {
			if (this.group.removeAll(), t.get("show")) {
				var n = this.group,
					r = t.getModel("textStyle"),
					a = t.getModel("subtextStyle"),
					o = t.get("textAlign"),
					s = k(t.get("textBaseline"), t.get("textVerticalAlign")),
					l = new hy({
						style: Xa({}, r, {
							text: t.get("text"),
							textFill: r.getTextColor()
						}, {
							disableBox: !0
						}),
						z2: 10
					}),
					u = l.getBoundingRect(),
					h = t.get("subtext"),
					c = new hy({
						style: Xa({}, a, {
							text: h,
							textFill: a.getTextColor(),
							y: u.height + t.get("itemGap"),
							textVerticalAlign: "top"
						}, {
							disableBox: !0
						}),
						z2: 10
					}),
					d = t.get("link"),
					f = t.get("sublink"),
					p = t.get("triggerEvent", !0);
				l.silent = !d && !p, c.silent = !f && !p, d && l.on("click", function() {
					Ko(d, "_" + t.get("target"))
				}), f && c.on("click", function() {
					Ko(f, "_" + t.get("subtarget"))
				}), l.eventData = c.eventData = p ? {
					componentType: "title",
					componentIndex: t.componentIndex
				} : null, n.add(l), h && n.add(c);
				var g = n.getBoundingRect(),
					v = t.getBoxLayoutParams();
				v.width = g.width, v.height = g.height;
				var m = Qo(v, {
					width: i.getWidth(),
					height: i.getHeight()
				}, t.get("padding"));
				o || (o = t.get("left") || t.get("right"), "middle" === o && (o = "center"), "right" === o ? m.x += m.width : "center" === o && (m.x += m.width / 2)), s || (s = t.get("top") || t.get("bottom"), "center" === s && (s = "middle"), "bottom" === s ? m.y += m.height : "middle" === s && (m.y += m.height / 2), s = s || "top"), n.attr("position", [m.x, m.y]);
				var y = {
					textAlign: o,
					textVerticalAlign: s
				};
				l.setStyle(y), c.setStyle(y), g = n.getBoundingRect();
				var _ = m.margin,
					x = t.getItemStyle(["color", "opacity"]);
				x.fill = t.get("backgroundColor");
				var w = new by({
					shape: {
						x: g.x - _[3],
						y: g.y - _[0],
						width: g.width + _[1] + _[3],
						height: g.height + _[0] + _[2],
						r: t.get("borderRadius")
					},
					style: x,
					subPixelOptimize: !0,
					silent: !0
				});
				n.add(w)
			}
		}
	});
	var GS = mx.legend.selector,
		US = {
			all: {
				type: "all",
				title: n(GS.all)
			},
			inverse: {
				type: "inverse",
				title: n(GS.inverse)
			}
		},
		XS = Du({
			type: "legend.plain",
			dependencies: ["series"],
			layoutMode: {
				type: "box",
				ignoreSize: !0
			},
			init: function(t, e, i) {
				this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t)
			},
			mergeOption: function(t) {
				XS.superCall(this, "mergeOption", t), this._updateSelector(t)
			},
			_updateSelector: function(t) {
				var e = t.selector;
				e === !0 && (e = t.selector = ["all", "inverse"]), x(e) && f(e, function(t, i) {
					b(t) && (t = {
						type: t
					}), e[i] = r(t, US[t.type])
				})
			},
			optionUpdated: function() {
				this._updateData(this.ecModel);
				var t = this._data;
				if (t[0] && "single" === this.get("selectedMode")) {
					for (var e = !1, i = 0; i < t.length; i++) {
						var n = t[i].get("name");
						if (this.isSelected(n)) {
							this.select(n), e = !0;
							break
						}
					}!e && this.select(t[0].get("name"))
				}
			},
			_updateData: function(t) {
				var e = [],
					i = [];
				t.eachRawSeries(function(n) {
					var r = n.name;
					i.push(r);
					var a;
					if (n.legendVisualProvider) {
						var o = n.legendVisualProvider,
							s = o.getAllNames();
						t.isSeriesFiltered(n) || (i = i.concat(s)), s.length ? e = e.concat(s) : a = !0
					} else a = !0;
					a && sr(n) && e.push(n.name)
				}), this._availableNames = i;
				var n = this.get("data") || e,
					r = p(n, function(t) {
						return ("string" == typeof t || "number" == typeof t) && (t = {
							name: t
						}), new go(t, this, this.ecModel)
					}, this);
				this._data = r
			},
			getData: function() {
				return this._data
			},
			select: function(t) {
				var e = this.option.selected,
					i = this.get("selectedMode");
				if ("single" === i) {
					var n = this._data;
					f(n, function(t) {
						e[t.get("name")] = !1
					})
				}
				e[t] = !0
			},
			unSelect: function(t) {
				"single" !== this.get("selectedMode") && (this.option.selected[t] = !1)
			},
			toggleSelected: function(t) {
				var e = this.option.selected;
				e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
			},
			allSelect: function() {
				var t = this._data,
					e = this.option.selected;
				f(t, function(t) {
					e[t.get("name", !0)] = !0
				})
			},
			inverseSelect: function() {
				var t = this._data,
					e = this.option.selected;
				f(t, function(t) {
					var i = t.get("name", !0);
					e.hasOwnProperty(i) || (e[i] = !0), e[i] = !e[i]
				})
			},
			isSelected: function(t) {
				var e = this.option.selected;
				return !(e.hasOwnProperty(t) && !e[t]) && u(this._availableNames, t) >= 0
			},
			getOrient: function() {
				return "vertical" === this.get("orient") ? {
					index: 1,
					name: "vertical"
				} : {
					index: 0,
					name: "horizontal"
				}
			},
			defaultOption: {
				zlevel: 0,
				z: 4,
				show: !0,
				orient: "horizontal",
				left: "center",
				top: 0,
				align: "auto",
				backgroundColor: "rgba(0,0,0,0)",
				borderColor: "#ccc",
				borderRadius: 0,
				borderWidth: 0,
				padding: 5,
				itemGap: 10,
				itemWidth: 25,
				itemHeight: 14,
				inactiveColor: "#ccc",
				inactiveBorderColor: "#ccc",
				itemStyle: {
					borderWidth: 0
				},
				textStyle: {
					color: "#333"
				},
				selectedMode: !0,
				selector: !1,
				selectorLabel: {
					show: !0,
					borderRadius: 10,
					padding: [3, 5, 3, 5],
					fontSize: 12,
					fontFamily: " sans-serif",
					color: "#666",
					borderWidth: 1,
					borderColor: "#666"
				},
				emphasis: {
					selectorLabel: {
						show: !0,
						color: "#eee",
						backgroundColor: "#666"
					}
				},
				selectorPosition: "auto",
				selectorItemGap: 7,
				selectorButtonGap: 10,
				tooltip: {
					show: !1
				}
			}
		});
	wu("legendToggleSelect", "legendselectchanged", _(Cd, "toggleSelected")), wu("legendAllSelect", "legendselectall", _(Cd, "allSelect")), wu("legendInverseSelect", "legendinverseselect", _(Cd, "inverseSelect")), wu("legendSelect", "legendselected", _(Cd, "select")), wu("legendUnSelect", "legendunselected", _(Cd, "unSelect"));
	var jS = _,
		YS = f,
		qS = Zg,
		ZS = ku({
			type: "legend.plain",
			newlineDisabled: !1,
			init: function() {
				this.group.add(this._contentGroup = new qS), this._backgroundEl, this.group.add(this._selectorGroup = new qS), this._isFirstRender = !0
			},
			getContentGroup: function() {
				return this._contentGroup
			},
			getSelectorGroup: function() {
				return this._selectorGroup
			},
			render: function(t, e, i) {
				var n = this._isFirstRender;
				if (this._isFirstRender = !1, this.resetInner(), t.get("show", !0)) {
					var r = t.get("align"),
						a = t.get("orient");
					r && "auto" !== r || (r = "right" === t.get("left") && "vertical" === a ? "right" : "left");
					var o = t.get("selector", !0),
						l = t.get("selectorPosition", !0);
					!o || l && "auto" !== l || (l = "horizontal" === a ? "end" : "start"), this.renderInner(r, t, e, i, o, a, l);
					var u = t.getBoxLayoutParams(),
						h = {
							width: i.getWidth(),
							height: i.getHeight()
						},
						c = t.get("padding"),
						d = Qo(u, h, c),
						f = this.layoutInner(t, r, d, n, o, l),
						p = Qo(s({
							width: f.width,
							height: f.height
						}, u), h, c);
					this.group.attr("position", [p.x - f.x, p.y - f.y]), this.group.add(this._backgroundEl = Dd(f, t))
				}
			},
			resetInner: function() {
				this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll()
			},
			renderInner: function(t, e, i, n, r, a, o) {
				var s = this.getContentGroup(),
					l = N(),
					u = e.get("selectedMode"),
					h = [];
				i.eachRawSeries(function(t) {
					!t.get("legendHoverLink") && h.push(t.id)
				}), YS(e.getData(), function(r, a) {
					var o = r.get("name");
					if (!this.newlineDisabled && ("" === o || "\n" === o)) return void s.add(new qS({
						newline: !0
					}));
					var c = i.getSeriesByName(o)[0];
					if (!l.get(o))
						if (c) {
							var d = c.getData(),
								f = d.getVisual("color"),
								p = d.getVisual("borderColor");
							"function" == typeof f && (f = f(c.getDataParams(0))), "function" == typeof p && (p = p(c.getDataParams(0)));
							var g = d.getVisual("legendSymbol") || "roundRect",
								v = d.getVisual("symbol"),
								m = this._createItem(o, a, r, e, g, v, t, f, p, u);
							m.on("click", jS(Ad, o, null, n, h)).on("mouseover", jS(Pd, c.name, null, n, h)).on("mouseout", jS(Ld, c.name, null, n, h)), l.set(o, !0)
						} else i.eachRawSeries(function(i) {
							if (!l.get(o) && i.legendVisualProvider) {
								var s = i.legendVisualProvider;
								if (!s.containName(o)) return;
								var c = s.indexOfName(o),
									d = s.getItemVisual(c, "color"),
									f = s.getItemVisual(c, "borderColor"),
									p = "roundRect",
									g = this._createItem(o, a, r, e, p, null, t, d, f, u);
								g.on("click", jS(Ad, null, o, n, h)).on("mouseover", jS(Pd, null, o, n, h)).on("mouseout", jS(Ld, null, o, n, h)), l.set(o, !0)
							}
						}, this)
				}, this), r && this._createSelector(r, e, n, a, o)
			},
			_createSelector: function(t, e, i) {
				function n(t) {
					var n = t.type,
						a = new hy({
							style: {
								x: 0,
								y: 0,
								align: "center",
								verticalAlign: "middle"
							},
							onclick: function() {
								i.dispatchAction({
									type: "all" === n ? "legendAllSelect" : "legendInverseSelect"
								})
							}
						});
					r.add(a);
					var o = e.getModel("selectorLabel"),
						s = e.getModel("emphasis.selectorLabel");
					Ga(a.style, a.hoverStyle = {}, o, s, {
						defaultText: t.title,
						isRectText: !1
					}), Fa(a)
				}
				var r = this.getSelectorGroup();
				YS(t, function(t) {
					n(t)
				})
			},
			_createItem: function(t, e, i, n, r, a, s, l, u, h) {
				var c = n.get("itemWidth"),
					d = n.get("itemHeight"),
					f = n.get("inactiveColor"),
					p = n.get("inactiveBorderColor"),
					g = n.get("symbolKeepAspect"),
					v = n.getModel("itemStyle"),
					m = n.isSelected(t),
					y = new qS,
					_ = i.getModel("textStyle"),
					x = i.get("icon"),
					w = i.getModel("tooltip"),
					b = w.parentModel;
				r = x || r;
				var S = Wh(r, 0, 0, c, d, m ? l : f, null == g ? !0 : g);
				if (y.add(kd(S, r, v, u, p, m)), !x && a && (a !== r || "none" === a)) {
					var M = .8 * d;
					"none" === a && (a = "circle");
					var I = Wh(a, (c - M) / 2, (d - M) / 2, M, M, m ? l : f, null == g ? !0 : g);
					y.add(kd(I, a, v, u, p, m))
				}
				var T = "left" === s ? c + 5 : -5,
					C = s,
					D = n.get("formatter"),
					k = t;
				"string" == typeof D && D ? k = D.replace("{name}", null != t ? t : "") : "function" == typeof D && (k = D(t)), y.add(new hy({
					style: Xa({}, _, {
						text: k,
						x: T,
						y: d / 2,
						textFill: m ? _.getTextColor() : f,
						textAlign: C,
						textVerticalAlign: "middle"
					})
				}));
				var A = new by({
					shape: y.getBoundingRect(),
					invisible: !0,
					tooltip: w.get("show") ? o({
						content: t,
						formatter: b.get("formatter", !0) || function() {
							return t
						},
						formatterParams: {
							componentType: "legend",
							legendIndex: n.componentIndex,
							name: t,
							$vars: ["name"]
						}
					}, w.option) : null
				});
				return y.add(A), y.eachChild(function(t) {
					t.silent = !0
				}), A.silent = !h, this.getContentGroup().add(y), Fa(y), y.__legendDataIndex = e, y
			},
			layoutInner: function(t, e, i, n, r, a) {
				var o = this.getContentGroup(),
					s = this.getSelectorGroup();
				g_(t.get("orient"), o, t.get("itemGap"), i.width, i.height);
				var l = o.getBoundingRect(),
					u = [-l.x, -l.y];
				if (r) {
					g_("horizontal", s, t.get("selectorItemGap", !0));
					var h = s.getBoundingRect(),
						c = [-h.x, -h.y],
						d = t.get("selectorButtonGap", !0),
						f = t.getOrient().index,
						p = 0 === f ? "width" : "height",
						g = 0 === f ? "height" : "width",
						v = 0 === f ? "y" : "x";
					"end" === a ? c[f] += l[p] + d : u[f] += h[p] + d, c[1 - f] += l[g] / 2 - h[g] / 2, s.attr("position", c), o.attr("position", u);
					var m = {
						x: 0,
						y: 0
					};
					return m[p] = l[p] + d + h[p], m[g] = Math.max(l[g], h[g]), m[v] = Math.min(0, h[v] + c[1 - f]), m
				}
				return o.attr("position", u), this.group.getBoundingRect()
			},
			remove: function() {
				this.getContentGroup().removeAll(), this._isFirstRender = !0
			}
		}),
		KS = function(t) {
			var e = t.findComponents({
				mainType: "legend"
			});
			e && e.length && t.filterSeries(function(t) {
				for (var i = 0; i < e.length; i++)
					if (!e[i].isSelected(t.name)) return !1;
				return !0
			})
		};
	_u(hw.PROCESSOR.SERIES_FILTER, KS), y_.registerSubTypeDefaulter("legend", function() {
		return "plain"
	});
	var $S = XS.extend({
			type: "legend.scroll",
			setScrollDataIndex: function(t) {
				this.option.scrollDataIndex = t
			},
			defaultOption: {
				scrollDataIndex: 0,
				pageButtonItemGap: 5,
				pageButtonGap: null,
				pageButtonPosition: "end",
				pageFormatter: "{current}/{total}",
				pageIcons: {
					horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
					vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
				},
				pageIconColor: "#2f4554",
				pageIconInactiveColor: "#aaa",
				pageIconSize: 15,
				pageTextStyle: {
					color: "#333"
				},
				animationDurationUpdate: 800
			},
			init: function(t, e, i, n) {
				var r = ts(t);
				$S.superCall(this, "init", t, e, i, n), Od(this, t, r)
			},
			mergeOption: function(t, e) {
				$S.superCall(this, "mergeOption", t, e), Od(this, this.option, t)
			}
		}),
		QS = Zg,
		JS = ["width", "height"],
		tM = ["x", "y"],
		eM = ZS.extend({
			type: "legend.scroll",
			newlineDisabled: !0,
			init: function() {
				eM.superCall(this, "init"), this._currentIndex = 0, this.group.add(this._containerGroup = new QS), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new QS), this._showController
			},
			resetInner: function() {
				eM.superCall(this, "resetInner"), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null
			},
			renderInner: function(t, e, i, n, r, a, o) {
				function s(t, i) {
					var r = t + "DataIndex",
						a = uo(e.get("pageIcons", !0)[e.getOrient().name][i], {
							onclick: y(l._pageGo, l, r, e, n)
						}, {
							x: -h[0] / 2,
							y: -h[1] / 2,
							width: h[0],
							height: h[1]
						});
					a.name = t, u.add(a)
				}
				var l = this;
				eM.superCall(this, "renderInner", t, e, i, n, r, a, o);
				var u = this._controllerGroup,
					h = e.get("pageIconSize", !0);
				x(h) || (h = [h, h]), s("pagePrev", 0);
				var c = e.getModel("pageTextStyle");
				u.add(new hy({
					name: "pageText",
					style: {
						textFill: c.getTextColor(),
						font: c.getFont(),
						textVerticalAlign: "middle",
						textAlign: "center"
					},
					silent: !0
				})), s("pageNext", 1)
			},
			layoutInner: function(t, e, i, r, a, o) {
				var s = this.getSelectorGroup(),
					l = t.getOrient().index,
					u = JS[l],
					h = tM[l],
					c = JS[1 - l],
					d = tM[1 - l];
				a && g_("horizontal", s, t.get("selectorItemGap", !0));
				var f = t.get("selectorButtonGap", !0),
					p = s.getBoundingRect(),
					g = [-p.x, -p.y],
					v = n(i);
				a && (v[u] = i[u] - p[u] - f);
				var m = this._layoutContentAndController(t, r, v, l, u, c, d);
				if (a) {
					if ("end" === o) g[l] += m[u] + f;
					else {
						var y = p[u] + f;
						g[l] -= y, m[h] -= y
					}
					m[u] += p[u] + f, g[1 - l] += m[d] + m[c] / 2 - p[c] / 2, m[c] = Math.max(m[c], p[c]), m[d] = Math.min(m[d], p[d] + g[1 - l]), s.attr("position", g)
				}
				return m
			},
			_layoutContentAndController: function(t, e, i, n, r, a, o) {
				var s = this.getContentGroup(),
					l = this._containerGroup,
					u = this._controllerGroup;
				g_(t.get("orient"), s, t.get("itemGap"), n ? i.width : null, n ? null : i.height), g_("horizontal", u, t.get("pageButtonItemGap", !0));
				var h = s.getBoundingRect(),
					c = u.getBoundingRect(),
					d = this._showController = h[r] > i[r],
					f = [-h.x, -h.y];
				e || (f[n] = s.position[n]);
				var p = [0, 0],
					g = [-c.x, -c.y],
					v = k(t.get("pageButtonGap", !0), t.get("itemGap", !0));
				if (d) {
					var m = t.get("pageButtonPosition", !0);
					"end" === m ? g[n] += i[r] - c[r] : p[n] += c[r] + v
				}
				g[1 - n] += h[a] / 2 - c[a] / 2, s.attr("position", f), l.attr("position", p), u.attr("position", g);
				var y = {
					x: 0,
					y: 0
				};
				if (y[r] = d ? i[r] : h[r], y[a] = Math.max(h[a], c[a]), y[o] = Math.min(0, c[o] + g[1 - n]), l.__rectSize = i[r], d) {
					var _ = {
						x: 0,
						y: 0
					};
					_[r] = Math.max(i[r] - c[r] - v, 0), _[a] = y[a], l.setClipPath(new by({
						shape: _
					})), l.__rectSize = _[r]
				} else u.eachChild(function(t) {
					t.attr({
						invisible: !0,
						silent: !0
					})
				});
				var x = this._getPageInfo(t);
				return null != x.pageIndex && eo(s, {
					position: x.contentPosition
				}, d ? t : !1), this._updatePageInfoView(t, x), y
			},
			_pageGo: function(t, e, i) {
				var n = this._getPageInfo(e)[t];
				null != n && i.dispatchAction({
					type: "legendScroll",
					scrollDataIndex: n,
					legendId: e.id
				})
			},
			_updatePageInfoView: function(t, e) {
				var i = this._controllerGroup;
				f(["pagePrev", "pageNext"], function(n) {
					var r = null != e[n + "DataIndex"],
						a = i.childOfName(n);
					a && (a.setStyle("fill", r ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), a.cursor = r ? "pointer" : "default")
				});
				var n = i.childOfName("pageText"),
					r = t.get("pageFormatter"),
					a = e.pageIndex,
					o = null != a ? a + 1 : 0,
					s = e.pageCount;
				n && r && n.setStyle("text", b(r) ? r.replace("{current}", o).replace("{total}", s) : r({
					current: o,
					total: s
				}))
			},
			_getPageInfo: function(t) {
				function e(t) {
					if (t) {
						var e = t.getBoundingRect(),
							i = e[l] + t.position[o];
						return {
							s: i,
							e: i + e[s],
							i: t.__legendDataIndex
						}
					}
				}

				function i(t, e) {
					return t.e >= e && t.s <= e + a
				}
				var n = t.get("scrollDataIndex", !0),
					r = this.getContentGroup(),
					a = this._containerGroup.__rectSize,
					o = t.getOrient().index,
					s = JS[o],
					l = tM[o],
					u = this._findTargetItemIndex(n),
					h = r.children(),
					c = h[u],
					d = h.length,
					f = d ? 1 : 0,
					p = {
						contentPosition: r.position.slice(),
						pageCount: f,
						pageIndex: f - 1,
						pagePrevDataIndex: null,
						pageNextDataIndex: null
					};
				if (!c) return p;
				var g = e(c);
				p.contentPosition[o] = -g.s;
				for (var v = u + 1, m = g, y = g, _ = null; d >= v; ++v) _ = e(h[v]), (!_ && y.e > m.s + a || _ && !i(_, m.s)) && (m = y.i > m.i ? y : _, m && (null == p.pageNextDataIndex && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = _;
				for (var v = u - 1, m = g, y = g, _ = null; v >= -1; --v) _ = e(h[v]), _ && i(y, _.s) || !(m.i < y.i) || (y = m, null == p.pagePrevDataIndex && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = _;
				return p
			},
			_findTargetItemIndex: function(t) {
				if (!this._showController) return 0;
				var e, i, n = this.getContentGroup();
				return n.eachChild(function(n, r) {
					var a = n.__legendDataIndex;
					null == i && null != a && (i = r), a === t && (e = r)
				}), null != e ? e : i
			}
		});
	wu("legendScroll", "legendscroll", function(t, e) {
		var i = t.scrollDataIndex;
		null != i && e.eachComponent({
			mainType: "legend",
			subType: "scroll",
			query: t
		}, function(t) {
			t.setScrollDataIndex(i)
		})
	});
	var iM = f,
		nM = _,
		rM = function(t, e) {
			var i, n = [],
				r = t.seriesIndex;
			if (null == r || !(i = e.getSeriesByIndex(r))) return {
				point: []
			};
			var a = i.getData(),
				o = ur(a, t);
			if (null == o || 0 > o || x(o)) return {
				point: []
			};
			var s = a.getItemGraphicEl(o),
				l = i.coordinateSystem;
			if (i.getTooltipPosition) n = i.getTooltipPosition(o) || [];
			else if (l && l.dataToPoint) n = l.dataToPoint(a.getValues(p(l.dimensions, function(t) {
				return a.mapDimension(t)
			}), o, !0)) || [];
			else if (s) {
				var u = s.getBoundingRect().clone();
				u.applyTransform(s.transform), n = [u.x + u.width / 2, u.y + u.height / 2]
			}
			return {
				point: n,
				el: s
			}
		},
		aM = f,
		oM = _,
		sM = hr(),
		lM = function(t, e, i) {
			var n = t.currTrigger,
				r = [t.x, t.y],
				a = t,
				o = t.dispatchAction || y(i.dispatchAction, i),
				s = e.getComponent("axisPointer").coordSysAxesInfo;
			if (s) {
				tf(r) && (r = rM({
					seriesIndex: a.seriesIndex,
					dataIndex: a.dataIndex
				}, e).point);
				var l = tf(r),
					u = a.axesInfo,
					h = s.axesInfo,
					c = "leave" === n || tf(r),
					d = {},
					f = {},
					p = {
						list: [],
						map: {}
					},
					g = {
						showPointer: oM(Yd, f),
						showTooltip: oM(qd, p)
					};
				aM(s.coordSysMap, function(t, e) {
					var i = l || t.containPoint(r);
					aM(s.coordSysAxesInfo[e], function(t) {
						var e = t.axis,
							n = Qd(u, t);
						if (!c && i && (!u || n)) {
							var a = n && n.value;
							null != a || l || (a = e.pointToData(r)), null != a && Xd(t, a, g, !1, d)
						}
					})
				});
				var v = {};
				return aM(h, function(t, e) {
					var i = t.linkGroup;
					i && !f[e] && aM(i.axesInfo, function(e, n) {
						var r = f[n];
						if (e !== t && r) {
							var a = r.value;
							i.mapper && (a = t.axis.scale.parse(i.mapper(a, Jd(e), Jd(t)))), v[t.key] = a
						}
					})
				}), aM(v, function(t, e) {
					Xd(h[e], t, g, !0, d)
				}), Zd(f, h, d), Kd(p, r, t, o), $d(h, o, i), d
			}
		},
		uM = (Du({
			type: "axisPointer",
			coordSysAxesInfo: null,
			defaultOption: {
				show: "auto",
				triggerOn: null,
				zlevel: 0,
				z: 50,
				type: "line",
				snap: !1,
				triggerTooltip: !0,
				value: null,
				status: null,
				link: [],
				animation: null,
				animationDurationUpdate: 200,
				lineStyle: {
					color: "#aaa",
					width: 1,
					type: "solid"
				},
				shadowStyle: {
					color: "rgba(150,150,150,0.3)"
				},
				label: {
					show: !0,
					formatter: null,
					precision: "auto",
					margin: 3,
					color: "#fff",
					padding: [5, 7, 5, 7],
					backgroundColor: "auto",
					borderColor: null,
					borderWidth: 0,
					shadowBlur: 3,
					shadowColor: "#aaa"
				},
				handle: {
					show: !1,
					icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
					size: 45,
					margin: 50,
					color: "#333",
					shadowBlur: 3,
					shadowColor: "#aaa",
					shadowOffsetX: 0,
					shadowOffsetY: 2,
					throttle: 40
				}
			}
		}), hr()),
		hM = f,
		cM = ku({
			type: "axisPointer",
			render: function(t, e, i) {
				var n = e.getComponent("tooltip"),
					r = t.get("triggerOn") || n && n.get("triggerOn") || "mousemove|click";
				ef("axisPointer", i, function(t, e, i) {
					"none" !== r && ("leave" === t || r.indexOf(t) >= 0) && i({
						type: "updateAxisPointer",
						currTrigger: t,
						x: e && e.offsetX,
						y: e && e.offsetY
					})
				})
			},
			remove: function(t, e) {
				lf(e.getZr(), "axisPointer"), cM.superApply(this._model, "remove", arguments)
			},
			dispose: function(t, e) {
				lf("axisPointer", e), cM.superApply(this._model, "dispose", arguments)
			}
		}),
		dM = hr(),
		fM = n,
		pM = y;
	uf.prototype = {
		_group: null,
		_lastGraphicKey: null,
		_handle: null,
		_dragging: !1,
		_lastValue: null,
		_lastStatus: null,
		_payloadInfo: null,
		animationThreshold: 15,
		render: function(t, e, i, n) {
			var r = e.get("value"),
				a = e.get("status");
			if (this._axisModel = t, this._axisPointerModel = e, this._api = i, n || this._lastValue !== r || this._lastStatus !== a) {
				this._lastValue = r, this._lastStatus = a;
				var o = this._group,
					s = this._handle;
				if (!a || "hide" === a) return o && o.hide(), void(s && s.hide());
				o && o.show(), s && s.show();
				var l = {};
				this.makeElOption(l, r, t, e, i);
				var u = l.graphicKey;
				u !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = u;
				var h = this._moveAnimation = this.determineAnimation(t, e);
				if (o) {
					var c = _(hf, e, h);
					this.updatePointerEl(o, l, c, e), this.updateLabelEl(o, l, c, e)
				} else o = this._group = new Zg, this.createPointerEl(o, l, t, e), this.createLabelEl(o, l, t, e), i.getZr().add(o);
				pf(o, e, !0), this._renderHandle(r)
			}
		},
		remove: function(t) {
			this.clear(t)
		},
		dispose: function(t) {
			this.clear(t)
		},
		determineAnimation: function(t, e) {
			var i = e.get("animation"),
				n = t.axis,
				r = "category" === n.type,
				a = e.get("snap");
			if (!a && !r) return !1;
			if ("auto" === i || null == i) {
				var o = this.animationThreshold;
				if (r && n.getBandWidth() > o) return !0;
				if (a) {
					var s = Hd(t).seriesDataCount,
						l = n.getExtent();
					return Math.abs(l[0] - l[1]) / s > o
				}
				return !1
			}
			return i === !0
		},
		makeElOption: function() {},
		createPointerEl: function(t, e) {
			var i = e.pointer;
			if (i) {
				var n = dM(t).pointerEl = new Yy[i.type](fM(e.pointer));
				t.add(n)
			}
		},
		createLabelEl: function(t, e, i, n) {
			if (e.label) {
				var r = dM(t).labelEl = new by(fM(e.label));
				t.add(r), df(r, n)
			}
		},
		updatePointerEl: function(t, e, i) {
			var n = dM(t).pointerEl;
			n && e.pointer && (n.setStyle(e.pointer.style), i(n, {
				shape: e.pointer.shape
			}))
		},
		updateLabelEl: function(t, e, i, n) {
			var r = dM(t).labelEl;
			r && (r.setStyle(e.label.style), i(r, {
				shape: e.label.shape,
				position: e.label.position
			}), df(r, n))
		},
		_renderHandle: function(t) {
			if (!this._dragging && this.updateHandleTransform) {
				var e = this._axisPointerModel,
					i = this._api.getZr(),
					n = this._handle,
					r = e.getModel("handle"),
					a = e.get("status");
				if (!r.get("show") || !a || "hide" === a) return n && i.remove(n), void(this._handle = null);
				var o;
				this._handle || (o = !0, n = this._handle = uo(r.get("icon"), {
					cursor: "move",
					draggable: !0,
					onmousemove: function(t) {
						hg(t.event)
					},
					onmousedown: pM(this._onHandleDragMove, this, 0, 0),
					drift: pM(this._onHandleDragMove, this),
					ondragend: pM(this._onHandleDragEnd, this)
				}), i.add(n)), pf(n, e, !1);
				var s = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
				n.setStyle(r.getItemStyle(null, s));
				var l = r.get("size");
				x(l) || (l = [l, l]), n.attr("scale", [l[0] / 2, l[1] / 2]), vl(this, "_doDispatchAxisPointer", r.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, o)
			}
		},
		_moveHandleToValue: function(t, e) {
			hf(this._axisPointerModel, !e && this._moveAnimation, this._handle, ff(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)))
		},
		_onHandleDragMove: function(t, e) {
			var i = this._handle;
			if (i) {
				this._dragging = !0;
				var n = this.updateHandleTransform(ff(i), [t, e], this._axisModel, this._axisPointerModel);
				this._payloadInfo = n, i.stopAnimation(), i.attr(ff(n)), dM(i).lastProp = null, this._doDispatchAxisPointer()
			}
		},
		_doDispatchAxisPointer: function() {
			var t = this._handle;
			if (t) {
				var e = this._payloadInfo,
					i = this._axisModel;
				this._api.dispatchAction({
					type: "updateAxisPointer",
					x: e.cursorPoint[0],
					y: e.cursorPoint[1],
					tooltipOption: e.tooltipOption,
					axesInfo: [{
						axisDim: i.axis.dim,
						axisIndex: i.componentIndex
					}]
				})
			}
		},
		_onHandleDragEnd: function() {
			this._dragging = !1;
			var t = this._handle;
			if (t) {
				var e = this._axisPointerModel.get("value");
				this._moveHandleToValue(e), this._api.dispatchAction({
					type: "hideTip"
				})
			}
		},
		getHandleTransform: null,
		updateHandleTransform: null,
		clear: function(t) {
			this._lastValue = null, this._lastStatus = null;
			var e = t.getZr(),
				i = this._group,
				n = this._handle;
			e && i && (this._lastGraphicKey = null, i && e.remove(i), n && e.remove(n), this._group = null, this._handle = null, this._payloadInfo = null)
		},
		doClear: function() {},
		buildLabel: function(t, e, i) {
			return i = i || 0, {
				x: t[i],
				y: t[1 - i],
				width: e[i],
				height: e[1 - i]
			}
		}
	}, uf.prototype.constructor = uf, yr(uf);
	var gM = Math.PI,
		vM = function(t, e) {
			this.opt = e, this.axisModel = t, s(e, {
				labelOffset: 0,
				nameDirection: 1,
				tickDirection: 1,
				labelDirection: 1,
				silent: !0
			}), this.group = new Zg;
			var i = new Zg({
				position: e.position.slice(),
				rotation: e.rotation
			});
			i.updateTransform(), this._transform = i.transform, this._dumbGroup = i
		};
	vM.prototype = {
		constructor: vM,
		hasBuilder: function(t) {
			return !!mM[t]
		},
		add: function(t) {
			mM[t].call(this)
		},
		getGroup: function() {
			return this.group
		}
	};
	var mM = {
			axisLine: function() {
				var t = this.opt,
					e = this.axisModel;
				if (e.get("axisLine.show")) {
					var i = this.axisModel.axis.getExtent(),
						n = this._transform,
						r = [i[0], 0],
						a = [i[1], 0];
					n && (ae(r, r, n), ae(a, a, n));
					var s = o({
						lineCap: "round"
					}, e.getModel("axisLine.lineStyle").getLineStyle());
					this.group.add(new My({
						anid: "line",
						subPixelOptimize: !0,
						shape: {
							x1: r[0],
							y1: r[1],
							x2: a[0],
							y2: a[1]
						},
						style: s,
						strokeContainThreshold: t.strokeContainThreshold || 5,
						silent: !0,
						z2: 1
					}));
					var l = e.get("axisLine.symbol"),
						u = e.get("axisLine.symbolSize"),
						h = e.get("axisLine.symbolOffset") || 0;
					if ("number" == typeof h && (h = [h, h]), null != l) {
						"string" == typeof l && (l = [l, l]), ("string" == typeof u || "number" == typeof u) && (u = [u, u]);
						var c = u[0],
							d = u[1];
						f([{
							rotate: t.rotation + Math.PI / 2,
							offset: h[0],
							r: 0
						}, {
							rotate: t.rotation - Math.PI / 2,
							offset: h[1],
							r: Math.sqrt((r[0] - a[0]) * (r[0] - a[0]) + (r[1] - a[1]) * (r[1] - a[1]))
						}], function(e, i) {
							if ("none" !== l[i] && null != l[i]) {
								var n = Wh(l[i], -c / 2, -d / 2, c, d, s.stroke, !0),
									a = e.r + e.offset,
									o = [r[0] + a * Math.cos(t.rotation), r[1] - a * Math.sin(t.rotation)];
								n.attr({
									rotation: e.rotate,
									position: o,
									silent: !0,
									z2: 11
								}), this.group.add(n)
							}
						}, this)
					}
				}
			},
			axisTickLabel: function() {
				var t = this.axisModel,
					e = this.opt,
					i = wf(this, t, e),
					n = Sf(this, t, e);
				vf(t, n, i), bf(this, t, e)
			},
			axisName: function() {
				var t = this.opt,
					e = this.axisModel,
					i = D(t.axisName, e.get("name"));
				if (i) {
					var n, r = e.get("nameLocation"),
						a = t.nameDirection,
						s = e.getModel("nameTextStyle"),
						l = e.get("nameGap") || 0,
						u = this.axisModel.axis.getExtent(),
						h = u[0] > u[1] ? -1 : 1,
						c = ["start" === r ? u[0] - h * l : "end" === r ? u[1] + h * l : (u[0] + u[1]) / 2, _f(r) ? t.labelOffset + a * l : 0],
						d = e.get("nameRotate");
					null != d && (d = d * gM / 180);
					var f;
					_f(r) ? n = _M(t.rotation, null != d ? d : t.rotation, a) : (n = gf(t, r, d || 0, u), f = t.axisNameAvailableWidth, null != f && (f = Math.abs(f / Math.sin(n.rotation)), !isFinite(f) && (f = null)));
					var p = s.getFont(),
						g = e.get("nameTruncate", !0) || {},
						v = g.ellipsis,
						m = D(t.nameTruncateMaxWidth, g.maxWidth, f),
						y = null != v && null != m ? h_(i, m, p, v, {
							minChar: 2,
							placeholder: g.placeholder
						}) : i,
						_ = e.get("tooltip", !0),
						x = e.mainType,
						w = {
							componentType: x,
							name: i,
							$vars: ["name"]
						};
					w[x + "Index"] = e.componentIndex;
					var b = new hy({
						anid: "name",
						__fullText: i,
						__truncatedText: y,
						position: c,
						rotation: n.rotation,
						silent: xM(e),
						z2: 1,
						tooltip: _ && _.show ? o({
							content: i,
							formatter: function() {
								return i
							},
							formatterParams: w
						}, _) : null
					});
					Xa(b.style, s, {
						text: y,
						textFont: p,
						textFill: s.getTextColor() || e.get("axisLine.lineStyle.color"),
						textAlign: s.get("align") || n.textAlign,
						textVerticalAlign: s.get("verticalAlign") || n.textVerticalAlign
					}), e.get("triggerEvent") && (b.eventData = yM(e), b.eventData.targetType = "axisName", b.eventData.name = i), this._dumbGroup.add(b), b.updateTransform(), this.group.add(b), b.decomposeTransform()
				}
			}
		},
		yM = vM.makeAxisEventDataBase = function(t) {
			var e = {
				componentType: t.mainType,
				componentIndex: t.componentIndex
			};
			return e[t.mainType + "Index"] = t.componentIndex, e
		},
		_M = vM.innerTextLayout = function(t, e, i) {
			var n, r, a = Ao(e - t);
			return Po(a) ? (r = i > 0 ? "top" : "bottom", n = "center") : Po(a - gM) ? (r = i > 0 ? "bottom" : "top", n = "center") : (r = "middle", n = a > 0 && gM > a ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), {
				rotation: a,
				textAlign: n,
				textVerticalAlign: r
			}
		},
		xM = vM.isLabelSilent = function(t) {
			var e = t.get("tooltip");
			return t.get("silent") || !(t.get("triggerEvent") || e && e.show)
		},
		wM = ku({
			type: "axis",
			_axisPointer: null,
			axisPointerClass: null,
			render: function(t, e, i, n) {
				this.axisPointerClass && Vd(t), wM.superApply(this, "render", arguments), Of(this, t, e, i, n, !0)
			},
			updateAxisPointer: function(t, e, i, n) {
				Of(this, t, e, i, n, !1)
			},
			remove: function(t, e) {
				var i = this._axisPointer;
				i && i.remove(e), wM.superApply(this, "remove", arguments)
			},
			dispose: function(t, e) {
				Ef(this, e), wM.superApply(this, "dispose", arguments)
			}
		}),
		bM = [];
	wM.registerAxisPointerClass = function(t, e) {
		bM[t] = e
	}, wM.getAxisPointerClass = function(t) {
		return t && bM[t]
	};
	var SM = uf.extend({
			makeElOption: function(t, e, i, n, r) {
				var a = i.axis,
					o = a.grid,
					s = n.get("type"),
					l = zf(o, a).getOtherAxis(a).getGlobalExtent(),
					u = a.toGlobalCoord(a.dataToCoord(e, !0));
				if (s && "none" !== s) {
					var h = Mf(n),
						c = MM[s](a, u, l);
					c.style = h, t.graphicKey = c.type, t.pointer = c
				}
				var d = Lf(o.model, i);
				kf(e, t, d, i, n, r)
			},
			getHandleTransform: function(t, e, i) {
				var n = Lf(e.axis.grid.model, e, {
					labelInside: !1
				});
				return n.labelMargin = i.get("handle.margin"), {
					position: Df(e.axis, t, n),
					rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0)
				}
			},
			updateHandleTransform: function(t, e, i) {
				var n = i.axis,
					r = n.grid,
					a = n.getGlobalExtent(!0),
					o = zf(r, n).getOtherAxis(n).getGlobalExtent(),
					s = "x" === n.dim ? 0 : 1,
					l = t.position;
				l[s] += e[s], l[s] = Math.min(a[1], l[s]), l[s] = Math.max(a[0], l[s]);
				var u = (o[1] + o[0]) / 2,
					h = [u, u];
				h[s] = l[s];
				var c = [{
					verticalAlign: "middle"
				}, {
					align: "center"
				}];
				return {
					position: l,
					rotation: t.rotation,
					cursorPoint: h,
					tooltipOption: c[s]
				}
			}
		}),
		MM = {
			line: function(t, e, i) {
				var n = Af([e, i[0]], [e, i[1]], Bf(t));
				return {
					type: "Line",
					subPixelOptimize: !0,
					shape: n
				}
			},
			shadow: function(t, e, i) {
				var n = Math.max(1, t.getBandWidth()),
					r = i[1] - i[0];
				return {
					type: "Rect",
					shape: Pf([e - n / 2, i[0]], [n, r], Bf(t))
				}
			}
		};
	wM.registerAxisPointerClass("CartesianAxisPointer", SM), yu(function(t) {
		if (t) {
			(!t.axisPointer || 0 === t.axisPointer.length) && (t.axisPointer = {});
			var e = t.axisPointer.link;
			e && !x(e) && (t.axisPointer.link = [e])
		}
	}), _u(hw.PROCESSOR.STATISTIC, function(t, e) {
		t.getComponent("axisPointer").coordSysAxesInfo = Ed(t, e)
	}), wu({
		type: "updateAxisPointer",
		event: "updateAxisPointer",
		update: ":updateAxisPointer"
	}, lM), Du({
		type: "tooltip",
		dependencies: ["axisPointer"],
		defaultOption: {
			zlevel: 0,
			z: 60,
			show: !0,
			showContent: !0,
			trigger: "item",
			triggerOn: "mousemove|click",
			alwaysShowContent: !1,
			displayMode: "single",
			renderMode: "auto",
			confine: !1,
			showDelay: 0,
			hideDelay: 100,
			transitionDuration: .4,
			enterable: !1,
			backgroundColor: "rgba(50,50,50,0.7)",
			borderColor: "#333",
			borderRadius: 4,
			borderWidth: 0,
			padding: 5,
			extraCssText: "",
			axisPointer: {
				type: "line",
				axis: "auto",
				animation: "auto",
				animationDurationUpdate: 200,
				animationEasingUpdate: "exponentialOut",
				crossStyle: {
					color: "#999",
					width: 1,
					type: "dashed",
					textStyle: {}
				}
			},
			textStyle: {
				color: "#fff",
				fontSize: 14
			}
		}
	});
	var IM = f,
		TM = Vo,
		CM = ["", "-webkit-", "-moz-", "-o-"],
		DM = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
	Hf.prototype = {
		constructor: Hf,
		_enterable: !0,
		update: function(t) {
			var e = this._container,
				i = e.currentStyle || document.defaultView.getComputedStyle(e),
				n = e.style;
			"absolute" !== n.position && "absolute" !== i.position && (n.position = "relative");
			var r = t.get("alwaysShowContent");
			r && this._moveTooltipIfResized()
		},
		_moveTooltipIfResized: function() {
			var t = this._styleCoord[2],
				e = this._styleCoord[3],
				i = t * this._zr.getWidth(),
				n = e * this._zr.getHeight();
			this.moveTo(i, n)
		},
		show: function(t) {
			clearTimeout(this._hideTimeout);
			var e = this.el,
				i = this._styleCoord;
			e.style.cssText = DM + Ff(t) + ";left:" + i[0] + "px;top:" + i[1] + "px;" + (t.get("extraCssText") || ""), e.style.display = e.innerHTML ? "block" : "none", e.style.pointerEvents = this._enterable ? "auto" : "none", this._show = !0
		},
		setContent: function(t) {
			this.el.innerHTML = null == t ? "" : t
		},
		setEnterable: function(t) {
			this._enterable = t
		},
		getSize: function() {
			var t = this.el;
			return [t.clientWidth, t.clientHeight]
		},
		moveTo: function(t, e) {
			var i = this._styleCoord;
			Vf(i, this._zr, this._appendToBody, t, e);
			var n = this.el.style;
			n.left = i[0] + "px", n.top = i[1] + "px"
		},
		hide: function() {
			this.el.style.display = "none", this._show = !1
		},
		hideLater: function(t) {
			!this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(y(this.hide, this), t)) : this.hide())
		},
		isShow: function() {
			return this._show
		},
		dispose: function() {
			this.el.parentNode.removeChild(this.el)
		},
		getOuterSize: function() {
			var t = this.el.clientWidth,
				e = this.el.clientHeight;
			if (document.defaultView && document.defaultView.getComputedStyle) {
				var i = document.defaultView.getComputedStyle(this.el);
				i && (t += parseInt(i.borderLeftWidth, 10) + parseInt(i.borderRightWidth, 10), e += parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10))
			}
			return {
				width: t,
				height: e
			}
		}
	}, Gf.prototype = {
		constructor: Gf,
		_enterable: !0,
		update: function(t) {
			var e = t.get("alwaysShowContent");
			e && this._moveTooltipIfResized()
		},
		_moveTooltipIfResized: function() {
			var t = this._styleCoord[2],
				e = this._styleCoord[3],
				i = t * this._zr.getWidth(),
				n = e * this._zr.getHeight();
			this.moveTo(i, n)
		},
		show: function() {
			this._hideTimeout && clearTimeout(this._hideTimeout), this.el.attr("show", !0), this._show = !0
		},
		setContent: function(t, e, i) {
			this.el && this._zr.remove(this.el);
			for (var n = {}, r = t, a = "{marker", o = "|}", s = r.indexOf(a); s >= 0;) {
				var l = r.indexOf(o),
					u = r.substr(s + a.length, l - s - a.length);
				n["marker" + u] = u.indexOf("sub") > -1 ? {
					textWidth: 4,
					textHeight: 4,
					textBorderRadius: 2,
					textBackgroundColor: e[u],
					textOffset: [3, 0]
				} : {
					textWidth: 10,
					textHeight: 10,
					textBorderRadius: 5,
					textBackgroundColor: e[u]
				}, r = r.substr(l + 1), s = r.indexOf("{marker")
			}
			var h = i.getModel("textStyle"),
				c = h.get("fontSize"),
				d = i.get("textLineHeight");
			null == d && (d = Math.round(3 * c / 2)), this.el = new hy({
				style: Xa({}, h, {
					rich: n,
					text: t,
					textBackgroundColor: i.get("backgroundColor"),
					textBorderRadius: i.get("borderRadius"),
					textFill: i.get("textStyle.color"),
					textPadding: i.get("padding"),
					textLineHeight: d
				}),
				z: i.get("z")
			}), this._zr.add(this.el);
			var f = this;
			this.el.on("mouseover", function() {
				f._enterable && (clearTimeout(f._hideTimeout), f._show = !0), f._inContent = !0
			}), this.el.on("mouseout", function() {
				f._enterable && f._show && f.hideLater(f._hideDelay), f._inContent = !1
			})
		},
		setEnterable: function(t) {
			this._enterable = t
		},
		getSize: function() {
			var t = this.el.getBoundingRect();
			return [t.width, t.height]
		},
		moveTo: function(t, e) {
			if (this.el) {
				var i = this._styleCoord;
				Wf(i, this._zr, t, e), this.el.attr("position", [i[0], i[1]])
			}
		},
		hide: function() {
			this.el && this.el.hide(), this._show = !1
		},
		hideLater: function(t) {
			!this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(y(this.hide, this), t)) : this.hide())
		},
		isShow: function() {
			return this._show
		},
		dispose: function() {
			clearTimeout(this._hideTimeout), this.el && this._zr.remove(this.el)
		},
		getOuterSize: function() {
			var t = this.getSize();
			return {
				width: t[0],
				height: t[1]
			}
		}
	};
	var kM = y,
		AM = f,
		PM = So,
		LM = new by({
			shape: {
				x: -1,
				y: -1,
				width: 2,
				height: 2
			}
		});
	ku({
		type: "tooltip",
		init: function(t, e) {
			if (!zp.node) {
				var i = t.getComponent("tooltip"),
					n = i.get("renderMode");
				this._renderMode = gr(n);
				var r;
				"html" === this._renderMode ? (r = new Hf(e.getDom(), e, {
					appendToBody: i.get("appendToBody", !0)
				}), this._newLine = "<br/>") : (r = new Gf(e), this._newLine = "\n"), this._tooltipContent = r
			}
		},
		render: function(t, e, i) {
			if (!zp.node) {
				this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastDataByCoordSys = null, this._alwaysShowContent = t.get("alwaysShowContent");
				var n = this._tooltipContent;
				n.update(t), n.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow()
			}
		},
		_initGlobalListener: function() {
			var t = this._tooltipModel,
				e = t.get("triggerOn");
			ef("itemTooltip", this._api, kM(function(t, i, n) {
				"none" !== e && (e.indexOf(t) >= 0 ? this._tryShow(i, n) : "leave" === t && this._hide(n))
			}, this))
		},
		_keepShow: function() {
			var t = this._tooltipModel,
				e = this._ecModel,
				i = this._api;
			if (null != this._lastX && null != this._lastY && "none" !== t.get("triggerOn")) {
				var n = this;
				clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
					!i.isDisposed() && n.manuallyShowTip(t, e, i, {
						x: n._lastX,
						y: n._lastY
					})
				})
			}
		},
		manuallyShowTip: function(t, e, i, n) {
			if (n.from !== this.uid && !zp.node) {
				var r = Xf(n, i);
				this._ticket = "";
				var a = n.dataByCoordSys;
				if (n.tooltip && null != n.x && null != n.y) {
					var o = LM;
					o.position = [n.x, n.y], o.update(), o.tooltip = n.tooltip, this._tryShow({
						offsetX: n.x,
						offsetY: n.y,
						target: o
					}, r)
				} else if (a) this._tryShow({
					offsetX: n.x,
					offsetY: n.y,
					position: n.position,
					dataByCoordSys: n.dataByCoordSys,
					tooltipOption: n.tooltipOption
				}, r);
				else if (null != n.seriesIndex) {
					if (this._manuallyAxisShowTip(t, e, i, n)) return;
					var s = rM(n, e),
						l = s.point[0],
						u = s.point[1];
					null != l && null != u && this._tryShow({
						offsetX: l,
						offsetY: u,
						position: n.position,
						target: s.el
					}, r)
				} else null != n.x && null != n.y && (i.dispatchAction({
					type: "updateAxisPointer",
					x: n.x,
					y: n.y
				}), this._tryShow({
					offsetX: n.x,
					offsetY: n.y,
					position: n.position,
					target: i.getZr().findHover(n.x, n.y).target
				}, r))
			}
		},
		manuallyHideTip: function(t, e, i, n) {
			var r = this._tooltipContent;
			!this._alwaysShowContent && this._tooltipModel && r.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = null, n.from !== this.uid && this._hide(Xf(n, i))
		},
		_manuallyAxisShowTip: function(t, e, i, n) {
			var r = n.seriesIndex,
				a = n.dataIndex,
				o = e.getComponent("axisPointer").coordSysAxesInfo;
			if (null != r && null != a && null != o) {
				var s = e.getSeriesByIndex(r);
				if (s) {
					var l = s.getData(),
						t = Uf([l.getItemModel(a), s, (s.coordinateSystem || {}).model, t]);
					if ("axis" === t.get("trigger")) return i.dispatchAction({
						type: "updateAxisPointer",
						seriesIndex: r,
						dataIndex: a,
						position: n.position
					}), !0
				}
			}
		},
		_tryShow: function(t, e) {
			var i = t.target,
				n = this._tooltipModel;
			if (n) {
				this._lastX = t.offsetX, this._lastY = t.offsetY;
				var r = t.dataByCoordSys;
				r && r.length ? this._showAxisTooltip(r, t) : i && null != i.dataIndex ? (this._lastDataByCoordSys = null, this._showSeriesItemTooltip(t, i, e)) : i && i.tooltip ? (this._lastDataByCoordSys = null, this._showComponentItemTooltip(t, i, e)) : (this._lastDataByCoordSys = null, this._hide(e))
			}
		},
		_showOrMove: function(t, e) {
			var i = t.get("showDelay");
			e = y(e, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(e, i) : e()
		},
		_showAxisTooltip: function(t, e) {
			var i = this._ecModel,
				n = this._tooltipModel,
				a = [e.offsetX, e.offsetY],
				o = [],
				s = [],
				l = Uf([e.tooltipOption, n]),
				u = this._renderMode,
				h = this._newLine,
				c = {};
			AM(t, function(t) {
				AM(t.dataByAxis, function(t) {
					var e = i.getComponent(t.axisDim + "Axis", t.axisIndex),
						n = t.value,
						a = [];
					if (e && null != n) {
						var l = Cf(n, e.axis, i, t.seriesDataIndices, t.valueLabelOpt);
						f(t.seriesDataIndices, function(o) {
							var h = i.getSeriesByIndex(o.seriesIndex),
								d = o.dataIndexInside,
								f = h && h.getDataParams(d);
							if (f.axisDim = t.axisDim, f.axisIndex = t.axisIndex, f.axisType = t.axisType, f.axisId = t.axisId, f.axisValue = Nh(e.axis, n), f.axisValueLabel = l, f) {
								s.push(f);
								var p, g = h.formatTooltip(d, !0, null, u);
								if (S(g)) {
									p = g.html;
									var v = g.markers;
									r(c, v)
								} else p = g;
								a.push(p)
							}
						});
						var d = l;
						o.push("html" !== u ? a.join(h) : (d ? Ho(d) + h : "") + a.join(h))
					}
				})
			}, this), o.reverse(), o = o.join(this._newLine + this._newLine);
			var d = e.position;
			this._showOrMove(l, function() {
				this._updateContentNotChangedOnAxis(t) ? this._updatePosition(l, d, a[0], a[1], this._tooltipContent, s) : this._showTooltipContent(l, o, s, Math.random(), a[0], a[1], d, void 0, c)
			})
		},
		_showSeriesItemTooltip: function(t, e, i) {
			var n = this._ecModel,
				r = e.seriesIndex,
				a = n.getSeriesByIndex(r),
				o = e.dataModel || a,
				s = e.dataIndex,
				l = e.dataType,
				u = o.getData(l),
				h = Uf([u.getItemModel(s), o, a && (a.coordinateSystem || {}).model, this._tooltipModel]),
				c = h.get("trigger");
			if (null == c || "item" === c) {
				var d, f, p = o.getDataParams(s, l),
					g = o.formatTooltip(s, !1, l, this._renderMode);
				S(g) ? (d = g.html, f = g.markers) : (d = g, f = null);
				var v = "item_" + o.name + "_" + s;
				this._showOrMove(h, function() {
					this._showTooltipContent(h, d, p, v, t.offsetX, t.offsetY, t.position, t.target, f)
				}), i({
					type: "showTip",
					dataIndexInside: s,
					dataIndex: u.getRawIndex(s),
					seriesIndex: r,
					from: this.uid
				})
			}
		},
		_showComponentItemTooltip: function(t, e, i) {
			var n = e.tooltip;
			if ("string" == typeof n) {
				var r = n;
				n = {
					content: r,
					formatter: r
				}
			}
			var a = new go(n, this._tooltipModel, this._ecModel),
				o = a.get("content"),
				s = Math.random();
			this._showOrMove(a, function() {
				this._showTooltipContent(a, o, a.get("formatterParams") || {}, s, t.offsetX, t.offsetY, t.position, e)
			}), i({
				type: "showTip",
				from: this.uid
			})
		},
		_showTooltipContent: function(t, e, i, n, r, a, o, s, l) {
			if (this._ticket = "", t.get("showContent") && t.get("show")) {
				var u = this._tooltipContent,
					h = t.get("formatter");
				o = o || t.get("position");
				var c = e;
				if (h && "string" == typeof h) c = Wo(h, i, !0);
				else if ("function" == typeof h) {
					var d = kM(function(e, n) {
						e === this._ticket && (u.setContent(n, l, t), this._updatePosition(t, o, r, a, u, i, s))
					}, this);
					this._ticket = n, c = h(i, n, d)
				}
				u.setContent(c, l, t), u.show(t), this._updatePosition(t, o, r, a, u, i, s)
			}
		},
		_updatePosition: function(t, e, i, n, r, a, o) {
			var s = this._api.getWidth(),
				l = this._api.getHeight();
			e = e || t.get("position");
			var u = r.getSize(),
				h = t.get("align"),
				c = t.get("verticalAlign"),
				d = o && o.getBoundingRect().clone();
			if (o && d.applyTransform(o.transform), "function" == typeof e && (e = e([i, n], a, r.el, d, {
					viewSize: [s, l],
					contentSize: u.slice()
				})), x(e)) i = PM(e[0], s), n = PM(e[1], l);
			else if (S(e)) {
				e.width = u[0], e.height = u[1];
				var f = Qo(e, {
					width: s,
					height: l
				});
				i = f.x, n = f.y, h = null, c = null
			} else if ("string" == typeof e && o) {
				var p = qf(e, d, u);
				i = p[0], n = p[1]
			} else {
				var p = jf(i, n, r, s, l, h ? null : 20, c ? null : 20);
				i = p[0], n = p[1]
			}
			if (h && (i -= Zf(h) ? u[0] / 2 : "right" === h ? u[0] : 0), c && (n -= Zf(c) ? u[1] / 2 : "bottom" === c ? u[1] : 0), t.get("confine")) {
				var p = Yf(i, n, r, s, l);
				i = p[0], n = p[1]
			}
			r.moveTo(i, n)
		},
		_updateContentNotChangedOnAxis: function(t) {
			var e = this._lastDataByCoordSys,
				i = !!e && e.length === t.length;
			return i && AM(e, function(e, n) {
				var r = e.dataByAxis || {},
					a = t[n] || {},
					o = a.dataByAxis || [];
				i &= r.length === o.length, i && AM(r, function(t, e) {
					var n = o[e] || {},
						r = t.seriesDataIndices || [],
						a = n.seriesDataIndices || [];
					i &= t.value === n.value && t.axisType === n.axisType && t.axisId === n.axisId && r.length === a.length, i && AM(r, function(t, e) {
						var n = a[e];
						i &= t.seriesIndex === n.seriesIndex && t.dataIndex === n.dataIndex
					})
				})
			}), this._lastDataByCoordSys = t, !!i
		},
		_hide: function(t) {
			this._lastDataByCoordSys = null, t({
				type: "hideTip",
				from: this.uid
			})
		},
		dispose: function(t, e) {
			zp.node || (this._tooltipContent.dispose(), lf("itemTooltip", e))
		}
	}), wu({
		type: "showTip",
		event: "showTip",
		update: "tooltip:manuallyShowTip"
	}, function() {}), wu({
		type: "hideTip",
		event: "hideTip",
		update: "tooltip:manuallyHideTip"
	}, function() {});
	var OM, EM = "urn:schemas-microsoft-com:vml",
		zM = "undefined" == typeof window ? null : window,
		BM = !1,
		RM = zM && zM.document;
	if (RM && !zp.canvasSupported) try {
		!RM.namespaces.zrvml && RM.namespaces.add("zrvml", EM), OM = function(t) {
			return RM.createElement("<zrvml:" + t + ' class="zrvml">')
		}
	} catch (NM) {
		OM = function(t) {
			return RM.createElement("<" + t + ' xmlns="' + EM + '" class="zrvml">')
		}
	}
	var FM = Fm.CMD,
		VM = Math.round,
		HM = Math.sqrt,
		WM = Math.abs,
		GM = Math.cos,
		UM = Math.sin,
		XM = Math.max;
	if (!zp.canvasSupported) {
		var jM = ",",
			YM = "progid:DXImageTransform.Microsoft",
			qM = 21600,
			ZM = qM / 2,
			KM = 1e5,
			$M = 1e3,
			QM = function(t) {
				t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = qM + "," + qM, t.coordorigin = "0,0"
			},
			JM = function(t) {
				return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
			},
			tI = function(t, e, i) {
				return "rgb(" + [t, e, i].join(",") + ")"
			},
			eI = function(t, e) {
				e && t && e.parentNode !== t && t.appendChild(e)
			},
			iI = function(t, e) {
				e && t && e.parentNode === t && t.removeChild(e)
			},
			nI = function(t, e, i) {
				return (parseFloat(t) || 0) * KM + (parseFloat(e) || 0) * $M + i
			},
			rI = In,
			aI = function(t, e, i) {
				var n = ti(e);
				i = +i, isNaN(i) && (i = 1), n && (t.color = tI(n[0], n[1], n[2]), t.opacity = i * n[3])
			},
			oI = function(t) {
				var e = ti(t);
				return [tI(e[0], e[1], e[2]), e[3]]
			},
			sI = function(t, e, i) {
				var n = e.fill;
				if (null != n)
					if (n instanceof ky) {
						var r, a = 0,
							o = [0, 0],
							s = 0,
							l = 1,
							u = i.getBoundingRect(),
							h = u.width,
							c = u.height;
						if ("linear" === n.type) {
							r = "gradient";
							var d = i.transform,
								f = [n.x * h, n.y * c],
								p = [n.x2 * h, n.y2 * c];
							d && (ae(f, f, d), ae(p, p, d));
							var g = p[0] - f[0],
								v = p[1] - f[1];
							a = 180 * Math.atan2(g, v) / Math.PI, 0 > a && (a += 360), 1e-6 > a && (a = 0)
						} else {
							r = "gradientradial";
							var f = [n.x * h, n.y * c],
								d = i.transform,
								m = i.scale,
								y = h,
								_ = c;
							o = [(f[0] - u.x) / y, (f[1] - u.y) / _], d && ae(f, f, d), y /= m[0] * qM, _ /= m[1] * qM;
							var x = XM(y, _);
							s = 0 / x, l = 2 * n.r / x - s
						}
						var w = n.colorStops.slice();
						w.sort(function(t, e) {
							return t.offset - e.offset
						});
						for (var b = w.length, S = [], M = [], I = 0; b > I; I++) {
							var T = w[I],
								C = oI(T.color);
							M.push(T.offset * l + s + " " + C[0]), (0 === I || I === b - 1) && S.push(C)
						}
						if (b >= 2) {
							var D = S[0][0],
								k = S[1][0],
								A = S[0][1] * e.opacity,
								P = S[1][1] * e.opacity;
							t.type = r, t.method = "none", t.focus = "100%", t.angle = a, t.color = D, t.color2 = k, t.colors = M.join(","), t.opacity = P, t.opacity2 = A
						}
						"radial" === r && (t.focusposition = o.join(","))
					} else aI(t, n, e.opacity)
			},
			lI = function(t, e) {
				e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e.stroke || e.stroke instanceof ky || aI(t, e.stroke, e.opacity)
			},
			uI = function(t, e, i, n) {
				var r = "fill" === e,
					a = t.getElementsByTagName(e)[0];
				null != i[e] && "none" !== i[e] && (r || !r && i.lineWidth) ? (t[r ? "filled" : "stroked"] = "true", i[e] instanceof ky && iI(t, a), a || (a = Kf(e)), r ? sI(a, i, n) : lI(a, i), eI(t, a)) : (t[r ? "filled" : "stroked"] = "false", iI(t, a))
			},
			hI = [
				[],
				[],
				[]
			],
			cI = function(t, e) {
				var i, n, r, a, o, s, l = FM.M,
					u = FM.C,
					h = FM.L,
					c = FM.A,
					d = FM.Q,
					f = [],
					p = t.data,
					g = t.len();
				for (a = 0; g > a;) {
					switch (r = p[a++], n = "", i = 0, r) {
						case l:
							n = " m ", i = 1, o = p[a++], s = p[a++], hI[0][0] = o, hI[0][1] = s;
							break;
						case h:
							n = " l ", i = 1, o = p[a++], s = p[a++], hI[0][0] = o, hI[0][1] = s;
							break;
						case d:
						case u:
							n = " c ", i = 3;
							var v, m, y = p[a++],
								_ = p[a++],
								x = p[a++],
								w = p[a++];
							r === d ? (v = x, m = w, x = (x + 2 * y) / 3, w = (w + 2 * _) / 3, y = (o + 2 * y) / 3, _ = (s + 2 * _) / 3) : (v = p[a++], m = p[a++]), hI[0][0] = y, hI[0][1] = _, hI[1][0] = x, hI[1][1] = w, hI[2][0] = v, hI[2][1] = m, o = v, s = m;
							break;
						case c:
							var b = 0,
								S = 0,
								M = 1,
								I = 1,
								T = 0;
							e && (b = e[4], S = e[5], M = HM(e[0] * e[0] + e[1] * e[1]), I = HM(e[2] * e[2] + e[3] * e[3]), T = Math.atan2(-e[1] / I, e[0] / M));
							var C = p[a++],
								D = p[a++],
								k = p[a++],
								A = p[a++],
								P = p[a++] + T,
								L = p[a++] + P + T;
							a++;
							var O = p[a++],
								E = C + GM(P) * k,
								z = D + UM(P) * A,
								y = C + GM(L) * k,
								_ = D + UM(L) * A,
								B = O ? " wa " : " at ";
							Math.abs(E - y) < 1e-4 && (Math.abs(L - P) > .01 ? O && (E += 270 / qM) : Math.abs(z - D) < 1e-4 ? O && C > E || !O && E > C ? _ -= 270 / qM : _ += 270 / qM : O && D > z || !O && z > D ? y += 270 / qM : y -= 270 / qM), f.push(B, VM(((C - k) * M + b) * qM - ZM), jM, VM(((D - A) * I + S) * qM - ZM), jM, VM(((C + k) * M + b) * qM - ZM), jM, VM(((D + A) * I + S) * qM - ZM), jM, VM((E * M + b) * qM - ZM), jM, VM((z * I + S) * qM - ZM), jM, VM((y * M + b) * qM - ZM), jM, VM((_ * I + S) * qM - ZM)), o = y, s = _;
							break;
						case FM.R:
							var R = hI[0],
								N = hI[1];
							R[0] = p[a++], R[1] = p[a++], N[0] = R[0] + p[a++], N[1] = R[1] + p[a++], e && (ae(R, R, e), ae(N, N, e)), R[0] = VM(R[0] * qM - ZM), N[0] = VM(N[0] * qM - ZM), R[1] = VM(R[1] * qM - ZM), N[1] = VM(N[1] * qM - ZM), f.push(" m ", R[0], jM, R[1], " l ", N[0], jM, R[1], " l ", N[0], jM, N[1], " l ", R[0], jM, N[1]);
							break;
						case FM.Z:
							f.push(" x ")
					}
					if (i > 0) {
						f.push(n);
						for (var F = 0; i > F; F++) {
							var V = hI[F];
							e && ae(V, V, e), f.push(VM(V[0] * qM - ZM), jM, VM(V[1] * qM - ZM), i - 1 > F ? jM : "")
						}
					}
				}
				return f.join("")
			};
		ia.prototype.brushVML = function(t) {
			var e = this.style,
				i = this._vmlEl;
			i || (i = Kf("shape"), QM(i), this._vmlEl = i), uI(i, "fill", e, this), uI(i, "stroke", e, this);
			var n = this.transform,
				r = null != n,
				a = i.getElementsByTagName("stroke")[0];
			if (a) {
				var o = e.lineWidth;
				if (r && !e.strokeNoScale) {
					var s = n[0] * n[3] - n[1] * n[2];
					o *= HM(WM(s))
				}
				a.weight = o + "px"
			}
			var l = this.path || (this.path = new Fm);
			this.__dirtyPath && (l.beginPath(), l.subPixelOptimize = !1, this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1), i.path = cI(l, this.transform), i.style.zIndex = nI(this.zlevel, this.z, this.z2), eI(t, i), null != e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t)
		}, ia.prototype.onRemove = function(t) {
			iI(t, this._vmlEl), this.removeRectText(t)
		}, ia.prototype.onAdd = function(t) {
			eI(t, this._vmlEl), this.appendRectText(t)
		};
		var dI = function(t) {
			return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase()
		};
		kn.prototype.brushVML = function(t) {
			var e, i, n = this.style,
				r = n.image;
			if (dI(r)) {
				var a = r.src;
				if (a === this._imageSrc) e = this._imageWidth, i = this._imageHeight;
				else {
					var o = r.runtimeStyle,
						s = o.width,
						l = o.height;
					o.width = "auto", o.height = "auto", e = r.width, i = r.height, o.width = s, o.height = l, this._imageSrc = a, this._imageWidth = e, this._imageHeight = i
				}
				r = a
			} else r === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);
			if (r) {
				var u = n.x || 0,
					h = n.y || 0,
					c = n.width,
					d = n.height,
					f = n.sWidth,
					p = n.sHeight,
					g = n.sx || 0,
					v = n.sy || 0,
					m = f && p,
					y = this._vmlEl;
				y || (y = RM.createElement("div"), QM(y), this._vmlEl = y);
				var _, x = y.style,
					w = !1,
					b = 1,
					S = 1;
				if (this.transform && (_ = this.transform, b = HM(_[0] * _[0] + _[1] * _[1]), S = HM(_[2] * _[2] + _[3] * _[3]), w = _[1] || _[2]), w) {
					var M = [u, h],
						I = [u + c, h],
						T = [u, h + d],
						C = [u + c, h + d];
					ae(M, M, _), ae(I, I, _), ae(T, T, _), ae(C, C, _);
					var D = XM(M[0], I[0], T[0], C[0]),
						k = XM(M[1], I[1], T[1], C[1]),
						A = [];
					A.push("M11=", _[0] / b, jM, "M12=", _[2] / S, jM, "M21=", _[1] / b, jM, "M22=", _[3] / S, jM, "Dx=", VM(u * b + _[4]), jM, "Dy=", VM(h * S + _[5])), x.padding = "0 " + VM(D) + "px " + VM(k) + "px 0", x.filter = YM + ".Matrix(" + A.join("") + ", SizingMethod=clip)"
				} else _ && (u = u * b + _[4], h = h * S + _[5]), x.filter = "", x.left = VM(u) + "px", x.top = VM(h) + "px";
				var P = this._imageEl,
					L = this._cropEl;
				P || (P = RM.createElement("div"), this._imageEl = P);
				var O = P.style;
				if (m) {
					if (e && i) O.width = VM(b * e * c / f) + "px", O.height = VM(S * i * d / p) + "px";
					else {
						var E = new Image,
							z = this;
						E.onload = function() {
							E.onload = null, e = E.width, i = E.height, O.width = VM(b * e * c / f) + "px", O.height = VM(S * i * d / p) + "px", z._imageWidth = e, z._imageHeight = i, z._imageSrc = r
						}, E.src = r
					}
					L || (L = RM.createElement("div"), L.style.overflow = "hidden", this._cropEl = L);
					var B = L.style;
					B.width = VM((c + g * c / f) * b), B.height = VM((d + v * d / p) * S), B.filter = YM + ".Matrix(Dx=" + -g * c / f * b + ",Dy=" + -v * d / p * S + ")", L.parentNode || y.appendChild(L), P.parentNode !== L && L.appendChild(P)
				} else O.width = VM(b * c) + "px", O.height = VM(S * d) + "px", y.appendChild(P), L && L.parentNode && (y.removeChild(L), this._cropEl = null);
				var R = "",
					N = n.opacity;
				1 > N && (R += ".Alpha(opacity=" + VM(100 * N) + ") "), R += YM + ".AlphaImageLoader(src=" + r + ", SizingMethod=scale)", O.filter = R, y.style.zIndex = nI(this.zlevel, this.z, this.z2), eI(t, y), null != n.text && this.drawRectText(t, this.getBoundingRect())
			}
		}, kn.prototype.onRemove = function(t) {
			iI(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t)
		}, kn.prototype.onAdd = function(t) {
			eI(t, this._vmlEl), this.appendRectText(t)
		};
		var fI, pI = "normal",
			gI = {},
			vI = 0,
			mI = 100,
			yI = document.createElement("div"),
			_I = function(t) {
				var e = gI[t];
				if (!e) {
					vI > mI && (vI = 0, gI = {});
					var i, n = yI.style;
					try {
						n.font = t, i = n.fontFamily.split(",")[0]
					} catch (r) {}
					e = {
						style: n.fontStyle || pI,
						variant: n.fontVariant || pI,
						weight: n.fontWeight || pI,
						size: 0 | parseFloat(n.fontSize || 12),
						family: i || "Microsoft YaHei"
					}, gI[t] = e, vI++
				}
				return e
			};
		Ui("measureText", function(t, e) {
			var i = RM;
			fI || (fI = i.createElement("div"), fI.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", RM.body.appendChild(fI));
			try {
				fI.style.font = e
			} catch (n) {}
			return fI.innerHTML = "", fI.appendChild(i.createTextNode(t)), {
				width: fI.offsetWidth
			}
		});
		for (var xI = new Ti, wI = function(t, e, i, n) {
				var r = this.style;
				this.__dirty && hn(r, !0);
				var a = r.text;
				if (null != a && (a += ""), a) {
					if (r.rich) {
						var o = on(a, r);
						a = [];
						for (var s = 0; s < o.lines.length; s++) {
							for (var l = o.lines[s].tokens, u = [], h = 0; h < l.length; h++) u.push(l[h].text);
							a.push(u.join(""))
						}
						a = a.join("\n")
					}
					var c, d, f = r.textAlign,
						p = r.textVerticalAlign,
						g = _I(r.font),
						v = g.style + " " + g.variant + " " + g.weight + " " + g.size + 'px "' + g.family + '"';
					i = i || ji(a, v, f, p, r.textPadding, r.textLineHeight);
					var m = this.transform;
					if (m && !n && (xI.copy(e), xI.applyTransform(m), e = xI), n) c = e.x, d = e.y;
					else {
						var y = r.textPosition;
						if (y instanceof Array) c = e.x + rI(y[0], e.width), d = e.y + rI(y[1], e.height), f = f || "left";
						else {
							var _ = this.calculateTextPosition ? this.calculateTextPosition({}, r, e) : $i({}, r, e);
							c = _.x, d = _.y, f = f || _.textAlign, p = p || _.textVerticalAlign
						}
					}
					c = Zi(c, i.width, f), d = Ki(d, i.height, p), d += i.height / 2;
					var x, w, b, S = Kf,
						M = this._textVmlEl;
					M ? (b = M.firstChild, x = b.nextSibling, w = x.nextSibling) : (M = S("line"), x = S("path"), w = S("textpath"), b = S("skew"), w.style["v-text-align"] = "left", QM(M), x.textpathok = !0, w.on = !0, M.from = "0 0", M.to = "1000 0.05", eI(M, b), eI(M, x), eI(M, w), this._textVmlEl = M);
					var I = [c, d],
						T = M.style;
					m && n ? (ae(I, I, m), b.on = !0, b.matrix = m[0].toFixed(3) + jM + m[2].toFixed(3) + jM + m[1].toFixed(3) + jM + m[3].toFixed(3) + ",0,0", b.offset = (VM(I[0]) || 0) + "," + (VM(I[1]) || 0), b.origin = "0 0", T.left = "0px", T.top = "0px") : (b.on = !1, T.left = VM(c) + "px", T.top = VM(d) + "px"), w.string = JM(a);
					try {
						w.style.font = v
					} catch (C) {}
					uI(M, "fill", {
						fill: r.textFill,
						opacity: r.opacity
					}, this), uI(M, "stroke", {
						stroke: r.textStroke,
						opacity: r.opacity,
						lineDash: r.lineDash || null
					}, this), M.style.zIndex = nI(this.zlevel, this.z, this.z2), eI(t, M)
				}
			}, bI = function(t) {
				iI(t, this._textVmlEl), this._textVmlEl = null
			}, SI = function(t) {
				eI(t, this._textVmlEl)
			}, MI = [Iv, Dn, kn, ia, hy], II = 0; II < MI.length; II++) {
			var TI = MI[II].prototype;
			TI.drawRectText = wI, TI.removeRectText = bI, TI.appendRectText = SI
		}
		hy.prototype.brushVML = function(t) {
			var e = this.style;
			null != e.text ? this.drawRectText(t, {
				x: e.x || 0,
				y: e.y || 0,
				width: 0,
				height: 0
			}, this.getBoundingRect(), !0) : this.removeRectText(t)
		}, hy.prototype.onRemove = function(t) {
			this.removeRectText(t)
		}, hy.prototype.onAdd = function(t) {
			this.appendRectText(t)
		}
	}
	Jf.prototype = {
		constructor: Jf,
		getType: function() {
			return "vml"
		},
		getViewportRoot: function() {
			return this._vmlViewport
		},
		getViewportRootOffset: function() {
			var t = this.getViewportRoot();
			return t ? {
				offsetLeft: t.offsetLeft || 0,
				offsetTop: t.offsetTop || 0
			} : void 0
		},
		refresh: function() {
			var t = this.storage.getDisplayList(!0, !0);
			this._paintList(t)
		},
		_paintList: function(t) {
			for (var e = this._vmlRoot, i = 0; i < t.length; i++) {
				var n = t[i];
				n.invisible || n.ignore ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n.__dirty = !1
			}
			this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1)
		},
		resize: function(t, e) {
			var t = null == t ? this._getWidth() : t,
				e = null == e ? this._getHeight() : e;
			if (this._width !== t || this._height !== e) {
				this._width = t, this._height = e;
				var i = this._vmlViewport.style;
				i.width = t + "px", i.height = e + "px"
			}
		},
		dispose: function() {
			this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null
		},
		getWidth: function() {
			return this._width
		},
		getHeight: function() {
			return this._height
		},
		clear: function() {
			this._vmlViewport && this.root.removeChild(this._vmlViewport)
		},
		_getWidth: function() {
			var t = this.root,
				e = t.currentStyle;
			return (t.clientWidth || Qf(e.width)) - Qf(e.paddingLeft) - Qf(e.paddingRight) | 0
		},
		_getHeight: function() {
			var t = this.root,
				e = t.currentStyle;
			return (t.clientHeight || Qf(e.height)) - Qf(e.paddingTop) - Qf(e.paddingBottom) | 0
		}
	}, f(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function(t) {
		Jf.prototype[t] = tp(t)
	}), Jn("vml", Jf);
	var CI = "http://www.w3.org/2000/svg",
		DI = Fm.CMD,
		kI = Array.prototype.join,
		AI = "none",
		PI = Math.round,
		LI = Math.sin,
		OI = Math.cos,
		EI = Math.PI,
		zI = 2 * Math.PI,
		BI = 180 / EI,
		RI = 1e-4,
		NI = {};
	NI.brush = function(t) {
		var e = t.style,
			i = t.__svgEl;
		i || (i = ep("path"), t.__svgEl = i), t.path || t.createPathProxy();
		var n = t.path;
		if (t.__dirtyPath) {
			n.beginPath(), n.subPixelOptimize = !1, t.buildPath(n, t.shape), t.__dirtyPath = !1;
			var r = hp(n);
			r.indexOf("NaN") < 0 && sp(i, "d", r)
		}
		up(i, e, !1, t), op(i, t.transform), null != e.text ? XI(t, t.getBoundingRect()) : pp(t)
	};
	var FI = {};
	FI.brush = function(t) {
		var e = t.style,
			i = e.image;
		if (i instanceof HTMLImageElement) {
			var n = i.src;
			i = n
		}
		if (i) {
			var r = e.x || 0,
				a = e.y || 0,
				o = e.width,
				s = e.height,
				l = t.__svgEl;
			l || (l = ep("image"), t.__svgEl = l), i !== t.__imageSrc && (lp(l, "href", i), t.__imageSrc = i), sp(l, "width", o), sp(l, "height", s), sp(l, "x", r), sp(l, "y", a), op(l, t.transform), null != e.text ? XI(t, t.getBoundingRect()) : pp(t)
		}
	};
	var VI = {},
		HI = new Ti,
		WI = {},
		GI = [],
		UI = {
			left: "start",
			right: "end",
			center: "middle",
			middle: "middle"
		},
		XI = function(t, e) {
			var i = t.style,
				n = t.transform,
				r = t instanceof hy || i.transformText;
			t.__dirty && hn(i, !0);
			var a = i.text;
			if (null != a && (a += ""), Cn(a, i)) {
				null == a && (a = ""), !r && n && (HI.copy(e), HI.applyTransform(n), e = HI);
				var o = t.__textSvgEl;
				o || (o = ep("text"), t.__textSvgEl = o);
				var s = o.style,
					l = i.font || vv,
					u = o.__computedFont;
				l !== o.__styleFont && (s.font = o.__styleFont = l, u = o.__computedFont = s.font);
				var h = i.textPadding,
					c = i.textLineHeight,
					d = t.__textCotentBlock;
				(!d || t.__dirtyText) && (d = t.__textCotentBlock = an(a, u, h, c, i.truncate));
				var f = d.outerHeight,
					p = d.lineHeight;
				wn(WI, t, i, e);
				var g = WI.baseX,
					v = WI.baseY,
					m = WI.textAlign || "left",
					y = WI.textVerticalAlign;
				cp(o, r, n, i, e, g, v);
				var _ = Ki(v, f, y),
					x = g,
					w = _;
				h && (x = dp(g, m, h), w += h[0]), w += p / 2, up(o, i, !0, t);
				var b = d.canCacheByTextString,
					S = t.__tspanList || (t.__tspanList = []),
					M = S.length;
				if (b && t.__canCacheByTextString && t.__text === a) {
					if (t.__dirtyText && M)
						for (var I = 0; M > I; ++I) fp(S[I], m, x, w + I * p)
				} else {
					t.__text = a, t.__canCacheByTextString = b;
					for (var T = d.lines, C = T.length, I = 0; C > I; I++) {
						var D = S[I],
							k = T[I];
						D ? D.__zrText !== k && (D.innerHTML = "", D.appendChild(document.createTextNode(k))) : (D = S[I] = ep("tspan"), o.appendChild(D), D.appendChild(document.createTextNode(k))), fp(D, m, x, w + I * p)
					}
					if (M > C) {
						for (; M > I; I++) o.removeChild(S[I]);
						S.length = C
					}
				}
			}
		};
	VI.drawRectText = XI, VI.brush = function(t) {
		var e = t.style;
		null != e.text ? XI(t, !1) : pp(t)
	}, gp.prototype = {
		diff: function(t, e, i) {
			function n() {
				for (var i = -1 * s; s >= i; i += 2) {
					var n, l = u[i - 1],
						h = u[i + 1],
						c = (h ? h.newPos : 0) - i;
					l && (u[i - 1] = void 0);
					var d = l && l.newPos + 1 < a,
						f = h && c >= 0 && o > c;
					if (d || f) {
						if (!d || f && l.newPos < h.newPos ? (n = mp(h), r.pushComponent(n.components, void 0, !0)) : (n = l, n.newPos++, r.pushComponent(n.components, !0, void 0)), c = r.extractCommon(n, e, t, i), n.newPos + 1 >= a && c + 1 >= o) return vp(r, n.components, e, t);
						u[i] = n
					} else u[i] = void 0
				}
				s++
			}
			i || (i = function(t, e) {
				return t === e
			}), this.equals = i;
			var r = this;
			t = t.slice(), e = e.slice();
			var a = e.length,
				o = t.length,
				s = 1,
				l = a + o,
				u = [{
					newPos: -1,
					components: []
				}],
				h = this.extractCommon(u[0], e, t, 0);
			if (u[0].newPos + 1 >= a && h + 1 >= o) {
				for (var c = [], d = 0; d < e.length; d++) c.push(d);
				return [{
					indices: c,
					count: e.length
				}]
			}
			for (; l >= s;) {
				var f = n();
				if (f) return f
			}
		},
		pushComponent: function(t, e, i) {
			var n = t[t.length - 1];
			n && n.added === e && n.removed === i ? t[t.length - 1] = {
				count: n.count + 1,
				added: e,
				removed: i
			} : t.push({
				count: 1,
				added: e,
				removed: i
			})
		},
		extractCommon: function(t, e, i, n) {
			for (var r = e.length, a = i.length, o = t.newPos, s = o - n, l = 0; r > o + 1 && a > s + 1 && this.equals(e[o + 1], i[s + 1]);) o++, s++, l++;
			return l && t.components.push({
				count: l
			}), t.newPos = o, s
		},
		tokenize: function(t) {
			return t.slice()
		},
		join: function(t) {
			return t.slice()
		}
	};
	var jI = new gp,
		YI = function(t, e, i) {
			return jI.diff(t, e, i)
		},
		qI = "0",
		ZI = "1";
	yp.prototype.createElement = ep, yp.prototype.getDefs = function(t) {
		var e = this._svgRoot,
			i = this._svgRoot.getElementsByTagName("defs");
		return 0 === i.length ? t ? (i = e.insertBefore(this.createElement("defs"), e.firstChild), i.contains || (i.contains = function(t) {
			var e = i.children;
			if (!e) return !1;
			for (var n = e.length - 1; n >= 0; --n)
				if (e[n] === t) return !0;
			return !1
		}), i) : null : i[0]
	}, yp.prototype.update = function(t, e) {
		if (t) {
			var i = this.getDefs(!1);
			if (t[this._domName] && i.contains(t[this._domName])) "function" == typeof e && e(t);
			else {
				var n = this.add(t);
				n && (t[this._domName] = n)
			}
		}
	}, yp.prototype.addDom = function(t) {
		var e = this.getDefs(!0);
		e.appendChild(t)
	}, yp.prototype.removeDom = function(t) {
		var e = this.getDefs(!1);
		e && t[this._domName] && (e.removeChild(t[this._domName]), t[this._domName] = null)
	}, yp.prototype.getDoms = function() {
		var t = this.getDefs(!1);
		if (!t) return [];
		var e = [];
		return f(this._tagNames, function(i) {
			var n = t.getElementsByTagName(i);
			e = e.concat([].slice.call(n))
		}), e
	}, yp.prototype.markAllUnused = function() {
		var t = this.getDoms(),
			e = this;
		f(t, function(t) {
			t[e._markLabel] = qI
		})
	}, yp.prototype.markUsed = function(t) {
		t && (t[this._markLabel] = ZI)
	}, yp.prototype.removeUnused = function() {
		var t = this.getDefs(!1);
		if (t) {
			var e = this.getDoms(),
				i = this;
			f(e, function(e) {
				e[i._markLabel] !== ZI && t.removeChild(e)
			})
		}
	}, yp.prototype.getSvgProxy = function(t) {
		return t instanceof ia ? NI : t instanceof kn ? FI : t instanceof hy ? VI : NI
	}, yp.prototype.getTextSvgElement = function(t) {
		return t.__textSvgEl
	}, yp.prototype.getSvgElement = function(t) {
		return t.__svgEl
	}, h(_p, yp), _p.prototype.addWithoutUpdate = function(t, e) {
		if (e && e.style) {
			var i = this;
			f(["fill", "stroke"], function(n) {
				if (e.style[n] && ("linear" === e.style[n].type || "radial" === e.style[n].type)) {
					var r, a = e.style[n],
						o = i.getDefs(!0);
					a._dom ? (r = a._dom, o.contains(a._dom) || i.addDom(r)) : r = i.add(a), i.markUsed(e);
					var s = r.getAttribute("id");
					t.setAttribute(n, "url(#" + s + ")")
				}
			})
		}
	}, _p.prototype.add = function(t) {
		var e;
		if ("linear" === t.type) e = this.createElement("linearGradient");
		else {
			if ("radial" !== t.type) return Gg("Illegal gradient type."), null;
			e = this.createElement("radialGradient")
		}
		return t.id = t.id || this.nextId++, e.setAttribute("id", "zr" + this._zrId + "-gradient-" + t.id), this.updateDom(t, e), this.addDom(e), e
	}, _p.prototype.update = function(t) {
		var e = this;
		yp.prototype.update.call(this, t, function() {
			var i = t.type,
				n = t._dom.tagName;
			"linear" === i && "linearGradient" === n || "radial" === i && "radialGradient" === n ? e.updateDom(t, t._dom) : (e.removeDom(t), e.add(t))
		})
	}, _p.prototype.updateDom = function(t, e) {
		if ("linear" === t.type) e.setAttribute("x1", t.x), e.setAttribute("y1", t.y), e.setAttribute("x2", t.x2), e.setAttribute("y2", t.y2);
		else {
			if ("radial" !== t.type) return void Gg("Illegal gradient type.");
			e.setAttribute("cx", t.x), e.setAttribute("cy", t.y), e.setAttribute("r", t.r)
		}
		t.global ? e.setAttribute("gradientUnits", "userSpaceOnUse") : e.setAttribute("gradientUnits", "objectBoundingBox"), e.innerHTML = "";
		for (var i = t.colorStops, n = 0, r = i.length; r > n; ++n) {
			var a = this.createElement("stop");
			a.setAttribute("offset", 100 * i[n].offset + "%");
			var o = i[n].color;
			if (o.indexOf("rgba") > -1) {
				var s = ti(o)[3],
					l = ri(o);
				a.setAttribute("stop-color", "#" + l), a.setAttribute("stop-opacity", s)
			} else a.setAttribute("stop-color", i[n].color);
			e.appendChild(a)
		}
		t._dom = e
	}, _p.prototype.markUsed = function(t) {
		if (t.style) {
			var e = t.style.fill;
			e && e._dom && yp.prototype.markUsed.call(this, e._dom), e = t.style.stroke, e && e._dom && yp.prototype.markUsed.call(this, e._dom)
		}
	}, h(xp, yp), xp.prototype.update = function(t) {
		var e = this.getSvgElement(t);
		e && this.updateDom(e, t.__clipPaths, !1);
		var i = this.getTextSvgElement(t);
		i && this.updateDom(i, t.__clipPaths, !0), this.markUsed(t)
	}, xp.prototype.updateDom = function(t, e, i) {
		if (e && e.length > 0) {
			var n, r, a = this.getDefs(!0),
				o = e[0],
				s = i ? "_textDom" : "_dom";
			o[s] ? (r = o[s].getAttribute("id"), n = o[s], a.contains(n) || a.appendChild(n)) : (r = "zr" + this._zrId + "-clip-" + this.nextId, ++this.nextId, n = this.createElement("clipPath"), n.setAttribute("id", r), a.appendChild(n), o[s] = n);
			var l = this.getSvgProxy(o);
			if (o.transform && o.parent.invTransform && !i) {
				var u = Array.prototype.slice.call(o.transform);
				Be(o.transform, o.parent.invTransform, o.transform), l.brush(o), o.transform = u
			} else l.brush(o);
			var h = this.getSvgElement(o);
			n.innerHTML = "", n.appendChild(h.cloneNode()), t.setAttribute("clip-path", "url(#" + r + ")"), e.length > 1 && this.updateDom(n, e.slice(1), i)
		} else t && t.setAttribute("clip-path", "none")
	}, xp.prototype.markUsed = function(t) {
		var e = this;
		t.__clipPaths && f(t.__clipPaths, function(t) {
			t._dom && yp.prototype.markUsed.call(e, t._dom), t._textDom && yp.prototype.markUsed.call(e, t._textDom)
		})
	}, h(wp, yp), wp.prototype.addWithoutUpdate = function(t, e) {
		if (e && bp(e.style)) {
			var i;
			if (e._shadowDom) {
				i = e._shadowDom;
				var n = this.getDefs(!0);
				n.contains(e._shadowDom) || this.addDom(i)
			} else i = this.add(e);
			this.markUsed(e);
			var r = i.getAttribute("id");
			t.style.filter = "url(#" + r + ")"
		}
	}, wp.prototype.add = function(t) {
		var e = this.createElement("filter");
		return t._shadowDomId = t._shadowDomId || this.nextId++, e.setAttribute("id", "zr" + this._zrId + "-shadow-" + t._shadowDomId), this.updateDom(t, e), this.addDom(e), e
	}, wp.prototype.update = function(t, e) {
		var i = e.style;
		if (bp(i)) {
			var n = this;
			yp.prototype.update.call(this, e, function() {
				n.updateDom(e, e._shadowDom)
			})
		} else this.remove(t, e)
	}, wp.prototype.remove = function(t, e) {
		null != e._shadowDomId && (this.removeDom(t), t.style.filter = "")
	}, wp.prototype.updateDom = function(t, e) {
		var i = e.getElementsByTagName("feDropShadow");
		i = 0 === i.length ? this.createElement("feDropShadow") : i[0];
		var n, r, a, o, s = t.style,
			l = t.scale ? t.scale[0] || 1 : 1,
			u = t.scale ? t.scale[1] || 1 : 1;
		if (s.shadowBlur || s.shadowOffsetX || s.shadowOffsetY) n = s.shadowOffsetX || 0, r = s.shadowOffsetY || 0, a = s.shadowBlur, o = s.shadowColor;
		else {
			if (!s.textShadowBlur) return void this.removeDom(e, s);
			n = s.textShadowOffsetX || 0, r = s.textShadowOffsetY || 0, a = s.textShadowBlur, o = s.textShadowColor
		}
		i.setAttribute("dx", n / l), i.setAttribute("dy", r / u), i.setAttribute("flood-color", o);
		var h = a / 2 / l,
			c = a / 2 / u,
			d = h + " " + c;
		i.setAttribute("stdDeviation", d), e.setAttribute("x", "-100%"), e.setAttribute("y", "-100%"), e.setAttribute("width", Math.ceil(a / 2 * 200) + "%"), e.setAttribute("height", Math.ceil(a / 2 * 200) + "%"), e.appendChild(i), t._shadowDom = e
	}, wp.prototype.markUsed = function(t) {
		t._shadowDom && yp.prototype.markUsed.call(this, t._shadowDom)
	};
	var KI = function(t, e, i, n) {
		this.root = t, this.storage = e, this._opts = i = o({}, i || {});
		var r = ep("svg");
		r.setAttribute("xmlns", "http://www.w3.org/2000/svg"), r.setAttribute("version", "1.1"), r.setAttribute("baseProfile", "full"), r.style.cssText = "user-select:none;position:absolute;left:0;top:0;";
		var a = ep("g");
		r.appendChild(a);
		var s = ep("g");
		r.appendChild(s), this.gradientManager = new _p(n, s), this.clipPathManager = new xp(n, s), this.shadowManager = new wp(n, s);
		var l = document.createElement("div");
		l.style.cssText = "overflow:hidden;position:relative", this._svgDom = r, this._svgRoot = s, this._backgroundRoot = a, this._viewport = l, t.appendChild(l), l.appendChild(r), this.resize(i.width, i.height), this._visibleList = []
	};
	KI.prototype = {
		constructor: KI,
		getType: function() {
			return "svg"
		},
		getViewportRoot: function() {
			return this._viewport
		},
		getSvgDom: function() {
			return this._svgDom
		},
		getSvgRoot: function() {
			return this._svgRoot
		},
		getViewportRootOffset: function() {
			var t = this.getViewportRoot();
			return t ? {
				offsetLeft: t.offsetLeft || 0,
				offsetTop: t.offsetTop || 0
			} : void 0
		},
		refresh: function() {
			var t = this.storage.getDisplayList(!0);
			this._paintList(t)
		},
		setBackgroundColor: function(t) {
			this._backgroundRoot && this._backgroundNode && this._backgroundRoot.removeChild(this._backgroundNode);
			var e = ep("rect");
			e.setAttribute("width", this.getWidth()), e.setAttribute("height", this.getHeight()), e.setAttribute("x", 0), e.setAttribute("y", 0), e.setAttribute("id", 0), e.style.fill = t, this._backgroundRoot.appendChild(e), this._backgroundNode = e
		},
		_paintList: function(t) {
			this.gradientManager.markAllUnused(), this.clipPathManager.markAllUnused(), this.shadowManager.markAllUnused();
			var e, i = this._svgRoot,
				n = this._visibleList,
				r = t.length,
				a = [];
			for (e = 0; r > e; e++) {
				var o = t[e],
					s = Mp(o),
					l = Ap(o) || kp(o);
				o.invisible || (o.__dirty && (s && s.brush(o), this.clipPathManager.update(o), o.style && (this.gradientManager.update(o.style.fill), this.gradientManager.update(o.style.stroke), this.shadowManager.update(l, o)), o.__dirty = !1), a.push(o))
			}
			var u, h = YI(n, a);
			for (e = 0; e < h.length; e++) {
				var c = h[e];
				if (c.removed)
					for (var d = 0; d < c.count; d++) {
						var o = n[c.indices[d]],
							l = Ap(o),
							f = kp(o);
						Dp(i, l), Dp(i, f)
					}
			}
			for (e = 0; e < h.length; e++) {
				var c = h[e];
				if (c.added)
					for (var d = 0; d < c.count; d++) {
						var o = a[c.indices[d]],
							l = Ap(o),
							f = kp(o);
						u ? Tp(i, l, u) : Cp(i, l), l ? Tp(i, f, l) : u ? Tp(i, f, u) : Cp(i, f), Tp(i, f, l), u = f || l || u, this.gradientManager.addWithoutUpdate(l || f, o), this.shadowManager.addWithoutUpdate(l || f, o), this.clipPathManager.markUsed(o)
					} else if (!c.removed)
						for (var d = 0; d < c.count; d++) {
							var o = a[c.indices[d]],
								l = Ap(o),
								f = kp(o),
								l = Ap(o),
								f = kp(o);
							this.gradientManager.markUsed(o), this.gradientManager.addWithoutUpdate(l || f, o), this.shadowManager.markUsed(o), this.shadowManager.addWithoutUpdate(l || f, o), this.clipPathManager.markUsed(o), f && Tp(i, f, l), u = l || f || u
						}
			}
			this.gradientManager.removeUnused(), this.clipPathManager.removeUnused(), this.shadowManager.removeUnused(), this._visibleList = a
		},
		_getDefs: function(t) {
			var e = this._svgDom,
				i = e.getElementsByTagName("defs");
			if (0 === i.length) {
				if (t) {
					var i = e.insertBefore(ep("defs"), e.firstChild);
					return i.contains || (i.contains = function(t) {
						var e = i.children;
						if (!e) return !1;
						for (var n = e.length - 1; n >= 0; --n)
							if (e[n] === t) return !0;
						return !1
					}), i
				}
				return null
			}
			return i[0]
		},
		resize: function(t, e) {
			var i = this._viewport;
			i.style.display = "none";
			var n = this._opts;
			if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width !== t || this._height !== e) {
				this._width = t, this._height = e;
				var r = i.style;
				r.width = t + "px", r.height = e + "px";
				var a = this._svgDom;
				a.setAttribute("width", t), a.setAttribute("height", e)
			}
			this._backgroundNode && (this._backgroundNode.setAttribute("width", t), this._backgroundNode.setAttribute("height", e))
		},
		getWidth: function() {
			return this._width
		},
		getHeight: function() {
			return this._height
		},
		_getSize: function(t) {
			var e = this._opts,
				i = ["width", "height"][t],
				n = ["clientWidth", "clientHeight"][t],
				r = ["paddingLeft", "paddingTop"][t],
				a = ["paddingRight", "paddingBottom"][t];
			if (null != e[i] && "auto" !== e[i]) return parseFloat(e[i]);
			var o = this.root,
				s = document.defaultView.getComputedStyle(o);
			return (o[n] || Sp(s[i]) || Sp(o.style[i])) - (Sp(s[r]) || 0) - (Sp(s[a]) || 0) | 0
		},
		dispose: function() {
			this.root.innerHTML = "", this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null
		},
		clear: function() {
			this._viewport && this.root.removeChild(this._viewport)
		},
		toDataURL: function() {
			this.refresh();
			var t = encodeURIComponent(this._svgDom.outerHTML.replace(/></g, ">\n\r<"));
			return "data:image/svg+xml;charset=UTF-8," + t
		}
	}, f(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "pathToImage"], function(t) {
		KI.prototype[t] = Pp(t)
	}), Jn("svg", KI), t.version = Kx, t.dependencies = $x, t.PRIORITY = hw, t.init = cu, t.connect = du, t.disConnect = fu, t.disconnect = Aw, t.dispose = pu, t.getInstanceByDom = gu, t.getInstanceById = vu, t.registerTheme = mu, t.registerPreprocessor = yu, t.registerProcessor = _u, t.registerPostUpdate = xu, t.registerAction = wu, t.registerCoordinateSystem = bu, t.getCoordinateSystemDimensions = Su, t.registerLayout = Mu, t.registerVisual = Iu, t.registerLoading = Cu, t.extendComponentModel = Du, t.extendComponentView = ku, t.extendSeriesModel = Au, t.extendChartView = Pu, t.setCanvasCreator = Lu, t.registerMap = Ou, t.getMap = Eu, t.dataTool = Pw, t.zrender = Yv, t.number = r_, t.format = c_, t.throttle = gl, t.helper = Lb, t.matrix = mg, t.vector = eg, t.color = Bg, t.parseGeoJSON = Eb, t.parseGeoJson = Nb, t.util = Fb, t.graphic = Vb, t.List = Gw, t.Model = go, t.Axis = Rb, t.env = zp
});